<!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="Abstract

a protocol for schema evolution in a globally distributed database management system with shared data, stateless servers, and no global membership.

asynchronous
all servers can access and update all data during a schema change



INTRODUCTION

Schema evolution:  the ability to change a database’s definition without the loss of data
F1 is built on top of Spanner, a globally distributed KV data store

Main feature
The main features of F1 that impact schema changes are:">  

  <title>
    
      Read Google F1
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="//localhost:1313/css/main.900100e9dbee2d56c58fac8bb717037cae7e26a9c36c29d2ff587bdd65f0cbbe510b41d81a3bb234919cdfdc7550d786b2fab70c8fc507772d732fe097106d12.css" integrity="sha512-kAEA6dvuLVbFj6yLtxcDfK5&#43;JqnDbCnS/1h73WXwy75RC0HYGjuyNJGc39x1UNeGsvq3DI/FB3ctcy/glxBtEg==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2023-08-14 21:46:24 &#43;0800 CST">
            2023-08-14
        </time>
    </p>

    <h1>Read Google F1</h1>

    
        <aside >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#abstract">Abstract</a></li>
    <li><a href="#introduction">INTRODUCTION</a>
      <ul>
        <li><a href="#main-feature">Main feature</a></li>
        <li><a href="#an-example">An example</a></li>
      </ul>
    </li>
    <li><a href="#background">BackGround</a>
      <ul>
        <li><a href="#key-value-store">Key-value store</a></li>
        <li><a href="#relational-schema">Relational schema</a></li>
        <li><a href="#row-representation">Row representation</a></li>
        <li><a href="#relational-operations">Relational operations</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </aside>
    

    <h2 id="abstract">Abstract</h2>
<ul>
<li>a protocol for schema evolution in a globally distributed database management system with <strong>shared data</strong>, <strong>stateless servers</strong>, and <strong>no global membership</strong>.
<ul>
<li><strong>asynchronous</strong></li>
<li>all servers can <strong>access</strong> and <strong>update</strong> all data during a schema change</li>
</ul>
</li>
</ul>
<h2 id="introduction">INTRODUCTION</h2>
<ul>
<li>Schema evolution:  the ability to change a database’s definition without the loss of data</li>
<li>F1 is built on top of Spanner, a globally distributed <strong>KV</strong> data store</li>
</ul>
<h3 id="main-feature">Main feature</h3>
<p>The main features of F1 that impact schema changes are:</p>
<ul>
<li>Massively distributed:
<ul>
<li>An instance of F1 consists of hundreds of individual F1 servers</li>
</ul>
</li>
<li>Relational schema:
<ul>
<li><strong>Each F1 server has a copy of a relational schema</strong> that describes tables, columns, indexes, and constraints.</li>
<li>Any modification to the schema requires a distributed schema change to update all servers</li>
</ul>
</li>
<li>Shared data storage:
<ul>
<li>All F1 servers in all datacenters <strong>have access to all data</strong> stored in Spanner.</li>
</ul>
</li>
<li>Stateless servers:
<ul>
<li>F1 servers must tolerate machine failures, preemption(取代), and loss of access to network resources
<ul>
<li>clients may <strong>connect to any F1 server</strong>, even for <strong>different statements in the same transaction</strong>.</li>
</ul>
</li>
</ul>
</li>
<li>No global membership:
<ul>
<li>no reliable mechanism for determining currently running F1 servers, and explicit <strong>global synchronization is not possible</strong></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/google-f1-arch.2024_02_12_1707671860.png" alt="image-20230814210030515"></p>
<p>several constraints on the schema change process:</p>
<ul>
<li>Full data availability:
<ul>
<li>the availability of the data managed by F1 is paramount(至为重要的)</li>
<li>it is unacceptable to take even a portion of the database offline during a schema change (e.g., locking a column to build an index).</li>
</ul>
</li>
<li>Minimal performance impact:
<ul>
<li>the F1 schema changes rapidly to support new features</li>
</ul>
</li>
<li>Asynchronous schema change
<ul>
<li>In other words, different F1 servers may transition to using a new schema at different times</li>
</ul>
</li>
</ul>
<p>These requirements influenced the design in several ways</p>
<ul>
<li>Since all data must be as available as possible, we do <strong>not restrict access to data undergoing reorganization</strong>.</li>
<li>Because the schema change must have minimal impact on user transactions, we allow transactions to <strong>span an arbitrary number of schema changes</strong>, although we do not automatically rewrite queries to conform to the schema in use</li>
<li>Applying schema changes asynchronously on individual F1 servers means that <strong>multiple versions of the schema may be in use simultaneously</strong></li>
</ul>
<h3 id="an-example">An example</h3>
<ul>
<li>Consider a schema change from schema <code>S1</code> to schema <code>S2</code> that adds index <code>I</code> on table <code>R</code></li>
<li>Assume two different servers, <code>M1</code> and <code>M2</code>, execute the following sequence of operations:
<ul>
<li>Server <code>M2</code>, using schema <code>S2</code>, inserts a new row <code>r</code> to table <code>R</code>. Because <code>S2</code> contains index <code>I</code>, server <code>M2</code> also adds a new index entry corresponding to <code>r</code> to the key– value store.</li>
<li>Server <code>M1</code>, using schema <code>S1</code>, deletes <code>r</code>. Because <code>S1</code> does not contain <code>I</code>, <code>M1</code> removes <code>r</code> from the key–value store but fails to remove the corresponding index entry in <code>I</code>.</li>
</ul>
</li>
<li>The second delete <strong>leaves the database corrupt.</strong></li>
</ul>
<p>We consider not only changes to the <strong>logical schema</strong>, such as the addition or removal of <strong>columns</strong>, but also changes to the physical schema like adding or removing <strong>secondary indexes</strong>.</p>
<p>By ensuring that:</p>
<ul>
<li>no more than two schema versions are in use at any given time</li>
<li>those schema versions have <strong>specific properties?</strong></li>
</ul>
<p>enables distributed schema changes in a way that</p>
<blockquote>
<p>does not require <strong>global membership</strong>, <strong>implicit or explicit synchronization</strong> between nodes, or the need to <strong>retain old schema versions</strong> once a schema change is complete</p></blockquote>
<h2 id="background">BackGround</h2>
<p>In this section, we:</p>
<ul>
<li>separate the <strong>interface provided by the key–value store</strong> from its implementation</li>
<li>show how we <strong>map traditional relational database features into this unique setting</strong></li>
</ul>
<h3 id="key-value-store">Key-value store</h3>
<ul>
<li>F1 assumes the key–value store supports three operations
<ul>
<li><em>put</em>: insert a value with a given key</li>
<li><em>del</em>: delete a value with a given key</li>
<li><em>get</em>: returns <strong>any stored values</strong> whose key <strong>matches a given prefix</strong></li>
<li>
<blockquote>
<p>Note that <em>put</em> and <em>del</em> reference exactly one key–value pair, while <em>get</em> may return multiple key–value pairs</p></blockquote>
</li>
</ul>
</li>
<li>Two more requirements
<ul>
<li><em>Commit timestamps</em>: Every key–value pair has a <strong>last-modified timestamp</strong> which is updated atomically by the key–value store</li>
<li><em>Atomic test-and-set support</em>:  Multiple <em>get</em> and <em>put</em> operations can be executed <strong>atomically</strong></li>
</ul>
</li>
</ul>
<h3 id="relational-schema">Relational schema</h3>
<ul>
<li>An F1 <strong>schema</strong> is a set of table definitions that enable F1 to <em>interpret the database located in the key–value store</em></li>
<li>Each table definition has:
<ul>
<li>a list of columns</li>
<li>a list of secondary indexes</li>
<li>a list of integrity constraints(foreign key or index uniqueness constraints)</li>
<li>a list of optimistic locks.
<ul>
<li>required columns that cannot be read directly by client transactions</li>
</ul>
</li>
</ul>
</li>
<li>A subset of columns in a table forms the primary key of the table</li>
<li>We call a column <strong>required</strong> if its value must be present in every row. All primary-key columns are implicitly required, while non-key columns may be either required or <strong>optional</strong></li>
</ul>
<h3 id="row-representation">Row representation</h3>
<ul>
<li>
<p>one pair for each non-primary-key column</p>
</li>
<li>
<p>Each key logically includes</p>
<ul>
<li>the name of the table,</li>
<li>the primary key values of the containing row,</li>
<li>the name of the column whose value is stored in the pair</li>
</ul>
</li>
<li>
<p>Although this appears to needlessly repeat all primary key values in the key for each column value, in practice, <strong>F1’s physical storage format eliminates this redundancy</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/google-f1-relational-representation.2024_02_12_1707672029.png" alt="">
<img src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/google-f1-kv-representation.2024_02_12_1707672075.png" alt=""></p>
<ul>
<li>A secondary index
<ul>
<li>covers a <strong>non-empty subset of columns</strong> on a table</li>
<li>is itself represented by <strong>a set of key–value pairs</strong> in the key– value store</li>
<li>Each row in the indexed table has an associated index key–value pair
<ul>
<li>The key for this pair is formed by concatenating
<ul>
<li>the table name</li>
<li>the index name</li>
<li>the row’s indexed column values</li>
<li>and the row’s primary key values</li>
</ul>
</li>
</ul>
</li>
<li>We denote the index key for row $r$ in index $I$ as $k_r(I)$</li>
<li>the special exists column doesn&rsquo;t have the associated value</li>
</ul>
</li>
</ul>
<h3 id="relational-operations">Relational operations</h3>
<p>F1 supports a set of standard relational operations:</p>
<ul>
<li>$insert(R,vk_r,vc_r)$ inserts row <em>r</em> to table <em>R</em> with primary key values $vk_r$ and non-key column values $vc_r$. Insert fails if a row with the same primary key values already exists in table R.</li>
<li>$delete (R, vk_r )$</li>
<li>$update(R,vk_r,vc_r)$</li>
<li>$query(\vec{R},\vec{C},P)$ :returns a projection $\vec{C}$ of rows from tables in $\vec{R}$ that satisfy predicate $P$ .</li>
</ul>

</article>

                
    
    
        Thanks for <a href="https://github.com/hanwenguo/hugo-theme-nostyleplease">https://github.com/hanwenguo/hugo-theme-nostyleplease</a>
    


            </div>
        </main>
    </body>
</html>
