<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="lsmTree
LSM-Tree 简介
LSM-Tree（Log-Structured Merge-Tree）是一种为高写入吞吐设计的存储结构，广泛应用于 NoSQL 数据库（如 LevelDB、RocksDB）。其核心思想是将随机写入转换为顺序写入，并通过分层合并优化数据管理。">  

  <title>
    
      lsmTree
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css" integrity="sha512-UWUjAtOpmL94h67Vws&#43;JFBu&#43;vfRaLI&#43;HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2025-03-03 22:34:36 &#43;0800 CST">
            2025-03-03
        </time>
    </p>

    <h1>lsmTree</h1>

    
        <aside >
            <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#lsm-tree-简介"><strong>LSM-Tree 简介</strong></a></li>
        <li><a href="#c-实现简易-lsm-tree"><strong>C++ 实现简易 LSM-Tree</strong></a></li>
        <li><a href="#实现说明"><strong>实现说明</strong></a></li>
        <li><a href="#优化方向"><strong>优化方向</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>
        </aside>
    

    <h1 id="lsmtree">lsmTree</h1>
<h3 id="lsm-tree-简介"><strong>LSM-Tree 简介</strong></h3>
<p>LSM-Tree（Log-Structured Merge-Tree）是一种为高写入吞吐设计的存储结构，广泛应用于 NoSQL 数据库（如 LevelDB、RocksDB）。其核心思想是将随机写入转换为顺序写入，并通过分层合并优化数据管理。</p>
<p>‍</p>
<p>​<img src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/lsmtree-20250303233520-zn8ytar.png" alt="lsmtree">​</p>
<hr>
<h4 id="lsm-tree-的核心组件"><strong>LSM-Tree 的核心组件</strong></h4>
<ol>
<li>
<p><strong>MemTable</strong></p>
<ul>
<li>内存中的可变数据结构（通常为跳表或平衡树），用于快速处理写入操作。</li>
<li>写入数据时，首先插入 MemTable。</li>
<li>当 MemTable 达到阈值时，转为不可变的 SSTable 并写入磁盘。</li>
</ul>
</li>
<li>
<p><strong>SSTable（Sorted String Table）</strong></p>
<ul>
<li>磁盘上的不可变有序文件，按层级组织。</li>
<li>每层包含多个 SSTable，高层级的数据量是低层级的倍数（如 10 倍）。</li>
</ul>
</li>
<li>
<p><strong>Compaction（合并）</strong></p>
<ul>
<li>当某层 SSTable 数量超过阈值时，触发合并操作。</li>
<li>合并相邻层的 SSTable，去重并删除无效数据，生成新的 SSTable 到下一层。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="lsm-tree-操作流程"><strong>LSM-Tree 操作流程</strong></h4>
<ol>
<li><strong>写入</strong>：数据先写入 MemTable。</li>
<li><strong>读取</strong>：先查 MemTable，再逐层查询 SSTable。</li>
<li><strong>删除</strong>：插入一个删除标记（Tombstone），合并时清理数据。</li>
<li><strong>合并</strong>：后台线程将小 SSTable 合并为大 SSTable，减少查询时的 I/O 开销。</li>
</ol>
<hr>
<h3 id="c-实现简易-lsm-tree"><strong>C++ 实现简易 LSM-Tree</strong></h3>
<h4 id="1-内存表memtable实现"><strong>1. 内存表（MemTable）实现</strong></h4>
<p>使用 <code>std::map</code>​ 模拟内存中的有序结构。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#e5e5e5">#include map&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#include string&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#include vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#include fstream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#include sstream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00">class</span> MemTable {
</span></span><span style="display:flex;"><span><span style="color:#f00">private</span>:
</span></span><span style="display:flex;"><span>    std::map&lt;std::string, std::string&gt; data;
</span></span><span style="display:flex;"><span>    size_t max_size;
</span></span><span style="display:flex;"><span>    <span style="color:#ee82ee">bool</span> tombstone = false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">public</span>:
</span></span><span style="display:flex;"><span>    MemTable(size_t max_size = <span style="color:#f60">1024</span>) : max_size(max_size) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 插入或更新键值对
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">void</span> <span style="color:#ff0">put</span>(<span style="color:#f00">const</span> std::string&amp; key, <span style="color:#f00">const</span> std::string&amp; value) {
</span></span><span style="display:flex;"><span>        data[key] = value;
</span></span><span style="display:flex;"><span>        <span style="color:#f00">if</span> (data.size() &gt;= max_size) {
</span></span><span style="display:flex;"><span>            tombstone = true; <span style="color:#0f0">// 标记为可转储
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 标记删除
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">void</span> <span style="color:#ff0">remove</span>(<span style="color:#f00">const</span> std::string&amp; key) {
</span></span><span style="display:flex;"><span>        data[key] = <span style="color:#87ceeb">&#34;TOMBSTONE&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 查找键值
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    std::string get(<span style="color:#f00">const</span> std::string&amp; key) {
</span></span><span style="display:flex;"><span>        <span style="color:#f00">auto</span> it = data.find(key);
</span></span><span style="display:flex;"><span>        <span style="color:#f00">if</span> (it != data.end()) {
</span></span><span style="display:flex;"><span>            <span style="color:#f00">return</span> it-&gt;second;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00">return</span> <span style="color:#87ceeb">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 判断是否需要转储到磁盘
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">bool</span> <span style="color:#ff0">need_flush</span>() <span style="color:#f00">const</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#f00">return</span> tombstone;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 获取所有键值对（按序）
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; export_data() {
</span></span><span style="display:flex;"><span>        <span style="color:#f00">return</span> std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;(data.begin(), data.end());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 清空内存表
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">void</span> <span style="color:#ff0">clear</span>() {
</span></span><span style="display:flex;"><span>        data.clear();
</span></span><span style="display:flex;"><span>        tombstone = false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h4 id="2-sstable-实现"><strong>2. SSTable 实现</strong></h4>
<p>将内存表数据写入有序文件，支持从文件加载数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#f00">class</span> SSTable {
</span></span><span style="display:flex;"><span><span style="color:#f00">private</span>:
</span></span><span style="display:flex;"><span>    std::string filename;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">public</span>:
</span></span><span style="display:flex;"><span>    SSTable(<span style="color:#f00">const</span> std::string&amp; filename) : filename(filename) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 将内存表数据写入 SSTable 文件
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">void</span> <span style="color:#ff0">write</span>(<span style="color:#f00">const</span> std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;&amp; data) {
</span></span><span style="display:flex;"><span>        std::ofstream file(filename, std::ios::binary);
</span></span><span style="display:flex;"><span>        <span style="color:#f00">for</span> (<span style="color:#f00">const</span> <span style="color:#f00">auto</span>&amp; entry : data) {
</span></span><span style="display:flex;"><span>            file &lt; entry.first &lt; <span style="color:#87ceeb">&#34;,&#34;</span> &lt; entry.second &lt; <span style="color:#87ceeb">&#34;</span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        file.close();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 从 SSTable 文件中查找键值
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    std::string read(<span style="color:#f00">const</span> std::string&amp; key) {
</span></span><span style="display:flex;"><span>        std::ifstream file(filename, std::ios::binary);
</span></span><span style="display:flex;"><span>        std::string line;
</span></span><span style="display:flex;"><span>        <span style="color:#f00">while</span> (std::getline(file, line)) {
</span></span><span style="display:flex;"><span>            std::istringstream iss(line);
</span></span><span style="display:flex;"><span>            std::string k, v;
</span></span><span style="display:flex;"><span>            std::getline(iss, k, <span style="color:#87ceeb">&#39;,&#39;</span>);
</span></span><span style="display:flex;"><span>            std::getline(iss, v);
</span></span><span style="display:flex;"><span>            <span style="color:#f00">if</span> (k == key) {
</span></span><span style="display:flex;"><span>                <span style="color:#f00">return</span> v;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00">return</span> <span style="color:#87ceeb">&#34;&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h4 id="3-lsm-tree-主逻辑"><strong>3. LSM-Tree 主逻辑</strong></h4>
<p>管理内存表和 SSTable 的层级合并。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#e5e5e5">#include vector&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#include filesystem&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5"></span><span style="color:#f00">namespace</span> fs = std::filesystem;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">class</span> LSMTree {
</span></span><span style="display:flex;"><span><span style="color:#f00">private</span>:
</span></span><span style="display:flex;"><span>    MemTable memtable;
</span></span><span style="display:flex;"><span>    std::vector&lt;std::vector&lt;SSTable&gt;&gt; levels;
</span></span><span style="display:flex;"><span>    size_t level0_max = <span style="color:#f60">4</span>;  <span style="color:#0f0">// Level 0 最多容纳 4 个 SSTable
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00">public</span>:
</span></span><span style="display:flex;"><span>    LSMTree() {
</span></span><span style="display:flex;"><span>        levels.resize(<span style="color:#f60">2</span>);  <span style="color:#0f0">// 简化实现：仅 Level 0 和 Level 1
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 插入数据
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">void</span> <span style="color:#ff0">put</span>(<span style="color:#f00">const</span> std::string&amp; key, <span style="color:#f00">const</span> std::string&amp; value) {
</span></span><span style="display:flex;"><span>        memtable.put(key, value);
</span></span><span style="display:flex;"><span>        <span style="color:#f00">if</span> (memtable.need_flush()) {
</span></span><span style="display:flex;"><span>            flush_memtable();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 删除数据
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">void</span> <span style="color:#ff0">remove</span>(<span style="color:#f00">const</span> std::string&amp; key) {
</span></span><span style="display:flex;"><span>        memtable.remove(key);
</span></span><span style="display:flex;"><span>        <span style="color:#f00">if</span> (memtable.need_flush()) {
</span></span><span style="display:flex;"><span>            flush_memtable();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 查找数据
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    std::string get(<span style="color:#f00">const</span> std::string&amp; key) {
</span></span><span style="display:flex;"><span>        <span style="color:#0f0">// 先查内存表
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        std::string value = memtable.get(key);
</span></span><span style="display:flex;"><span>        <span style="color:#f00">if</span> (!value.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#f00">return</span> (value == <span style="color:#87ceeb">&#34;TOMBSTONE&#34;</span>) ? <span style="color:#87ceeb">&#34;[DELETED]&#34;</span> : value;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0f0">// 再查磁盘中的 SSTable（从 Level 0 到 Level 1）
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        <span style="color:#f00">for</span> (<span style="color:#f00">auto</span>&amp; level : levels) {
</span></span><span style="display:flex;"><span>            <span style="color:#f00">for</span> (<span style="color:#f00">auto</span>&amp; sstable : level) {
</span></span><span style="display:flex;"><span>                value = sstable.read(key);
</span></span><span style="display:flex;"><span>                <span style="color:#f00">if</span> (!value.empty()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#f00">return</span> (value == <span style="color:#87ceeb">&#34;TOMBSTONE&#34;</span>) ? <span style="color:#87ceeb">&#34;[DELETED]&#34;</span> : value;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#f00">return</span> <span style="color:#87ceeb">&#34;[NOT FOUND]&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">private</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 将内存表转储为 Level 0 的 SSTable
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">void</span> flush_memtable() {
</span></span><span style="display:flex;"><span>        <span style="color:#f00">auto</span> data = memtable.export_data();
</span></span><span style="display:flex;"><span>        std::string filename = <span style="color:#87ceeb">&#34;sstable_level0_&#34;</span> + std::to_string(levels[<span style="color:#f60">0</span>].size()) + <span style="color:#87ceeb">&#34;.dat&#34;</span>;
</span></span><span style="display:flex;"><span>        SSTable <span style="color:#ff0">sstable</span>(filename);
</span></span><span style="display:flex;"><span>        sstable.write(data);
</span></span><span style="display:flex;"><span>        levels[<span style="color:#f60">0</span>].push_back(sstable);
</span></span><span style="display:flex;"><span>        memtable.clear();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0f0">// 触发 Level 0 合并
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        <span style="color:#f00">if</span> (levels[<span style="color:#f60">0</span>].size() &gt;= level0_max) {
</span></span><span style="display:flex;"><span>            compact_level(<span style="color:#f60">0</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 合并层级
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#ee82ee">void</span> <span style="color:#ff0">compact_level</span>(<span style="color:#ee82ee">int</span> level) {
</span></span><span style="display:flex;"><span>        std::vector&lt;SSTable&gt; merged_tables;
</span></span><span style="display:flex;"><span>        std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; merged_data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0f0">// 读取当前层级所有 SSTable 的数据
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        <span style="color:#f00">for</span> (<span style="color:#f00">auto</span>&amp; sstable : levels[level]) {
</span></span><span style="display:flex;"><span>            <span style="color:#0f0">// 模拟读取所有键值对（实际需实现迭代器）
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>            std::ifstream file(sstable.filename);
</span></span><span style="display:flex;"><span>            std::string line;
</span></span><span style="display:flex;"><span>            <span style="color:#f00">while</span> (std::getline(file, line)) {
</span></span><span style="display:flex;"><span>                std::istringstream iss(line);
</span></span><span style="display:flex;"><span>                std::string key, value;
</span></span><span style="display:flex;"><span>                std::getline(iss, key, <span style="color:#87ceeb">&#39;,&#39;</span>);
</span></span><span style="display:flex;"><span>                std::getline(iss, value);
</span></span><span style="display:flex;"><span>                merged_data.emplace_back(key, value);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            file.close();
</span></span><span style="display:flex;"><span>            fs::remove(sstable.filename); <span style="color:#0f0">// 删除旧文件
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0f0">// 去重和删除标记处理
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        std::map&lt;std::string, std::string&gt; temp_map;
</span></span><span style="display:flex;"><span>        <span style="color:#f00">for</span> (<span style="color:#f00">const</span> <span style="color:#f00">auto</span>&amp; entry : merged_data) {
</span></span><span style="display:flex;"><span>            <span style="color:#f00">if</span> (entry.second != <span style="color:#87ceeb">&#34;TOMBSTONE&#34;</span>) {
</span></span><span style="display:flex;"><span>                temp_map[entry.first] = entry.second;
</span></span><span style="display:flex;"><span>            } <span style="color:#f00">else</span> {
</span></span><span style="display:flex;"><span>                temp_map.erase(entry.first);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0f0">// 写入下一层级
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; new_data(temp_map.begin(), temp_map.end());
</span></span><span style="display:flex;"><span>        std::string filename = <span style="color:#87ceeb">&#34;sstable_level1_&#34;</span> + std::to_string(levels[<span style="color:#f60">1</span>].size()) + <span style="color:#87ceeb">&#34;.dat&#34;</span>;
</span></span><span style="display:flex;"><span>        SSTable new_sstable(filename);
</span></span><span style="display:flex;"><span>        new_sstable.write(new_data);
</span></span><span style="display:flex;"><span>        levels[<span style="color:#f60">1</span>].push_back(new_sstable);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0f0">// 清空当前层级
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>        levels[level].clear();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><hr>
<h4 id="4-测试示例"><strong>4. 测试示例</strong></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#e5e5e5">#include iostream&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5"></span>
</span></span><span style="display:flex;"><span><span style="color:#ee82ee">int</span> <span style="color:#ff0">main</span>() {
</span></span><span style="display:flex;"><span>    LSMTree lsm;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 插入数据
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    lsm.put(<span style="color:#87ceeb">&#34;name&#34;</span>, <span style="color:#87ceeb">&#34;Alice&#34;</span>);
</span></span><span style="display:flex;"><span>    lsm.put(<span style="color:#87ceeb">&#34;age&#34;</span>, <span style="color:#87ceeb">&#34;30&#34;</span>);
</span></span><span style="display:flex;"><span>    std::cout &lt; <span style="color:#87ceeb">&#34;Get name: &#34;</span> &lt; lsm.get(<span style="color:#87ceeb">&#34;name&#34;</span>) &lt; std::endl;  <span style="color:#0f0">// Alice
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 删除数据
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    lsm.remove(<span style="color:#87ceeb">&#34;age&#34;</span>);
</span></span><span style="display:flex;"><span>    std::cout &lt; <span style="color:#87ceeb">&#34;Get age: &#34;</span> &lt; lsm.get(<span style="color:#87ceeb">&#34;age&#34;</span>) &lt; std::endl;    <span style="color:#0f0">// [DELETED]
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#0f0">// 强制触发合并
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>    <span style="color:#f00">for</span> (<span style="color:#ee82ee">int</span> i = <span style="color:#f60">0</span>; i  <span style="color:#f60">5</span>; i++) {
</span></span><span style="display:flex;"><span>        lsm.put(<span style="color:#87ceeb">&#34;key&#34;</span> + std::to_string(i), <span style="color:#87ceeb">&#34;value&#34;</span> + std::to_string(i));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std::cout &lt; <span style="color:#87ceeb">&#34;Get key3: &#34;</span> &lt; lsm.get(<span style="color:#87ceeb">&#34;key3&#34;</span>) &lt; std::endl;  <span style="color:#0f0">// value3
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="实现说明"><strong>实现说明</strong></h3>
<ol>
<li><strong>MemTable</strong>：使用 <code>std::map</code>​ 模拟有序内存表，支持插入、删除和查找。</li>
<li><strong>SSTable</strong>：将数据按 CSV 格式写入文件，简化查询逻辑。</li>
<li><strong>合并策略</strong>：当 Level 0 的 SSTable 数量超过阈值时，合并到 Level 1。</li>
<li><strong>删除处理</strong>：通过 Tombstone 标记实现惰性删除，合并时清理数据。</li>
</ol>
<hr>
<h3 id="优化方向"><strong>优化方向</strong></h3>
<ol>
<li><strong>跳表实现</strong>：替换 <code>std::map</code>​ 为自定义跳表，提高并发写入性能。</li>
<li><strong>Bloom Filter</strong>：为 SSTable 添加布隆过滤器，加速查询。</li>
<li><strong>多线程合并</strong>：后台线程异步执行合并操作，避免阻塞写入。</li>
<li><strong>文件格式优化</strong>：使用二进制格式（如 Protobuf）存储 SSTable，减少 I/O 开销。</li>
</ol>
<hr>
<p>通过上述实现，可以理解 LSM-Tree 的核心设计思想，并在此基础上扩展为生产级存储引擎。</p>
<p>‍</p>

</article>

                
    
    
        <hr>
<p>written by mobilephone724</p>
    


            </div>
        </main>
    </body>
</html>
