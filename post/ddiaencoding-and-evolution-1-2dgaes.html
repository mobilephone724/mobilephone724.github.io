<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DDIA--Encoding and Evolution(1) | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="DDIA&ndash;Encoding and Evolution(1) Compatibility Backward compatibility: Newer code can read data that was written by older code. Forward compatibility: Older code can read data that was written by newer code. ‍ Thrift and Protocol Buffers Apache Thrift and Protocol Buffers (protobuf) are binary encoding libraries that are based on the same principle. ‍ In Thrift, you would describe the schema in the Thrift interface definition language (IDL) like this: struct">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://mobilephone724.github.io/post/ddiaencoding-and-evolution-1-2dgaes.html">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://mobilephone724.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mobilephone724.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mobilephone724.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mobilephone724.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mobilephone724.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://mobilephone724.github.io/post/ddiaencoding-and-evolution-1-2dgaes.html">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://mobilephone724.github.io/post/ddiaencoding-and-evolution-1-2dgaes.html">
  <meta property="og:site_name" content="PaperMod">
  <meta property="og:title" content="DDIA--Encoding and Evolution(1)">
  <meta property="og:description" content="DDIA–Encoding and Evolution(1) Compatibility Backward compatibility: Newer code can read data that was written by older code. Forward compatibility: Older code can read data that was written by newer code. ‍ Thrift and Protocol Buffers Apache Thrift and Protocol Buffers (protobuf) are binary encoding libraries that are based on the same principle. ‍ In Thrift, you would describe the schema in the Thrift interface definition language (IDL) like this: struct">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-18T23:03:23+08:00">
    <meta property="article:modified_time" content="2025-03-18T23:30:22+08:00">
      <meta property="og:image" content="https://mobilephone724.github.io/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://mobilephone724.github.io/images/papermod-cover.png">
<meta name="twitter:title" content="DDIA--Encoding and Evolution(1)">
<meta name="twitter:description" content="DDIA&ndash;Encoding and Evolution(1) Compatibility Backward compatibility: Newer code can read data that was written by older code. Forward compatibility: Older code can read data that was written by newer code. ‍ Thrift and Protocol Buffers Apache Thrift and Protocol Buffers (protobuf) are binary encoding libraries that are based on the same principle. ‍ In Thrift, you would describe the schema in the Thrift interface definition language (IDL) like this: struct">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mobilephone724.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "DDIA--Encoding and Evolution(1)",
      "item": "https://mobilephone724.github.io/post/ddiaencoding-and-evolution-1-2dgaes.html"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DDIA--Encoding and Evolution(1)",
  "name": "DDIA--Encoding and Evolution(1)",
  "description": "DDIA\u0026ndash;Encoding and Evolution(1) Compatibility Backward compatibility: Newer code can read data that was written by older code. Forward compatibility: Older code can read data that was written by newer code. ‍ Thrift and Protocol Buffers Apache Thrift and Protocol Buffers (protobuf) are binary encoding libraries that are based on the same principle. ‍ In Thrift, you would describe the schema in the Thrift interface definition language (IDL) like this: struct",
  "keywords": [
    
  ],
  "articleBody": "DDIA–Encoding and Evolution(1) Compatibility Backward compatibility: Newer code can read data that was written by older code. Forward compatibility: Older code can read data that was written by newer code. ‍\nThrift and Protocol Buffers Apache Thrift and Protocol Buffers (protobuf) are binary encoding libraries that are based on the same principle.\n‍\nIn Thrift, you would describe the schema in the Thrift interface definition language (IDL) like this:\nstruct Person { 1: required string userName, 2: optional i64 favoriteNumber, 3: optional list\u003cstring\u003e interests } ‍\nThe equivalent schema definition for Protocol Buffers looks very similar:\nmessage Person { required string user_name = 1; optional int64 favorite_number = 2; repeated string interests = 3; } ‍\nThrift BinaryProtocol ​​\nEach field has (1)a type annotation (to indicate whether it is a string, integer, list, etc.) and, where required, (2)a length indication (length of a string, number of items in a list).\nThere are no field names (userName, favoriteNumber, interests). Instead, the encoded data contains field tags, which are numbers (1, 2, and 3).\n‍\nThrift CompactProtocol ​​\nIt packs the same information into only 34 bytes. It does this by (1) packing the field type and tag number into a single byte, and by (2)using variable-length integers. Rather than using a full eight bytes for the number 1337, it is encoded in two bytes, with the top bit of each byte used to indicate whether there are still more bytes to come.\nSee “Base 128 Varint Encoding” for detail\n‍\nProtocol Buffers ​​\n‍\nin the schemas shown earlier, each field was marked either required or optional, but this makes no difference to how the field is encoded (nothing in the binary data indicates whether a field was required). The difference is simply that required enables a runtime check that fails if the field is not set, which can be useful for catching bugs.\n‍\nField tags and schema evolution We said previously that schemas inevitably need to change over time. We call this schema evolution.\nEach field is identified by its tag number (the numbers 1, 2, 3 in the\nsample schemas) and annotated with a datatype (e.g., string or integer). (1) If a field value is not set, it is simply omitted from the encoded record. From this you can see that field tags are critical to the meaning of the encoded data. (2) You can change the name of a field in the schema, since the encoded data never refers to field names, but you cannot change a field’s tag, since that would make all existing encoded data invalid.\nOmit a non-set value change the name instead of the tag ‍\nYou can add new fields to the schema, provided that you give each field a new tag number. If old code (which doesn’t know about the new tag numbers you added) tries to read data written by new code, including a new field with a tag number it doesn’t recognize, it can simply ignore that field. The datatype annotation allows the\nparser to determine how many bytes it needs to skip. This maintains forward compatibility: old code can read records that were written by new code.\nOld code ignores the tag that it doesn’t recognize\n‍\nWhat about backward compatibility? As long as each field has a unique tag number, new code can always read old data, because the tag numbers still have the same meaning. The only detail is that if you add a new field, you cannot make it required. If you were to add a field and make it required, that check would fail if new code read data written by old code, because the old code will not have written the new field that you added. Therefore, to maintain backward compatibility, every field you add after the initial deployment of the schema must be optional or have a default value.\nNew added field can’t be required\n‍\nRemoving a field is just like adding a field, with backward and forward compatibility concerns reversed. That means you can only remove a field that is optional (a required field can never be removed), and you can never use the same tag number again (because you may still have data written somewhere that includes the old tag number, and that field must be ignored by new code).\nCan remove optional field only and can’t use the same tag number again.\n‍\nBase 128 Varint Encoding Base 128 Varint Encoding is a method used to encode integers into a variable number of bytes, where each byte represents a 7-bit chunk of the integer. The most significant bit (MSB) of each byte is used as a flag to indicate whether there are more bytes to follow. This approach allows smaller integers to be stored in fewer bytes, optimizing space efficiency.\nHow it Works Split the Integer into 7-bit Chunks\nThe integer is divided into groups of 7 bits, starting from the least significant bit (LSB). Each group is stored in a separate byte.\nAdd the MSB Flag\nIf there are more 7-bit chunks to encode, the MSB of the byte is set to 1​. If the current byte is the last one, the MSB is set to 0​. Store the Bytes\nThe bytes are stored in sequence, with the least significant byte first.\nEncoding Process Convert the integer to its binary representation.\nSplit the binary number into 7-bit chunks, starting from the LSB.\nFor each chunk, add the MSB flag:\nSet MSB to 1​ if there are more chunks. Set MSB to 0​ if it’s the last chunk. Store the resulting bytes in order.\nExample: Encoding the Integer ​300​​ Binary Representation of 300:\n​100101100​ (9 bits)\nSplit into 7-bit Chunks:\n​0101100​ (LSB, first chunk) ​0000010​ (MSB, second chunk) Add MSB Flags:\nFirst chunk: 10101100​ (0xAC​) (MSB set to 1​ because there’s another chunk). Second chunk: 00000010​ (0x02​) (MSB set to 0​ because it’s the last chunk). Final Encoded Result:\n​[0xAC, 0x02]​\nKey Points MSB as a Continuation Flag:\nThe MSB of each byte indicates whether the next byte is part of the same integer. Variable-Length Encoding:\nSmaller integers use fewer bytes, while larger integers use more bytes. Efficiency:\nThis method is particularly efficient for encoding small integers, as it avoids the fixed overhead of using a fixed number of bytes (e.g., 4 bytes for a 32-bit integer). Decoding Process To decode a Varint-encoded integer:\nRead each byte sequentially.\nCheck the MSB of each byte:\nIf MSB is 1​, the next byte is part of the same integer. If MSB is 0​, the current byte is the last one. Combine the 7-bit chunks to reconstruct the original integer.\nWhy Use Base 128 Varint Encoding? Space Savings:\nIt reduces the number of bytes needed to store integers, especially for small values. Flexibility:\nIt can handle integers of arbitrary size without requiring a fixed-length format. Compatibility:\nIt is widely used in protocols like Thrift and Protocol Buffers for efficient data serialization. Summary Base 128 Varint Encoding is a compact and efficient way to store integers by splitting them into 7-bit chunks and using the MSB of each byte as a continuation flag. This method is particularly useful in scenarios where space optimization is critical, such as in network protocols or data storage systems.\n",
  "wordCount" : "1325",
  "inLanguage": "en",
  "image": "https://mobilephone724.github.io/images/papermod-cover.png","datePublished": "2025-03-18T23:03:23+08:00",
  "dateModified": "2025-03-18T23:30:22+08:00",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mobilephone724.github.io/post/ddiaencoding-and-evolution-1-2dgaes.html"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mobilephone724.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mobilephone724.github.io/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mobilephone724.github.io/article" title="长文">
                    <span>长文</span>
                </a>
            </li>
            <li>
                <a href="https://mobilephone724.github.io/archives" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://mobilephone724.github.io/search/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://mobilephone724.github.io/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://mobilephone724.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://mobilephone724.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      DDIA--Encoding and Evolution(1)
    </h1>
    <div class="post-meta"><span title='2025-03-18 23:03:23 +0800 CST'>March 18, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/mobilephone724/hugoBlog/tree/content/posts/ddiaencoding-and-evolution-1-2dgaes.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#ddia--encoding-and-evolution1" aria-label="DDIA&ndash;Encoding and Evolution(1)">DDIA&ndash;Encoding and Evolution(1)</a><ul>
                        
                <li>
                    <a href="#compatibility" aria-label="Compatibility">Compatibility</a></li>
                <li>
                    <a href="#thrift-and-protocol-buffers" aria-label="Thrift and Protocol Buffers">Thrift and Protocol Buffers</a><ul>
                        
                <li>
                    <a href="#thrift-binaryprotocol" aria-label="Thrift BinaryProtocol">Thrift BinaryProtocol</a></li>
                <li>
                    <a href="#thrift-compactprotocol" aria-label="Thrift CompactProtocol">Thrift CompactProtocol</a></li></ul>
                </li>
                <li>
                    <a href="#protocol-buffers" aria-label="Protocol Buffers">Protocol Buffers</a></li>
                <li>
                    <a href="#field-tags-and-schema-evolution" aria-label="Field tags and schema evolution">Field tags and schema evolution</a></li>
                <li>
                    <a href="#base-128-varint-encoding" aria-label="Base 128 Varint Encoding">Base 128 Varint Encoding</a><ul>
                        
                <li>
                    <a href="#how-it-works" aria-label="How it Works">How it Works</a></li>
                <li>
                    <a href="#encoding-process" aria-label="Encoding Process">Encoding Process</a></li>
                <li>
                    <a href="#example-encoding-the-integer-300" aria-label="Example: Encoding the Integer ​300​​">Example: Encoding the Integer ​300​​</a></li>
                <li>
                    <a href="#key-points" aria-label="Key Points">Key Points</a></li>
                <li>
                    <a href="#decoding-process" aria-label="Decoding Process">Decoding Process</a></li>
                <li>
                    <a href="#why-use-base-128-varint-encoding" aria-label="Why Use Base 128 Varint Encoding?">Why Use Base 128 Varint Encoding?</a></li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="ddia--encoding-and-evolution1">DDIA&ndash;Encoding and Evolution(1)<a hidden class="anchor" aria-hidden="true" href="#ddia--encoding-and-evolution1">#</a></h1>
<h2 id="compatibility">Compatibility<a hidden class="anchor" aria-hidden="true" href="#compatibility">#</a></h2>
<ul>
<li>Backward compatibility: Newer code can read data that was written by older code.</li>
<li>Forward compatibility: Older code can read data that was written by newer code.</li>
</ul>
<p>‍</p>
<h2 id="thrift-and-protocol-buffers">Thrift and Protocol Buffers<a hidden class="anchor" aria-hidden="true" href="#thrift-and-protocol-buffers">#</a></h2>
<p>Apache Thrift and Protocol Buffers (protobuf) are binary encoding libraries that are based on the same principle.</p>
<p>‍</p>
<p>In Thrift, you would describe the schema in the Thrift <strong>interface definition language</strong> (<strong>IDL</strong>) like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span><span class="o">:</span> <span class="n">required</span> <span class="n">string</span> <span class="n">userName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span><span class="o">:</span> <span class="n">optional</span> <span class="n">i64</span> <span class="n">favoriteNumber</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span><span class="o">:</span> <span class="n">optional</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">interests</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>‍</p>
<p>The equivalent schema definition for Protocol Buffers looks very similar:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">message</span> <span class="n">Person</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="n">required</span> <span class="n">string</span> <span class="n">user_name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">optional</span> <span class="n">int64</span> <span class="n">favorite_number</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">repeated</span> <span class="n">string</span> <span class="n">interests</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>‍</p>
<h3 id="thrift-binaryprotocol">Thrift BinaryProtocol<a hidden class="anchor" aria-hidden="true" href="#thrift-binaryprotocol">#</a></h3>
<p>​<img alt="image" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/image-20250318230834-58zd7vk.png">​</p>
<p>Each field has  <strong>(1)a type annotation</strong> (to indicate whether it is a string, integer, list, etc.) and, where required, (2)<strong>a length indication</strong> (length of a string, number of items in a list).</p>
<p>There are no field names (userName, favoriteNumber, interests). Instead, the encoded data contains <strong>field tags</strong>, which are numbers (1, 2, and 3).</p>
<p>‍</p>
<h3 id="thrift-compactprotocol">Thrift CompactProtocol<a hidden class="anchor" aria-hidden="true" href="#thrift-compactprotocol">#</a></h3>
<p>​<img alt="image" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/image-20250318231100-ske1qmo.png">​</p>
<p>It packs the same information into only 34 bytes. It does this by (1) <strong>packing the field type and tag number into a single byte</strong>, and by (2)<strong>using variable-length integers</strong>. Rather than using a full eight bytes for the number 1337, it is encoded in two bytes, <strong>with the top bit of each byte used to indicate whether there are still more bytes to come.</strong></p>
<p>See &ldquo;<strong>Base 128 Varint Encoding</strong>&rdquo; for detail</p>
<p>‍</p>
<h2 id="protocol-buffers">Protocol Buffers<a hidden class="anchor" aria-hidden="true" href="#protocol-buffers">#</a></h2>
<p>​<img alt="image" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/image-20250318232012-d80u44j.png">​</p>
<p>‍</p>
<p>in the schemas shown earlier, each field was marked either required or optional, but this makes no difference to how the field is encoded (nothing in the binary data indicates whether a field was required). The difference is simply that required enables a runtime check that fails if the field is not set, which can be useful for catching bugs.</p>
<p>‍</p>
<h2 id="field-tags-and-schema-evolution">Field tags and schema evolution<a hidden class="anchor" aria-hidden="true" href="#field-tags-and-schema-evolution">#</a></h2>
<p>We said previously that schemas inevitably need to change over time. We call this <strong>schema evolution</strong>.</p>
<blockquote>
<p>Each field is identified by its tag number (the numbers 1, 2, 3 in the<br>
sample schemas) and annotated with a datatype (e.g., string or integer).  <strong>(1)</strong>  If a field value is not set, it is simply omitted from the encoded record. From this you can see that field tags are critical to the meaning of the encoded data.  <strong>(2)</strong> You can change the name of a field in the schema, since the encoded data never refers to field names, but you cannot change a field’s tag, since that would make all existing encoded data invalid.</p>
</blockquote>
<ol>
<li>Omit a non-set value</li>
<li>change the name instead of the tag</li>
</ol>
<p>‍</p>
<blockquote>
<p>You can add new fields to the schema, provided that you give each field a new tag number. If old code (which doesn’t know about the new tag numbers you added) tries to read data written by new code, including a new field with a tag number it doesn’t recognize, it can simply ignore that field. The datatype annotation allows the<br>
parser to determine how many bytes it needs to skip. This maintains forward compatibility: old code can read records that were written by new code.</p>
</blockquote>
<p>Old code ignores the tag that it doesn&rsquo;t recognize</p>
<p>‍</p>
<blockquote>
<p>What about backward compatibility? As long as each field has a unique tag number, new code can always read old data, because the tag numbers still have the same meaning. The only detail is that if you add a new field, you cannot make it required. If you were to add a field and make it required, that check would fail if new code read data written by old code, because the old code will not have written the new field that you added. Therefore, to maintain backward compatibility, every field you add after the initial deployment of the schema must be optional or have a default value.</p>
</blockquote>
<p>New added field can&rsquo;t be required</p>
<p>‍</p>
<blockquote>
<p>Removing a field is just like adding a field, with backward and forward compatibility concerns reversed. That means you can only remove a field that is optional (a required field can never be removed), and you can never use the same tag number again (because you may still have data written somewhere that includes the old tag number, and that field must be ignored by new code).</p>
</blockquote>
<p>Can remove optional field only and can&rsquo;t use the same tag number again.</p>
<p>‍</p>
<h2 id="base-128-varint-encoding"><strong>Base 128 Varint Encoding</strong><a hidden class="anchor" aria-hidden="true" href="#base-128-varint-encoding">#</a></h2>
<p><strong>Base 128 Varint Encoding</strong> is a method used to encode integers into a variable number of bytes, where each byte represents a 7-bit chunk of the integer. The most significant bit (MSB) of each byte is used as a flag to indicate whether there are more bytes to follow. This approach allows smaller integers to be stored in fewer bytes, optimizing space efficiency.</p>
<hr>
<h3 id="how-it-works"><strong>How it Works</strong><a hidden class="anchor" aria-hidden="true" href="#how-it-works">#</a></h3>
<ol>
<li>
<p><strong>Split the Integer into 7-bit Chunks</strong><br>
The integer is divided into groups of 7 bits, starting from the least significant bit (LSB). Each group is stored in a separate byte.</p>
</li>
<li>
<p><strong>Add the MSB Flag</strong></p>
<ul>
<li>If there are more 7-bit chunks to encode, the MSB of the byte is set to <code>1</code>​.</li>
<li>If the current byte is the last one, the MSB is set to <code>0</code>​.</li>
</ul>
</li>
<li>
<p><strong>Store the Bytes</strong><br>
The bytes are stored in sequence, with the least significant byte first.</p>
</li>
</ol>
<hr>
<h3 id="encoding-process"><strong>Encoding Process</strong><a hidden class="anchor" aria-hidden="true" href="#encoding-process">#</a></h3>
<ol>
<li>
<p>Convert the integer to its binary representation.</p>
</li>
<li>
<p>Split the binary number into 7-bit chunks, starting from the LSB.</p>
</li>
<li>
<p>For each chunk, add the MSB flag:</p>
<ul>
<li>Set MSB to <code>1</code>​ if there are more chunks.</li>
<li>Set MSB to <code>0</code>​ if it&rsquo;s the last chunk.</li>
</ul>
</li>
<li>
<p>Store the resulting bytes in order.</p>
</li>
</ol>
<hr>
<h3 id="example-encoding-the-integer-300"><strong>Example: Encoding the Integer</strong> <strong>​<code>300</code>​</strong>​<a hidden class="anchor" aria-hidden="true" href="#example-encoding-the-integer-300">#</a></h3>
<ol>
<li>
<p><strong>Binary Representation of 300</strong>:<br>
​<code>100101100</code>​ (9 bits)</p>
</li>
<li>
<p><strong>Split into 7-bit Chunks</strong>:</p>
<ul>
<li>​<code>0101100</code>​ (LSB, first chunk)</li>
<li>​<code>0000010</code>​ (MSB, second chunk)</li>
</ul>
</li>
<li>
<p><strong>Add MSB Flags</strong>:</p>
<ul>
<li>First chunk: <code>10101100</code>​ (<code>0xAC</code>​) (MSB set to <code>1</code>​ because there’s another chunk).</li>
<li>Second chunk: <code>00000010</code>​ (<code>0x02</code>​) (MSB set to <code>0</code>​ because it’s the last chunk).</li>
</ul>
</li>
<li>
<p><strong>Final Encoded Result</strong>:<br>
​<code>[0xAC, 0x02]</code>​</p>
</li>
</ol>
<hr>
<h3 id="key-points"><strong>Key Points</strong><a hidden class="anchor" aria-hidden="true" href="#key-points">#</a></h3>
<ul>
<li><strong>MSB as a Continuation Flag</strong>:<br>
The MSB of each byte indicates whether the next byte is part of the same integer.</li>
<li><strong>Variable-Length Encoding</strong>:<br>
Smaller integers use fewer bytes, while larger integers use more bytes.</li>
<li><strong>Efficiency</strong>:<br>
This method is particularly efficient for encoding small integers, as it avoids the fixed overhead of using a fixed number of bytes (e.g., 4 bytes for a 32-bit integer).</li>
</ul>
<hr>
<h3 id="decoding-process"><strong>Decoding Process</strong><a hidden class="anchor" aria-hidden="true" href="#decoding-process">#</a></h3>
<p>To decode a Varint-encoded integer:</p>
<ol>
<li>
<p>Read each byte sequentially.</p>
</li>
<li>
<p>Check the MSB of each byte:</p>
<ul>
<li>If MSB is <code>1</code>​, the next byte is part of the same integer.</li>
<li>If MSB is <code>0</code>​, the current byte is the last one.</li>
</ul>
</li>
<li>
<p>Combine the 7-bit chunks to reconstruct the original integer.</p>
</li>
</ol>
<hr>
<h3 id="why-use-base-128-varint-encoding"><strong>Why Use Base 128 Varint Encoding?</strong><a hidden class="anchor" aria-hidden="true" href="#why-use-base-128-varint-encoding">#</a></h3>
<ul>
<li><strong>Space Savings</strong>:<br>
It reduces the number of bytes needed to store integers, especially for small values.</li>
<li><strong>Flexibility</strong>:<br>
It can handle integers of arbitrary size without requiring a fixed-length format.</li>
<li><strong>Compatibility</strong>:<br>
It is widely used in protocols like Thrift and Protocol Buffers for efficient data serialization.</li>
</ul>
<hr>
<h3 id="summary"><strong>Summary</strong><a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h3>
<p>Base 128 Varint Encoding is a compact and efficient way to store integers by splitting them into 7-bit chunks and using the MSB of each byte as a continuation flag. This method is particularly useful in scenarios where space optimization is critical, such as in network protocols or data storage systems.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://mobilephone724.github.io/post/me-z1ogd4d.html">
    <span class="title">« Prev</span>
    <br>
    <span>mesi-summary</span>
  </a>
  <a class="next" href="https://mobilephone724.github.io/post/implementation-of-skipping-tables-299fl1.html">
    <span class="title">Next »</span>
    <br>
    <span>跳表的实现</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share DDIA--Encoding and Evolution(1) on x"
            href="https://x.com/intent/tweet/?text=DDIA--Encoding%20and%20Evolution%281%29&amp;url=https%3a%2f%2fmobilephone724.github.io%2fpost%2fddiaencoding-and-evolution-1-2dgaes.html&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share DDIA--Encoding and Evolution(1) on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmobilephone724.github.io%2fpost%2fddiaencoding-and-evolution-1-2dgaes.html&amp;title=DDIA--Encoding%20and%20Evolution%281%29&amp;summary=DDIA--Encoding%20and%20Evolution%281%29&amp;source=https%3a%2f%2fmobilephone724.github.io%2fpost%2fddiaencoding-and-evolution-1-2dgaes.html">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share DDIA--Encoding and Evolution(1) on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fmobilephone724.github.io%2fpost%2fddiaencoding-and-evolution-1-2dgaes.html&title=DDIA--Encoding%20and%20Evolution%281%29">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share DDIA--Encoding and Evolution(1) on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmobilephone724.github.io%2fpost%2fddiaencoding-and-evolution-1-2dgaes.html">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share DDIA--Encoding and Evolution(1) on whatsapp"
            href="https://api.whatsapp.com/send?text=DDIA--Encoding%20and%20Evolution%281%29%20-%20https%3a%2f%2fmobilephone724.github.io%2fpost%2fddiaencoding-and-evolution-1-2dgaes.html">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share DDIA--Encoding and Evolution(1) on telegram"
            href="https://telegram.me/share/url?text=DDIA--Encoding%20and%20Evolution%281%29&amp;url=https%3a%2f%2fmobilephone724.github.io%2fpost%2fddiaencoding-and-evolution-1-2dgaes.html">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share DDIA--Encoding and Evolution(1) on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=DDIA--Encoding%20and%20Evolution%281%29&u=https%3a%2f%2fmobilephone724.github.io%2fpost%2fddiaencoding-and-evolution-1-2dgaes.html">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
