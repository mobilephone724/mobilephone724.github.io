<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="DDIA&ndash;Encoding and Evolution(1)
Compatibility

Backward compatibility: Newer code can read data that was written by older code.
Forward compatibility: Older code can read data that was written by newer code.

‍
Thrift and Protocol Buffers
Apache Thrift and Protocol Buffers (protobuf) are binary encoding libraries that are based on the same principle.
‍
In Thrift, you would describe the schema in the Thrift interface definition language (IDL) like this:
struct Person {
1: required string userName,
2: optional i64 favoriteNumber,
3: optional list&lt;string&gt; interests
}
‍">  

  <title>
    
      DDIA--Encoding and Evolution(1)
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css" integrity="sha512-UWUjAtOpmL94h67Vws&#43;JFBu&#43;vfRaLI&#43;HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2025-03-18 23:03:23 &#43;0800 CST">
            2025-03-18
        </time>
    </p>

    <h1>DDIA--Encoding and Evolution(1)</h1>

    
        <aside >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#compatibility">Compatibility</a></li>
    <li><a href="#thrift-and-protocol-buffers">Thrift and Protocol Buffers</a>
      <ul>
        <li><a href="#thrift-binaryprotocol">Thrift BinaryProtocol</a></li>
        <li><a href="#thrift-compactprotocol">Thrift CompactProtocol</a></li>
      </ul>
    </li>
    <li><a href="#protocol-buffers">Protocol Buffers</a></li>
    <li><a href="#field-tags-and-schema-evolution">Field tags and schema evolution</a></li>
    <li><a href="#base-128-varint-encoding"><strong>Base 128 Varint Encoding</strong></a>
      <ul>
        <li><a href="#how-it-works"><strong>How it Works</strong></a></li>
        <li><a href="#encoding-process"><strong>Encoding Process</strong></a></li>
        <li><a href="#example-encoding-the-integer-"><strong>Example: Encoding the Integer</strong> <strong>​<code>300</code>​</strong>​</a></li>
        <li><a href="#key-points"><strong>Key Points</strong></a></li>
        <li><a href="#decoding-process"><strong>Decoding Process</strong></a></li>
        <li><a href="#why-use-base-128-varint-encoding"><strong>Why Use Base 128 Varint Encoding?</strong></a></li>
        <li><a href="#summary"><strong>Summary</strong></a></li>
      </ul>
    </li>
  </ul>
</nav>
        </aside>
    

    <h1 id="ddiaencoding-and-evolution1">DDIA&ndash;Encoding and Evolution(1)</h1>
<h2 id="compatibility">Compatibility</h2>
<ul>
<li>Backward compatibility: Newer code can read data that was written by older code.</li>
<li>Forward compatibility: Older code can read data that was written by newer code.</li>
</ul>
<p>‍</p>
<h2 id="thrift-and-protocol-buffers">Thrift and Protocol Buffers</h2>
<p>Apache Thrift and Protocol Buffers (protobuf) are binary encoding libraries that are based on the same principle.</p>
<p>‍</p>
<p>In Thrift, you would describe the schema in the Thrift <strong>interface definition language</strong> (<strong>IDL</strong>) like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#f00">struct</span> Person {
</span></span><span style="display:flex;"><span><span style="color:#f60">1</span>: required string userName,
</span></span><span style="display:flex;"><span><span style="color:#f60">2</span>: optional i64 favoriteNumber,
</span></span><span style="display:flex;"><span><span style="color:#f60">3</span>: optional list&lt;string&gt; interests
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>‍</p>
<p>The equivalent schema definition for Protocol Buffers looks very similar:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>message Person {
</span></span><span style="display:flex;"><span>required string user_name = <span style="color:#f60">1</span>;
</span></span><span style="display:flex;"><span>optional int64 favorite_number = <span style="color:#f60">2</span>;
</span></span><span style="display:flex;"><span>repeated string interests = <span style="color:#f60">3</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>‍</p>
<h3 id="thrift-binaryprotocol">Thrift BinaryProtocol</h3>
<p>​<img src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/image-20250318230834-58zd7vk.png" alt="image">​</p>
<p>Each field has  <strong>(1)a type annotation</strong> (to indicate whether it is a string, integer, list, etc.) and, where required, (2)<strong>a length indication</strong> (length of a string, number of items in a list).</p>
<p>There are no field names (userName, favoriteNumber, interests). Instead, the encoded data contains <strong>field tags</strong>, which are numbers (1, 2, and 3).</p>
<p>‍</p>
<h3 id="thrift-compactprotocol">Thrift CompactProtocol</h3>
<p>​<img src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/image-20250318231100-ske1qmo.png" alt="image">​</p>
<p>It packs the same information into only 34 bytes. It does this by (1) <strong>packing the field type and tag number into a single byte</strong>, and by (2)<strong>using variable-length integers</strong>. Rather than using a full eight bytes for the number 1337, it is encoded in two bytes, <strong>with the top bit of each byte used to indicate whether there are still more bytes to come.</strong></p>
<p>See &ldquo;<strong>Base 128 Varint Encoding</strong>&rdquo; for detail</p>
<p>‍</p>
<h2 id="protocol-buffers">Protocol Buffers</h2>
<p>​<img src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/image-20250318232012-d80u44j.png" alt="image">​</p>
<p>‍</p>
<p>in the schemas shown earlier, each field was marked either required or optional, but this makes no difference to how the field is encoded (nothing in the binary data indicates whether a field was required). The difference is simply that required enables a runtime check that fails if the field is not set, which can be useful for catching bugs.</p>
<p>‍</p>
<h2 id="field-tags-and-schema-evolution">Field tags and schema evolution</h2>
<p>We said previously that schemas inevitably need to change over time. We call this <strong>schema evolution</strong>.</p>
<blockquote>
<p>Each field is identified by its tag number (the numbers 1, 2, 3 in the<br>
sample schemas) and annotated with a datatype (e.g., string or integer).  <strong>(1)</strong>  If a field value is not set, it is simply omitted from the encoded record. From this you can see that field tags are critical to the meaning of the encoded data.  <strong>(2)</strong> You can change the name of a field in the schema, since the encoded data never refers to field names, but you cannot change a field’s tag, since that would make all existing encoded data invalid.</p></blockquote>
<ol>
<li>Omit a non-set value</li>
<li>change the name instead of the tag</li>
</ol>
<p>‍</p>
<blockquote>
<p>You can add new fields to the schema, provided that you give each field a new tag number. If old code (which doesn’t know about the new tag numbers you added) tries to read data written by new code, including a new field with a tag number it doesn’t recognize, it can simply ignore that field. The datatype annotation allows the<br>
parser to determine how many bytes it needs to skip. This maintains forward compatibility: old code can read records that were written by new code.</p></blockquote>
<p>Old code ignores the tag that it doesn&rsquo;t recognize</p>
<p>‍</p>
<blockquote>
<p>What about backward compatibility? As long as each field has a unique tag number, new code can always read old data, because the tag numbers still have the same meaning. The only detail is that if you add a new field, you cannot make it required. If you were to add a field and make it required, that check would fail if new code read data written by old code, because the old code will not have written the new field that you added. Therefore, to maintain backward compatibility, every field you add after the initial deployment of the schema must be optional or have a default value.</p></blockquote>
<p>New added field can&rsquo;t be required</p>
<p>‍</p>
<blockquote>
<p>Removing a field is just like adding a field, with backward and forward compatibility concerns reversed. That means you can only remove a field that is optional (a required field can never be removed), and you can never use the same tag number again (because you may still have data written somewhere that includes the old tag number, and that field must be ignored by new code).</p></blockquote>
<p>Can remove optional field only and can&rsquo;t use the same tag number again.</p>
<p>‍</p>
<h2 id="base-128-varint-encoding"><strong>Base 128 Varint Encoding</strong></h2>
<p><strong>Base 128 Varint Encoding</strong> is a method used to encode integers into a variable number of bytes, where each byte represents a 7-bit chunk of the integer. The most significant bit (MSB) of each byte is used as a flag to indicate whether there are more bytes to follow. This approach allows smaller integers to be stored in fewer bytes, optimizing space efficiency.</p>
<hr>
<h3 id="how-it-works"><strong>How it Works</strong></h3>
<ol>
<li>
<p><strong>Split the Integer into 7-bit Chunks</strong><br>
The integer is divided into groups of 7 bits, starting from the least significant bit (LSB). Each group is stored in a separate byte.</p>
</li>
<li>
<p><strong>Add the MSB Flag</strong></p>
<ul>
<li>If there are more 7-bit chunks to encode, the MSB of the byte is set to <code>1</code>​.</li>
<li>If the current byte is the last one, the MSB is set to <code>0</code>​.</li>
</ul>
</li>
<li>
<p><strong>Store the Bytes</strong><br>
The bytes are stored in sequence, with the least significant byte first.</p>
</li>
</ol>
<hr>
<h3 id="encoding-process"><strong>Encoding Process</strong></h3>
<ol>
<li>
<p>Convert the integer to its binary representation.</p>
</li>
<li>
<p>Split the binary number into 7-bit chunks, starting from the LSB.</p>
</li>
<li>
<p>For each chunk, add the MSB flag:</p>
<ul>
<li>Set MSB to <code>1</code>​ if there are more chunks.</li>
<li>Set MSB to <code>0</code>​ if it&rsquo;s the last chunk.</li>
</ul>
</li>
<li>
<p>Store the resulting bytes in order.</p>
</li>
</ol>
<hr>
<h3 id="example-encoding-the-integer-"><strong>Example: Encoding the Integer</strong> <strong>​<code>300</code>​</strong>​</h3>
<ol>
<li>
<p><strong>Binary Representation of 300</strong>:<br>
​<code>100101100</code>​ (9 bits)</p>
</li>
<li>
<p><strong>Split into 7-bit Chunks</strong>:</p>
<ul>
<li>​<code>0101100</code>​ (LSB, first chunk)</li>
<li>​<code>0000010</code>​ (MSB, second chunk)</li>
</ul>
</li>
<li>
<p><strong>Add MSB Flags</strong>:</p>
<ul>
<li>First chunk: <code>10101100</code>​ (<code>0xAC</code>​) (MSB set to <code>1</code>​ because there’s another chunk).</li>
<li>Second chunk: <code>00000010</code>​ (<code>0x02</code>​) (MSB set to <code>0</code>​ because it’s the last chunk).</li>
</ul>
</li>
<li>
<p><strong>Final Encoded Result</strong>:<br>
​<code>[0xAC, 0x02]</code>​</p>
</li>
</ol>
<hr>
<h3 id="key-points"><strong>Key Points</strong></h3>
<ul>
<li><strong>MSB as a Continuation Flag</strong>:<br>
The MSB of each byte indicates whether the next byte is part of the same integer.</li>
<li><strong>Variable-Length Encoding</strong>:<br>
Smaller integers use fewer bytes, while larger integers use more bytes.</li>
<li><strong>Efficiency</strong>:<br>
This method is particularly efficient for encoding small integers, as it avoids the fixed overhead of using a fixed number of bytes (e.g., 4 bytes for a 32-bit integer).</li>
</ul>
<hr>
<h3 id="decoding-process"><strong>Decoding Process</strong></h3>
<p>To decode a Varint-encoded integer:</p>
<ol>
<li>
<p>Read each byte sequentially.</p>
</li>
<li>
<p>Check the MSB of each byte:</p>
<ul>
<li>If MSB is <code>1</code>​, the next byte is part of the same integer.</li>
<li>If MSB is <code>0</code>​, the current byte is the last one.</li>
</ul>
</li>
<li>
<p>Combine the 7-bit chunks to reconstruct the original integer.</p>
</li>
</ol>
<hr>
<h3 id="why-use-base-128-varint-encoding"><strong>Why Use Base 128 Varint Encoding?</strong></h3>
<ul>
<li><strong>Space Savings</strong>:<br>
It reduces the number of bytes needed to store integers, especially for small values.</li>
<li><strong>Flexibility</strong>:<br>
It can handle integers of arbitrary size without requiring a fixed-length format.</li>
<li><strong>Compatibility</strong>:<br>
It is widely used in protocols like Thrift and Protocol Buffers for efficient data serialization.</li>
</ul>
<hr>
<h3 id="summary"><strong>Summary</strong></h3>
<p>Base 128 Varint Encoding is a compact and efficient way to store integers by splitting them into 7-bit chunks and using the MSB of each byte as a continuation flag. This method is particularly useful in scenarios where space optimization is critical, such as in network protocols or data storage systems.</p>

</article>

                
    
    
        <hr>
<p>written by mobilephone724</p>
    


            </div>
        </main>
    </body>
</html>
