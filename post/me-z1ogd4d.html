<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="store buffer
why?
When a CPU wants to modify data (not in the &ldquo;Modified&rdquo; or &ldquo;Exclusive&rdquo; state), it will always update the data regardless of the responses from other CPUs.
Thus, the data is immediately updated in the store buffer.
complexity it introduces


Multilayer caches (reason for write memory barrier):

Example: Consider a CPU storing two values (A and B) sequentially, where A is in the store buffer and B is in the cache. It is uncertain whether another CPU will observe the updated A before observing B, as it depends on whether the invalidate message for A is received before the request for B.
Reason: Broadcasting later changes (in the cache) before earlier changes (in the store buffer) are visible to others.



Write memory barrier: CPUs must wait until the store buffer is cleared before applying subsequent changes. Alternatively, later changes can remain in the store buffer until all prior entries in the store buffer have been processed.">  

  <title>
    
      mesi-summary
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css" integrity="sha512-UWUjAtOpmL94h67Vws&#43;JFBu&#43;vfRaLI&#43;HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
                <div class="post-meta">
                    <a href="/">..</a>

                    <p>
                        <time datetime="2025-03-29 08:56:22 &#43;0800 CST">
                            2025-03-29
                        </time>
                    </p>
                </div>

<article>
    <h1>mesi-summary</h1>

    
        <aside >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#store-buffer">store buffer</a>
      <ul>
        <li><a href="#why">why?</a></li>
        <li><a href="#complexity-it-introduces">complexity it introduces</a></li>
      </ul>
    </li>
    <li><a href="#invalidate-queue">invalidate queue</a>
      <ul>
        <li><a href="#why-1">why?</a></li>
        <li><a href="#complexity-it-introduces-1">complexity it introduces</a></li>
      </ul>
    </li>
    <li><a href="#summary">summary</a></li>
    <li><a href="#summary-chart">Summary Chart</a></li>
  </ul>
</nav>
        </aside>
    

    <h2 id="store-buffer">store buffer</h2>
<h3 id="why">why?</h3>
<p>When a CPU wants to modify data (not in the &ldquo;Modified&rdquo; or &ldquo;Exclusive&rdquo; state), it will always update the data regardless of the responses from other CPUs.</p>
<p><strong>Thus, the data is immediately updated in the store buffer.</strong></p>
<h3 id="complexity-it-introduces">complexity it introduces</h3>
<ul>
<li>
<p>Multilayer caches (reason for write memory barrier):</p>
<ul>
<li>Example: Consider a CPU storing two values (A and B) sequentially, where A is in the store buffer and B is in the cache. It is uncertain whether another CPU will observe the updated A before observing B, as it depends on whether the invalidate message for A is received before the request for B.</li>
<li>Reason: Broadcasting later changes (in the cache) before earlier changes (in the store buffer) are visible to others.</li>
</ul>
</li>
<li>
<p><strong>Write memory barrier</strong>: CPUs must wait until the store buffer is cleared before applying subsequent changes. Alternatively, later changes can remain in the store buffer until all prior entries in the store buffer have been processed.</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/image-20250329093456-j3puqdh.png" alt="image"></p>
<p>‍</p>
<p>‍</p>
<h2 id="invalidate-queue">invalidate queue</h2>
<h3 id="why-1">why?</h3>
<p>When an invalidate message is received, the cache line may be busy, causing delayed acknowledgments.</p>
<p><strong>To address this, the invalidate message is stored in the invalidate queue and processed later.</strong></p>
<h3 id="complexity-it-introduces-1">complexity it introduces</h3>
<p><strong>Read memory barrier</strong>: All invalidate messages must be processed before reading subsequent values.</p>
<p><img src="https://raw.githubusercontent.com/mobilephone724/hugoBlog/siyuan-pub/images/image-20250329093503-406qo5f.png" alt="image"></p>
<h2 id="summary">summary</h2>
<h2 id="summary-chart">Summary Chart</h2>
<table>
  <thead>
      <tr>
          <th>Component</th>
          <th>Reason</th>
          <th>Complexity Introduced</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Store Buffer</td>
          <td>CPU updates data immediately in the store buffer regardless of responses from other CPUs.</td>
          <td>1. Multilayer caches caused by uncertainty in update visibility<!-- raw HTML omitted -->2. Write memory barrier needed</td>
      </tr>
      <tr>
          <td>Invalidate Queue</td>
          <td>Cache line may be busy, delaying acknowledgment of invalidate messages.</td>
          <td>Read memory barrier required - all invalidate messages must be processed before reading</td>
      </tr>
  </tbody>
</table>

</article>

            </div>
        </main>
    </body></html>
