<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MESI AND MEMORY_BARRIER: paper reading | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="paper Introduction: Memory Barriers: a Hardware View for Software Hackers 0x0 why we need memory barrier In short, because reordering memory references allows much better performance, and so memory barriers are needed to force ordering in things like synchronization primitives whose correct operation depends on ordered memory references.
0x1 Cache Structure 0x11 some cases of cache miss(not important) The cache miss means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is fetched from memory.">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="http://localhost:1313/article/mesi/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/article/mesi/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="http://localhost:1313/article/mesi/">
  <meta property="og:site_name" content="PaperMod">
  <meta property="og:title" content="MESI AND MEMORY_BARRIER: paper reading">
  <meta property="og:description" content="paper Introduction: Memory Barriers: a Hardware View for Software Hackers 0x0 why we need memory barrier In short, because reordering memory references allows much better performance, and so memory barriers are needed to force ordering in things like synchronization primitives whose correct operation depends on ordered memory references.
0x1 Cache Structure 0x11 some cases of cache miss(not important) The cache miss means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is fetched from memory.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="article">
    <meta property="article:published_time" content="2024-06-16T01:12:36+08:00">
    <meta property="article:modified_time" content="2024-06-16T01:12:36+08:00">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="MESI AND MEMORY_BARRIER: paper reading">
<meta name="twitter:description" content="paper Introduction: Memory Barriers: a Hardware View for Software Hackers 0x0 why we need memory barrier In short, because reordering memory references allows much better performance, and so memory barriers are needed to force ordering in things like synchronization primitives whose correct operation depends on ordered memory references.
0x1 Cache Structure 0x11 some cases of cache miss(not important) The cache miss means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is fetched from memory.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "较长的专题文章",
      "item": "http://localhost:1313/article/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "MESI AND MEMORY_BARRIER: paper reading",
      "item": "http://localhost:1313/article/mesi/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MESI AND MEMORY_BARRIER: paper reading",
  "name": "MESI AND MEMORY_BARRIER: paper reading",
  "description": "paper Introduction: Memory Barriers: a Hardware View for Software Hackers 0x0 why we need memory barrier In short, because reordering memory references allows much better performance, and so memory barriers are needed to force ordering in things like synchronization primitives whose correct operation depends on ordered memory references.\n0x1 Cache Structure 0x11 some cases of cache miss(not important) The cache miss means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is fetched from memory.",
  "keywords": [
    
  ],
  "articleBody": " paper Introduction: Memory Barriers: a Hardware View for Software Hackers 0x0 why we need memory barrier In short, because reordering memory references allows much better performance, and so memory barriers are needed to force ordering in things like synchronization primitives whose correct operation depends on ordered memory references.\n0x1 Cache Structure 0x11 some cases of cache miss(not important) The cache miss means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is fetched from memory.\ncapacity miss: After some time, the CPU’s cache will fill, and sub- sequent misses will likely need to eject an item from the cache in order to make room for the newly fetched item\nassociativity miss: occur in set-associative caches.\nAn “associativity cache miss” refers to a specific type of cache miss that can occur in set-associative caches.\nIn a set-associative cache, the cache memory is divided into sets, and each set contains multiple cache lines (or cache blocks). When the CPU needs to access data in memory, it first checks the cache to see if the data is present. The cache lookup is done by first identifying the set that the data would be stored in, and then searching through the multiple cache lines within that set to see if the data is present.\nAn associativity cache miss occurs when the data the CPU needs is not found in any of the cache lines within the identified set. This means the CPU has to go to main memory to fetch the data, which is slower than finding it in the cache.\nThe number of cache lines per set is called the “associativity” of the cache. Caches with higher associativity (more cache lines per set) generally have lower associativity cache miss rates, but they are also more complex and expensive to implement. The goal is to find the right balance of associativity to minimize cache misses without making the cache design overly complex.\nwrite miss: Before a given CPU writes to that data item, it must first cause it to be removed, or “invalidated”, from other CPUs’ caches. Once this invalidation has completed, the CPU may safely modify the data item. If the data item was present in this CPU’s cache, but was read- only, this process is termed a “write miss”.\ncache structure: one cache address can store two(or more?) sets of data.\n0x2 Cache-Coherence Protocols 0x21 Four state: MESI States The four types of states represent the state of a cache line in one cpu.\nHere, we use “I” to represent the cpu.\nmodified: I have changed the value in private cache and not written it back to memory. Others can’t access the memory until change their states(signal me). exclusive: I haven’t changed the value in private cache. (But may change it later, transfer to modified state) Others can’t access the memory until change their states(signal me). shared Others can read the memory without consulting me. invalid: the cache line holds no data. 0x22 Messages between the cpus(and memory): MESI Protocol Messages Read: a request for reading a line Read Response: The line data for a previous read. Either of memory or other cpu. Invalidate: invalidate the line in all other cpus Invalidate Acknowledge: successful response to a previous Invalidate message Read Invalidate: a atomic combination of “read” and “invalidate”. Requires both a “read response” and a set of “in- validate acknowledge” messages in reply. Writeback: write a line to memory 0x23 State Machine: MESI State Diagram Transitions are explained below:\n(a): write back to memory (b): modify the data in cache (c): I haven’t written back to memory but another cpu requests it (and will change it). So I return the value in cache and invalidate the private one without writing back to memory (d): I want to change a cache, so I emit a “invalidate” to other cpus. Now all others have acknowledge me, so I read and change my private cache. (e): Similar to “(d)”, but don’t need to read in memory. (f): Similar to (c), I haven’t written back to memory but another cpu requests it (but will not change it), so I return my private value. (g): Similar to (f) (h): similar to “(d)”, but don’t modify it now (i): similar to “(c)”, but don’t need to return my private value since that in memory is still the newest. (j): Similar to “(d)” (k): read in memory( or other cpu) (l): receive a “invalidate” message Examples are in the paper.\n0x3 Optimize 1: Stores Result in Unnecessary Stalls Consider to modify a cache that isn’t in modified or exclusive state.\nProblem: there is no real reason to force CPU 0 to stall for so long — after all, regardless of what data happens to be in the cache line that CPU 1 sends it, CPU 0 is going to unconditionally overwrite it. Solution: Add “store buffers” between each CPU and its cache CPU0 write to its store buffer immediately When CPU0 is acknowledged, the data will be moved from the store buffer to the cache line 0x31: Store Forwarding problem Thinking of the program below:\nCPU0 has value b CPU1 has value a = 0 in exclusive mode a = 1; b = a + 1; assert(b == 2); step1: cpu0 invalidate cpu1 with “a” , change private cache line to 1, and write it to store buffer.\nstep2: cpu0 receive the value “a” from cpu1. The value is 0, and it’s stored in private cache.(Note that the value in the store buffer is 1)\nstep3: cpu0 executes “b = a + 1”, load “a” from cache, and its value is 0\nstep4: cpu0 store the value of “b” to cache, whose value is 1\nstep5: cpu0 move the value of “a” from store buffer(1) to cache(0)\nstep6: CPU0 executes assert(b==2), which fails.\nThe problem is that we have two copies of “a”, one in the cache and the other in the store buffer.\nThe hardware guys took pity and implemented “store forwarding”, where each CPU refers to (or “snoops”) its store buffer as well as its cache when performing loads\nIn other words, a given CPU’s stores are directly forwarded to its subsequent loads, without hav- ing to pass through the cache.\n0x32 Store Buffers and Memory Barriers Think of the program below\nvoid foo(void) { a=1; b=1; } void bar(void) { while (b == 0) continue; assert(a == 1); } cpu0 executes foo own “b” cpu1 executes bar own “a” The problem is that, cpu1 reads “a” before being acknowledged that other cpus have changed it. Although CPU0 can continue to execute before writing it to stored buffer, but CPU1 doesn’t know that.\nThe hardware designers cannot help directly here, since the CPUs have no idea which variables are related, let alone how they might be related\nTherefore, the hardware designers provide memory-barrier instructions to allow the software to tell the CPU about such relations. The program fragment must be updated to contain the memory barrier:\nvoid foo(void) { a=1; smp_mb(); b=1; } void bar(void) { while (b == 0) continue; assert(a == 1); } The memory barrier smp_mb() will cause the CPU to flush its store buffer before applying subsequent stores to their cache lines. The CPU could either\nsimply stall until the store buffer was empty before proceeding, or it could only use the store buffer to hold subsequent stores until all of the prior entries in the store buffer had been applied. This is to prevent other cpus from getting the subsequent value before getting the prior entries So that, CPU0 will\nwait for the “invalidate acknowledge” message of “a” before executing “b=1;” or\n(1)while executing smp_mb ,marks all current store-buffer entries (namely, the a=1) (2) while executing “b=1”, only stores it store buffer. (3) wait “invalidate acknowledge” of “a” (4) store the value of b in stored buffer and send a “invalidate” message 0x4 Optimize 2: Store Sequences Result in Unnecessary Stalls Once the stored buffer is full or a memory barrier is encountered, the CPU must once again wait for invalidations to complete in order to drain its store buffer before it can continue executing invalidate acknowledge messages can take so long: they must ensure that the corre- sponding cache line is actually invalidated, and this invalidation can be delayed if the cache is busy, for example, if the CPU is intensively loading and storing data, all of which resides in the cache. However, the CPU need not actually invalidate the cache line before sending the acknowledgement.\n0x42 Invalidate Queues and Invalidate Acknowledge A CPU with an invalidate queue may acknowledge an invalidate message as soon as it is placed in the queue, instead of having to wait until the corresponding line is actually invalidated.\n0x43 Invalidate Queues and Memory Barriers Thinking of the following code:\nvoid foo(void) { a=1; smp_mb(); b=1; } void bar(void) { while (b == 0) continue; assert(a == 1); } CPU0: execute foo a is shared state b is exclusive CPU1: execute bar Once again, the CPU designers cannot do much about this situation However, the memory-barrier instructions can interact with the invalidate queue. When a given CPU executes a memory barrier, it marks all the entries currently in its invalidate queue, and forces any subsequent load to wait until all marked entries have been applied to the CPU’s cache.\nvoid foo(void) { a=1; smp_mb(); b=1; } void bar(void) { while (b == 0) continue; smp_mb(); assert(a == 1); } So that, CPU0 will\n(1) executes the smp_mb(), marking the entry in its invalidate queue. (2) start executing the assert(a==1), but a is in the invalidate queue, CPU 1 must stall this load until that entry in the invalidate queue has been applied. 0x5 Summary: Read and Write Memory Barriers In the previous section, memory barriers were used to mark entries in both the store buffer and the inval- idate queue. But in our code fragment, foo() had no reason to do anything with the invalidate queue, and bar() similarly had no reason to do anything with the store queue.\nMany CPU architectures therefore provide weaker memory-barrier instructions that do only one or the other of these two.\nread memory barrier: marks only the invalidate queue forces any subsequent load to wait until all marked entries have been applied from the invalidate queue write memory barrier: marks only the store buffer. only use the store buffer to hold subsequent stores until all of the prior entries in the store buffer had been applied. void foo(void) { a=1; smp_wmb(); b=1; } void bar(void) { while (b == 0) continue; smp_rmb(); assert(a == 1); } ",
  "wordCount" : "1775",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-06-16T01:12:36+08:00",
  "dateModified": "2024-06-16T01:12:36+08:00",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/article/mesi/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/article" title="article">
                    <span>article</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/article/">较长的专题文章</a></div>
    <h1 class="post-title entry-hint-parent">
      MESI AND MEMORY_BARRIER: paper reading
    </h1>
    <div class="post-meta"><span title='2024-06-16 01:12:36 +0800 CST'>June 16, 2024</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/article/mesi.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#0x0-why-we-need-memory-barrier" aria-label="0x0 why we need memory barrier">0x0 why we need memory barrier</a></li>
                <li>
                    <a href="#0x1-cache-structure" aria-label="0x1 Cache Structure">0x1 Cache Structure</a><ul>
                        
                <li>
                    <a href="#0x11-some-cases-of-cache-missnot-important" aria-label="0x11 some cases of cache miss(not important)">0x11 some cases of cache miss(not important)</a></li></ul>
                </li>
                <li>
                    <a href="#0x2-cache-coherence-protocols" aria-label="0x2 Cache-Coherence Protocols">0x2 Cache-Coherence Protocols</a><ul>
                        
                <li>
                    <a href="#0x21-four-state-mesi-states" aria-label="0x21 Four state: MESI States">0x21 Four state: MESI States</a></li>
                <li>
                    <a href="#0x22-messages-between-the-cpusand-memory-mesi-protocol-messages" aria-label="0x22 Messages between the cpus(and memory): MESI Protocol Messages">0x22 Messages between the cpus(and memory): MESI Protocol Messages</a></li>
                <li>
                    <a href="#0x23-state-machine-mesi-state-diagram" aria-label="0x23 State Machine: MESI State Diagram">0x23 State Machine: MESI State Diagram</a></li></ul>
                </li>
                <li>
                    <a href="#0x3-optimize-1-stores-result-in-unnecessary-stalls" aria-label="0x3 Optimize 1: Stores Result in Unnecessary Stalls">0x3 Optimize 1: Stores Result in Unnecessary Stalls</a><ul>
                        
                <li>
                    <a href="#0x31-store-forwarding-problem" aria-label="0x31: Store Forwarding problem">0x31: Store Forwarding problem</a></li>
                <li>
                    <a href="#0x32-store-buffers-and-memory-barriers" aria-label="0x32 Store Buffers and Memory Barriers">0x32 Store Buffers and Memory Barriers</a></li></ul>
                </li>
                <li>
                    <a href="#0x4-optimize-2-store-sequences-result-in-unnecessary-stalls" aria-label="0x4 Optimize 2: Store Sequences Result in Unnecessary Stalls">0x4 Optimize 2: Store Sequences Result in Unnecessary Stalls</a><ul>
                        
                <li>
                    <a href="#0x42-invalidate-queues-and-invalidate-acknowledge" aria-label="0x42 Invalidate Queues and Invalidate Acknowledge">0x42 Invalidate Queues and Invalidate Acknowledge</a></li>
                <li>
                    <a href="#0x43-invalidate-queues-and-memory-barriers" aria-label="0x43 Invalidate Queues and Memory Barriers">0x43 Invalidate Queues and Memory Barriers</a></li></ul>
                </li>
                <li>
                    <a href="#0x5-summary-read-and-write-memory-barriers" aria-label="0x5 Summary: Read and Write Memory Barriers">0x5 Summary: Read and Write Memory Barriers</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><ul>
<li>paper
<ul>
<li>Introduction: <a href="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/memory_barrier_withMarginNotes.2024_06_16_1718472482.pdf">Memory Barriers: a Hardware View for Software Hackers</a></li>
</ul>
</li>
</ul>
<h2 id="0x0-why-we-need-memory-barrier">0x0 why we need memory barrier<a hidden class="anchor" aria-hidden="true" href="#0x0-why-we-need-memory-barrier">#</a></h2>
<p>In short, because <strong>reordering memory references allows much better performance</strong>, and so memory barriers are needed to force ordering in things like synchronization primitives whose <strong>correct operation depends on ordered memory references</strong>.</p>
<h2 id="0x1-cache-structure">0x1 <strong>Cache Structure</strong><a hidden class="anchor" aria-hidden="true" href="#0x1-cache-structure">#</a></h2>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled.2024_06_17_1718631318.png"></p>
<h3 id="0x11-some-cases-of-cache-missnot-important">0x11 some cases of cache miss(not important)<a hidden class="anchor" aria-hidden="true" href="#0x11-some-cases-of-cache-missnot-important">#</a></h3>
<p>The cache miss means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is fetched from memory.</p>
<ul>
<li>
<p><strong>capacity miss</strong>: After some time, the CPU’s cache will fill, and sub- sequent misses will likely need to eject an item from the cache in order to make room for the newly fetched item</p>
</li>
<li>
<p><strong>associativity miss</strong>: occur in set-associative caches.</p>
<blockquote>
<p>An &ldquo;associativity cache miss&rdquo; refers to a specific type of cache miss that can occur in set-associative caches.</p>
</blockquote>
<blockquote>
<p>In a set-associative cache, the cache memory is divided into sets, and each set contains multiple cache lines (or cache blocks). When the CPU needs to access data in memory, it first checks the cache to see if the data is present. The cache lookup is done by first identifying the set that the data would be stored in, and then searching through the multiple cache lines within that set to see if the data is present.</p>
</blockquote>
<blockquote>
<p>An associativity cache miss occurs when the data the CPU needs is not found in any of the cache lines within the identified set. This means the CPU has to go to main memory to fetch the data, which is slower than finding it in the cache.</p>
</blockquote>
<blockquote>
<p>The number of cache lines per set is called the &ldquo;associativity&rdquo; of the cache. Caches with higher associativity (more cache lines per set) generally have lower associativity cache miss rates, but they are also more complex and expensive to implement. The goal is to find the right balance of associativity to minimize cache misses without making the cache design overly complex.</p>
</blockquote>
</li>
<li>
<p><strong>write miss</strong>: Before a given CPU writes to that data item, it must first cause it to be removed, or “invalidated”, from other CPUs’ caches. Once this invalidation has completed, the CPU may safely modify the data item. If the data item was present in this CPU’s cache, but was read- only, this process is termed a “write miss”.</p>
</li>
</ul>
<p>cache structure: one cache address can store two(or more?) sets of data.</p>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled%201.2024_06_17_1718631325.png"></p>
<h2 id="0x2-cache-coherence-protocols">0x2 Cache-Coherence Protocols<a hidden class="anchor" aria-hidden="true" href="#0x2-cache-coherence-protocols">#</a></h2>
<h3 id="0x21-four-state-mesi-states">0x21 Four state: MESI States<a hidden class="anchor" aria-hidden="true" href="#0x21-four-state-mesi-states">#</a></h3>
<p>The four types of states represent the state of a cache line in one cpu.</p>
<p>Here, we use “I” to represent the cpu.</p>
<ul>
<li><strong>modified</strong>:
<ul>
<li>I have changed the value in private cache and not written it back to memory.</li>
<li>Others  can’t access the memory until change their states(signal me).</li>
</ul>
</li>
<li><strong>exclusive</strong>:
<ul>
<li>I haven’t changed the value in private cache. (But may change it later, transfer to <strong>modified</strong> state)</li>
<li>Others can’t access the memory until change their states(signal me).</li>
</ul>
</li>
<li><strong>shared</strong>
<ul>
<li>Others can read the memory without consulting me.</li>
</ul>
</li>
<li><strong>invalid:</strong>
<ul>
<li>the cache line holds no data.</li>
</ul>
</li>
</ul>
<h3 id="0x22-messages-between-the-cpusand-memory-mesi-protocol-messages">0x22 Messages between the cpus(and memory): MESI Protocol Messages<a hidden class="anchor" aria-hidden="true" href="#0x22-messages-between-the-cpusand-memory-mesi-protocol-messages">#</a></h3>
<ul>
<li><strong>Read:</strong> a request for reading  a line</li>
<li><strong>Read Response</strong>: The line data for a previous read. Either of memory or other cpu.</li>
<li><strong>Invalidate</strong>: invalidate the line in <strong>all other cpus</strong></li>
<li><strong>Invalidate Acknowledge:</strong> successful response to a previous <strong>Invalidate</strong> message</li>
<li><strong>Read Invalidate</strong>: a <strong>atomic combination</strong> of “read” and “invalidate”. Requires both a “read response” and a set of “in- validate acknowledge” messages in reply.</li>
<li><strong>Writeback:</strong> write a line to memory</li>
</ul>
<h3 id="0x23-state-machine-mesi-state-diagram">0x23 State Machine: MESI State Diagram<a hidden class="anchor" aria-hidden="true" href="#0x23-state-machine-mesi-state-diagram">#</a></h3>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled%202.2024_06_17_1718631330.png"></p>
<p>Transitions are explained below:</p>
<ul>
<li>(a): write back to memory</li>
<li>(b): modify the data in cache</li>
<li>(c): I haven’t written back to memory but another cpu requests it (and will change it). So I return the value in cache and invalidate the private one without writing back to memory</li>
<li>(d): I want to change a cache, so I emit a “invalidate” to other cpus. Now all others have acknowledge me, so I read and change my private cache.</li>
<li>(e): Similar to “(d)”, but don’t need to read in memory.</li>
<li>(f): Similar to (c), I haven’t written back to memory but another cpu requests it (but will not change it), so I return my private value.</li>
<li>(g): Similar to (f)</li>
<li>(h): similar to “(d)”, but don’t modify it now</li>
<li>(i): similar to “(c)”, but don’t need to return my private value since that in memory is still the newest.</li>
<li>(j): Similar to “(d)”</li>
<li>(k): read in memory( or other cpu)</li>
<li>(l): receive a “invalidate” message</li>
</ul>
<p>Examples are in the paper.</p>
<h2 id="0x3-optimize-1-stores-result-in-unnecessary-stalls">0x3 Optimize 1: Stores Result in Unnecessary Stalls<a hidden class="anchor" aria-hidden="true" href="#0x3-optimize-1-stores-result-in-unnecessary-stalls">#</a></h2>
<p>Consider to modify a cache that isn’t in <strong>modified</strong> or <strong>exclusive</strong> state.</p>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled%203.2024_06_17_1718631337.png"></p>
<ul>
<li><strong>Problem</strong>: there is no real reason to force CPU 0 to stall for so long — after all, regardless of what data happens to be in the cache line that CPU 1 sends it, CPU 0 is going to unconditionally overwrite it.</li>
<li><strong>Solution</strong>: Add “store buffers” between each CPU and its cache
<ul>
<li>CPU0 write to its store buffer immediately</li>
<li><strong>When CPU0 is acknowledged, the data will be moved from the store buffer to the cache line</strong></li>
</ul>
</li>
</ul>
<h3 id="0x31-store-forwarding-problem">0x31: Store Forwarding problem<a hidden class="anchor" aria-hidden="true" href="#0x31-store-forwarding-problem">#</a></h3>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled%204.2024_06_17_1718631343.png"></p>
<p>Thinking of the program below:</p>
<ul>
<li>CPU0 has value b</li>
<li>CPU1 has value a = 0 in exclusive mode</li>
</ul>
<pre tabindex="0"><code>a = 1;
b = a + 1;
assert(b == 2);
</code></pre><p>step1: cpu0 invalidate cpu1 with “a” , change private cache line to 1, and write it to store buffer.</p>
<p>step2: cpu0 receive the value “a” from cpu1. The value is 0, and it’s stored in private cache.(Note that the value in the store buffer is 1)</p>
<p>step3: cpu0 executes “b = a + 1”, load “a” from cache, and its value is 0</p>
<p>step4: cpu0 store the value of “b” to cache, whose value is 1</p>
<p>step5: cpu0 move the value of “a” from store buffer(1) to cache(0)</p>
<p>step6: CPU0 executes assert(b==2), which fails.</p>
<p>The problem is that we have two copies of “a”, one in the cache and the other in the store buffer.</p>
<hr>
<p>The hardware guys took pity and implemented “store forwarding”, where <strong>each CPU refers to (or “snoops”) its store buffer as well as its cache when performing loads</strong></p>
<p><strong>In other words, a given CPU’s stores are directly forwarded to its subsequent loads, without hav- ing to pass through the cache.</strong></p>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled%205.2024_06_17_1718631351.png"></p>
<h3 id="0x32-store-buffers-and-memory-barriers">0x32 Store Buffers and Memory Barriers<a hidden class="anchor" aria-hidden="true" href="#0x32-store-buffers-and-memory-barriers">#</a></h3>
<p>Think of the program below</p>
<pre tabindex="0"><code>void foo(void)
{
  a=1;
  b=1;
}

void bar(void) {
  while (b == 0) continue;
  assert(a == 1);
}
</code></pre><ul>
<li>cpu0 executes foo
<ul>
<li>own “b”</li>
</ul>
</li>
<li>cpu1 executes bar
<ul>
<li>own “a”</li>
</ul>
</li>
</ul>
<hr>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled%206.2024_06_17_1718631356.png"></p>
<p>The problem is that, cpu1 reads “a” before being acknowledged that other cpus have changed it. Although CPU0 can continue to execute before writing it to stored buffer, but CPU1 doesn’t know that.</p>
<p>The hardware designers cannot help directly here, since the <strong>CPUs have no idea which variables are related, let alone how they might be related</strong></p>
<p>Therefore, the hardware designers provide <strong>memory-barrier</strong> instructions to allow the software to tell the CPU about such relations. The program fragment must be updated to contain the memory barrier:</p>
<pre tabindex="0"><code>void foo(void)
{
  a=1;
  smp_mb();
  b=1;
}

void bar(void)
{
  while (b == 0) continue;
  assert(a == 1);
}
</code></pre><p>The memory barrier <code>smp_mb()</code> will cause the CPU to flush its store buffer before applying subsequent stores to their cache lines. The CPU could either</p>
<ul>
<li>simply stall until the store buffer was empty before proceeding, or</li>
<li>it could only use the store buffer to hold subsequent stores until all of the prior entries in the store buffer had been applied.
<ul>
<li>This is to prevent other cpus from getting the subsequent value before getting the prior entries</li>
</ul>
</li>
</ul>
<p>So that, CPU0 will</p>
<ul>
<li>wait for the “invalidate acknowledge” message of “a” before executing “b=1;”</li>
</ul>
<p>or</p>
<ul>
<li>(1)while executing <code>smp_mb</code> ,marks all current store-buffer entries (namely, the a=1)</li>
<li>(2) while executing “b=1”, only stores it store buffer.</li>
<li>(3) wait “invalidate acknowledge” of “a”</li>
<li>(4) store the value of b in stored buffer and send a “invalidate” message</li>
</ul>
<h2 id="0x4-optimize-2-store-sequences-result-in-unnecessary-stalls">0x4 Optimize 2: Store Sequences Result in Unnecessary Stalls<a hidden class="anchor" aria-hidden="true" href="#0x4-optimize-2-store-sequences-result-in-unnecessary-stalls">#</a></h2>
<ol>
<li>Once the stored buffer is full or a memory barrier is encountered, the CPU must once again wait for invalidations to complete in order to drain its store buffer before it can continue executing</li>
<li>invalidate acknowledge messages can take so long: they must ensure that the corre- sponding cache line is actually invalidated, and this invalidation can be delayed if the cache is busy, for example, if the CPU is intensively loading and storing data, all of which resides in the cache.</li>
</ol>
<p>However, the CPU need not actually invalidate the cache line before sending the acknowledgement.</p>
<h3 id="0x42-invalidate-queues-and-invalidate-acknowledge">0x42 Invalidate Queues and Invalidate Acknowledge<a hidden class="anchor" aria-hidden="true" href="#0x42-invalidate-queues-and-invalidate-acknowledge">#</a></h3>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled%207.2024_06_17_1718631364.png"></p>
<p><strong>A CPU with an invalidate queue may acknowledge an invalidate message as soon as it is placed in the queue, instead of having to wait until the corresponding line is actually invalidated.</strong></p>
<h3 id="0x43-invalidate-queues-and-memory-barriers">0x43 Invalidate Queues and Memory Barriers<a hidden class="anchor" aria-hidden="true" href="#0x43-invalidate-queues-and-memory-barriers">#</a></h3>
<p>Thinking of the following code:</p>
<pre tabindex="0"><code>void foo(void)
{
  a=1;
  smp_mb();
  b=1;
}

void bar(void)
{
  while (b == 0) continue;
  assert(a == 1);
}
</code></pre><ul>
<li>CPU0:
<ul>
<li>execute foo</li>
<li>a is shared state</li>
<li>b is exclusive</li>
</ul>
</li>
<li>CPU1:
<ul>
<li>execute bar</li>
</ul>
</li>
</ul>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled%208.2024_06_17_1718631370.png"></p>
<ul>
<li>Once again, the CPU designers cannot do much about this situation</li>
<li>However, the memory-barrier instructions can interact with the invalidate queue.</li>
</ul>
<p>When a given CPU executes a memory barrier, it marks all the entries currently in its invalidate queue, and forces <strong>any subsequent load to wait until all marked entries have been applied to the CPU’s cache</strong>.</p>
<pre tabindex="0"><code>void foo(void)
{
  a=1;
  smp_mb();
  b=1;
}

void bar(void)
{
  while (b == 0) continue;
  smp_mb();
  assert(a == 1);
}
</code></pre><hr>
<p>So that, CPU0 will</p>
<ul>
<li>(1) executes the <code>smp_mb()</code>, marking the entry in its invalidate queue.</li>
<li>(2) start executing the assert(a==1), but a is in the invalidate queue, CPU 1 must stall this load until that entry in the invalidate queue has been applied.</li>
</ul>
<h2 id="0x5-summary-read-and-write-memory-barriers">0x5 Summary: Read and Write Memory Barriers<a hidden class="anchor" aria-hidden="true" href="#0x5-summary-read-and-write-memory-barriers">#</a></h2>
<p>In the previous section, memory barriers were used to mark entries in both the store buffer and the inval- idate queue. <strong>But in our code fragment, foo() had no reason to do anything with the invalidate queue, and bar() similarly had no reason to do anything with the store queue.</strong></p>
<p>Many CPU architectures therefore provide weaker memory-barrier instructions that do only one or the other of these two.</p>
<ul>
<li>read memory barrier:
<ul>
<li>marks only the invalidate queue</li>
<li>forces any subsequent <strong>load</strong> to wait until all marked entries have been applied from the <strong>invalidate queue</strong></li>
</ul>
</li>
<li>write memory barrier:
<ul>
<li>marks only the store buffer.</li>
<li>only use the store buffer to hold subsequent <strong>stores</strong> until all of the prior entries in the <strong>store buffer</strong> had been applied.</li>
</ul>
</li>
</ul>
<pre tabindex="0"><code>void foo(void)
{
  a=1;
  smp_wmb();
  b=1;
}

void bar(void)
{
  while (b == 0) continue;
  smp_rmb();
  assert(a == 1);
}
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share MESI AND MEMORY_BARRIER: paper reading on x"
            href="https://x.com/intent/tweet/?text=MESI%20AND%20MEMORY_BARRIER%3a%20paper%20reading&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2fmesi%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share MESI AND MEMORY_BARRIER: paper reading on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2fmesi%2f&amp;title=MESI%20AND%20MEMORY_BARRIER%3a%20paper%20reading&amp;summary=MESI%20AND%20MEMORY_BARRIER%3a%20paper%20reading&amp;source=http%3a%2f%2flocalhost%3a1313%2farticle%2fmesi%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share MESI AND MEMORY_BARRIER: paper reading on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2farticle%2fmesi%2f&title=MESI%20AND%20MEMORY_BARRIER%3a%20paper%20reading">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share MESI AND MEMORY_BARRIER: paper reading on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2farticle%2fmesi%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share MESI AND MEMORY_BARRIER: paper reading on whatsapp"
            href="https://api.whatsapp.com/send?text=MESI%20AND%20MEMORY_BARRIER%3a%20paper%20reading%20-%20http%3a%2f%2flocalhost%3a1313%2farticle%2fmesi%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share MESI AND MEMORY_BARRIER: paper reading on telegram"
            href="https://telegram.me/share/url?text=MESI%20AND%20MEMORY_BARRIER%3a%20paper%20reading&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2fmesi%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share MESI AND MEMORY_BARRIER: paper reading on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=MESI%20AND%20MEMORY_BARRIER%3a%20paper%20reading&u=http%3a%2f%2flocalhost%3a1313%2farticle%2fmesi%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
