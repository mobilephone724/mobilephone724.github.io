<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>roaring bitmap | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="0x0 Introduction A bitmap, also known as a bit array or bitset, is a data structure that represents a fixed-size sequence of bits. That is the value of the ith bit representing the existence of the the ith object. Bare bitmap can cost much memory according to the total substantial data size, even if we have stored little infomation. Roaring bitmap provide a new method to compress the bitmap structure.">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="http://localhost:1313/article/roaring_bitmap/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/article/roaring_bitmap/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="http://localhost:1313/article/roaring_bitmap/">
  <meta property="og:site_name" content="PaperMod">
  <meta property="og:title" content="roaring bitmap">
  <meta property="og:description" content="0x0 Introduction A bitmap, also known as a bit array or bitset, is a data structure that represents a fixed-size sequence of bits. That is the value of the ith bit representing the existence of the the ith object. Bare bitmap can cost much memory according to the total substantial data size, even if we have stored little infomation. Roaring bitmap provide a new method to compress the bitmap structure.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="article">
    <meta property="article:published_time" content="2024-05-07T21:04:38+08:00">
    <meta property="article:modified_time" content="2024-05-07T21:04:38+08:00">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="roaring bitmap">
<meta name="twitter:description" content="0x0 Introduction A bitmap, also known as a bit array or bitset, is a data structure that represents a fixed-size sequence of bits. That is the value of the ith bit representing the existence of the the ith object. Bare bitmap can cost much memory according to the total substantial data size, even if we have stored little infomation. Roaring bitmap provide a new method to compress the bitmap structure.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "较长的专题文章",
      "item": "http://localhost:1313/article/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "roaring bitmap",
      "item": "http://localhost:1313/article/roaring_bitmap/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "roaring bitmap",
  "name": "roaring bitmap",
  "description": "0x0 Introduction A bitmap, also known as a bit array or bitset, is a data structure that represents a fixed-size sequence of bits. That is the value of the ith bit representing the existence of the the ith object. Bare bitmap can cost much memory according to the total substantial data size, even if we have stored little infomation. Roaring bitmap provide a new method to compress the bitmap structure.",
  "keywords": [
    
  ],
  "articleBody": "0x0 Introduction A bitmap, also known as a bit array or bitset, is a data structure that represents a fixed-size sequence of bits. That is the value of the ith bit representing the existence of the the ith object. Bare bitmap can cost much memory according to the total substantial data size, even if we have stored little infomation. Roaring bitmap provide a new method to compress the bitmap structure.\n0x1 Related Infomation: blogs: (Very Important Introduction) [Blog of Vikram Oberoi]:A primer on Roaring bitmaps: what they are and how they work [blog of charlieroro] roaring bitmaps 【木东居士】：不深入而浅出 Roaring Bitmaps 的基本原理 paper Introduction: Better bitmap performance with Roaring bitmaps.pdf Opitmazition: Consistently faster and smaller compressed bitmaps with Roaring.pdf 0x2 Introduction TO Roaring Bitmap 0x21 two types of containers We partition the range of 32-bit indexes ([0, n)) into chunks of $2^{16}$ integers sharing the same 16 most significant digits. We use specialized containers to store their 16 least significant bits.\n(One chunk’ size is up to 8KB, that is 4096 integers.)\nWhen a chunk contains no more than 4096 integers, we use a sorted array of packed 16-bit integers. When there are more than 4096 integers, we use a $2^{16}$​-bit bitmap. Thus, we have two types of containers: an array container for sparse chunks and a bitmap container for dense chunks.\nSince the size of a chunk is up to 8KB, we may save much memoy if the cardinality is small. Don’t worry about the memory allocator, it can deal with the small memory with local buffer. And I believe it’s the most important meaning of two types of containers.\n0x22 conversion between the two types of container timing\nWhen removing an integer, a bitmap container might become an array container if its cardinality reaches 4096. When adding an integer, an array container might become a bitmap container when its cardinality exceeds 4096. method\nWhen this happens, a new container is created with the updated data while the old container is discarded. Converting an array container to a bitmap container is done by creating a new bitmap container initialized with zeros, and setting the corresponding bits. To convert a bitmap container to an array container, we extract the location of the set bits using an optimized algorithm 0x23 index array To check for the presence of a 32-bit integer x, we first seek the container corresponding to $x/2^{16}$ using binary search. If a bitmap container is found, we access the (x mod $2^{16}$)th bit. If an array container is found, we use a binary search again\nThe containers are stored in a dynamic array with the shared 16 most-significant bits: this serves as a first-level index. The array keeps the containers sorted by the 16 most-significant bits.\n0x3 set operations There are\nTwo basic opertions: union (bitwise OR) and intersection (bitwise AND); And three container type combinations: bitmap vs bitmap, array vs array annd bitmap vs array 0x31 bitmap vs bitmap union operation(the result must be a bitmap container) :\nIt might seem like computing bitwise ORs and computing the cardinality of the result\nwould be significantly slower than merely computing the bitwise ORs. However, four factors mitigate this potential problem\n[built in cpu instructions]: popular processors (Intel, AMD, ARM) have fast instructions to compute the number of ones in a word. Intel and AMD’s popcnt instruction has a throughput as high as one operation per CPU cycle. [Java Opitimization]: Recent Java implementations translate a call to Long.bitCount into such fast instructions. [superscalar]: Popular processors are superscalar: they can execute several operations at once. Thus, while we retrieve the next data elements, compute their bitwise OR and store it in memory, the processor can apply the popcnt instruction on the last result and increment the cardinality counter accordingly. [enough L1 cache]: For inexpensive data processing operations, the processor may not run at full capacity due to cache misses. intersection operation:\nFor computing intersections, we use a less direct route. First, we compute the cardinality of the result, using 1024 bitwise AND instructions. If the cardinality is larger than 4096, then we proceed as with the union, writing the result of bitwise ANDs to a new bitmap container. Otherwise, we create a new array container. We extract the set bits from the bitwise ANDs on the fly. See chapter “0x22” for detail\n0x32 bitmap vs array intersection(the result must be an array container)：we iterate over the sorted dynamic array, and verify the existence of each 16-bit integer in the bitmap container. The result is written out to an array container Unions(the result must be a bit map container)：we create a copy of the bitmap and simply iterate over the array, setting the corresponding bits 0x33 Array vs Array For unions: if the sum of the cardinalities is no more than 4096(the result must be an array container): we use a merge algorithm between the two arrays otherwise: Otherwise, we set the bits corresponding to both arrays in a bitmap container. We then compute the cardinality using fast instructions. If the cardinality is no more than 4096, we convert the bitmap container to an array containe. intersection(the result must be an array container): if the two arrays have cardinalities that differ by less than a factor of 64: merge otherwise: galloping intersection Galloping is superior to a simple merge when one array ($r$) is much smaller than other one ($f$) because it can skip many comparisons. Starting from the beginning of both arrays, we pick the next available integer $r_i$ from the small array $r$ and seek an integer at least as large $f_j$ in the large array $f$ , looking first at the next value, then looking at a value twice as far, and so on. Then, we use binary search to advance in the second list to the first value larger or equal to $r_i$ .\nGalloping(exponential search) Introduction\nThe initial value of bound can alway advance in each search.\n// Returns the position of key in the array arr of length size. template \u003ctypename T\u003e int exponential_search(T arr[], int size, T key) { if (size == 0) { return NOT_FOUND; } int bound = 1; while (bound \u003c size \u0026\u0026 arr[bound] \u003c key) { bound *= 2; } return binary_search(arr, key, bound/2, min(bound + 1, size)); } 0x34 in place operations When computing the union between two bitmap containers, we can modify one of the two bitmap containers instead of generating a new bitmap container. Similarly, for the intersection between two bitmap containers, we can modify one of the two containers if the cardinality of the result exceeds 4096 When computing the union between an array and a bitmap container, we can write the result to the bitmap container, by iterating over the values of the array container and setting the corresponding bits in the bitmap container. We can update the cardinality each time by checking whether the word value has been modified. 0x4 The “run” type container 0x41 To introduction to “run” The original Roaring has a limitation in some scenarios because it does not compress long runs of values. Indeed, given a bitset made of a few long runs (e.g., all integers in [10, 1000]), Roaring—as presented so far—can only offer suboptimal compression. If we consider the case of a bitmap made of all integers in [10, 1000], Roaring without support for runs would use 8 kB, whereas a few bytes ought to suffice.\nSuch unnecessarily large bitmaps can stress memory bandwidth. computing the intersection of two bitmaps representing the ranges [10, 1000] and [500, 10000] can be done in a few cycles when using RLE-compressed bitmaps. But the original Roaring would require intersecting two bitmap containers and possibly thousands of cycles. See chapter “0xF1” for detail. To solve this problem, we decided to add a third type of container to Roaring, one that is ideally suited to coding data made of runs of consecutive values. The new container is conceptually simple: **given a run (e.g., [10, 1000]), we store the starting point (10) and its length minus one (990). By packing the starting points and the lengths in pairs, using 16 bits each, **we preserve the ability to support fast random access by binary search through the coded runs\nThe run container, is made of a packed array of pairs of 16-bit integers. The first value of each pair represents a starting value, whereas the second value is the length of a run. For example, we would store the values 11, 12, 13, 14, 15 as the pair 11, 4 where 4 means that beyond 11 itself, there are 4 contiguous values that follow.\nIn addition to this packed array, we need to maintain the number of runs stored in the packed array. Like the array container, the run container is stored in a dynamic array. During serialization, we write out the number of runs, followed by the corresponding packed array.\n0x42 Decide The Best Container To decide the best container type, we are motivated to minimize storage. In serialized form, a run container uses 2 + 4r bytes(16-bit integer is 2 bytes and we need a pair; plus the number of runs) given r runs, a bitmap container always uses 8192 bytes and an array container uses 2c + 2 bytes, where c is the cardinality. Therefore, we apply the following rules:\nAll array containers are such that they use no more space than they would as a bitmap container: they contain no more than 4096 values. Bitmap containers use less space than they would as array containers: they contain more than 4096 values. A run container is only allowed to exist if it is smaller than either the array container or the bitmap container that could equivalently store the same values. If the run container has cardinality greater than 4096 values, then the number of runs must be no more than $\\lceil(8192 − 2)/4\\rceil = 2047$ runs. (Or it must be converted to a bitmap container) If the run container has cardinality no more than 4096, then the number of runs must be less than half the cardinality. (Or it must be converted to an array container) **So, the critical step in deciding whether an array or bitmap container should be converted to a run container is to count the number of runs of consecutive numbers it contains. **\n0x43 Compute The Number Of Runs For array containers, we count this number by iterating through the 16-bit integers and comparing them two by two in a straightforward manner. Because array containers have at most 4096 integers, this computation is expected to be fast.\nFor bitmap containers, the below algorithm shows how to compute the number of runs.\nWe can illustrate the core operation of the algorithm using a single 32-bit word containing 6 runs of consecutive ones:\nWe can verify that $\\mathrm{bitCount}((C_i \\ll 1)\\ \\mathrm{ANDNOT}\\ C_i) = 6$, that is, we have effectively computed the number of runs. ($a\\ \\mathrm{ANDNOT}\\ b$is true iff a=1 and b=0) In the case where a run continues up to the left-most bit, and does not continue in the next word, it does not get counted, but we add another term (($C_i \\gg 63$) ANDNOT $C_i+1$ when using 64-bit words) to check for this case. Nevertheless, the computation may be expensive—exceeding the cost of computing the union or intersection between two bitmap containers. Thus, instead of always computing the number of runs exactly, we rely on the observation that no bitmap container with more than 2047 runs should be converted. As soon as we can produce a lower bound exceeding 2047 on the number of runs, we can stop. An exact computation of the number of runs is important only when our lower bound is less than 2048. In short: estimate the lower bound count of runs first, and only do the precise computation if the lower bound is less than 2048.\nThere are several method to implement the heuristic algorithm, and see the paper for details.\n0x44 Logical operations There are many necessary logical operations, but we present primarily the union and intersection.\n0x441 Bitmap vs Bitmap: 0xF appendix 0xF1 RLE-based compressed bitmaps There are many RLE-based compression formats.\n0xF11 Introduction To WAH For example, WAH organizes the data in literal and fill words.\nLiteral words contain a mix of W − 1 zeros and ones (e.g., $01011 · · · 01$) where W denotes the word size in bits: typically W = 32 or W = 64. Fill words are made of just W − 1 ones or just W − 1 zeros (i.e., $11 · · · 11$ or $00 · · · 00$). WAH compresses sequences of consecutive identical fill words The most significant bit of each word distinguishes between fill and literal words\nWhen it is set to one, the remaining W −1 bits store the W −1 bits of a literal word. When it is set to zero, the second most significant bit indicates the bit value whereas the remaining bits are used to store the number of consecutive identical fill words (the run length) 0xF12 Introduction To Concise Concise is a variation that reduces the memory usage when the bitmap is _moderately sparse. _Instead of storing the run length using $W − 2$ bits, Concise uses only $W − 2 − \\lceil log2(W )\\rceil$ bits to indicate a run length $r$, reserving $\\lceil log2(W )\\rceil$ bits to store a value $p$. When $p$ is non-zero, we decode $r$ fill words, plus a single $W − 1$ bit word with its $p^{th}$ bit flipped.\nBelow is an example: ",
  "wordCount" : "2265",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-05-07T21:04:38+08:00",
  "dateModified": "2024-05-07T21:04:38+08:00",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/article/roaring_bitmap/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/article" title="article">
                    <span>article</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/article/">较长的专题文章</a></div>
    <h1 class="post-title entry-hint-parent">
      roaring bitmap
    </h1>
    <div class="post-meta"><span title='2024-05-07 21:04:38 +0800 CST'>May 7, 2024</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/article/roaring_bitmap.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#0x0-introduction" aria-label="0x0 Introduction">0x0 Introduction</a></li>
                <li>
                    <a href="#0x1-related-infomation" aria-label="0x1 Related Infomation:">0x1 Related Infomation:</a></li>
                <li>
                    <a href="#0x2-introduction-to-roaring-bitmap" aria-label="0x2 Introduction TO Roaring Bitmap">0x2 Introduction TO Roaring Bitmap</a><ul>
                        
                <li>
                    <a href="#0x21-two-types-of-containers" aria-label="0x21 two types of containers">0x21 two types of containers</a></li>
                <li>
                    <a href="#0x22-conversion-between-the-two-types-of-container" aria-label="0x22 conversion between the two types of container">0x22 conversion between the two types of container</a></li>
                <li>
                    <a href="#0x23-index-array" aria-label="0x23 index array">0x23 index array</a></li></ul>
                </li>
                <li>
                    <a href="#0x3-set-operations" aria-label="0x3 set operations">0x3 set operations</a><ul>
                        
                <li>
                    <a href="#0x31-bitmap-vs-bitmap" aria-label="0x31 bitmap vs bitmap">0x31 bitmap vs bitmap</a></li>
                <li>
                    <a href="#0x32-bitmap-vs-array" aria-label="0x32 bitmap vs array">0x32 bitmap vs array</a></li>
                <li>
                    <a href="#0x33-array-vs-array" aria-label="0x33 Array vs Array">0x33 Array vs Array</a></li>
                <li>
                    <a href="#0x34-in-place-operations" aria-label="0x34 in place operations">0x34 in place operations</a></li></ul>
                </li>
                <li>
                    <a href="#0x4-the-run-type-container" aria-label="0x4 The &ldquo;run&rdquo; type container">0x4 The &ldquo;run&rdquo; type container</a><ul>
                        
                <li>
                    <a href="#0x41--to-introduction-to-run" aria-label="0x41  To introduction to &ldquo;run&rdquo;">0x41  To introduction to &ldquo;run&rdquo;</a></li>
                <li>
                    <a href="#0x42-decide-the-best-container" aria-label="0x42 Decide The Best Container">0x42 Decide The Best Container</a></li>
                <li>
                    <a href="#0x43-compute-the-number-of-runs" aria-label="0x43 Compute The Number Of Runs">0x43 Compute The Number Of Runs</a></li>
                <li>
                    <a href="#0x44-logical-operations" aria-label="0x44 Logical operations">0x44 Logical operations</a><ul>
                        
                <li>
                    <a href="#0x441-bitmap-vs-bitmap" aria-label="0x441 Bitmap vs Bitmap:">0x441 Bitmap vs Bitmap:</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#0xf-appendix" aria-label="0xF appendix">0xF appendix</a><ul>
                        
                <li>
                    <a href="#0xf1-rle-based-compressed-bitmaps" aria-label="0xF1 RLE-based compressed bitmaps">0xF1 RLE-based compressed bitmaps</a><ul>
                        
                <li>
                    <a href="#0xf11-introduction-to-wah" aria-label="0xF11 Introduction To WAH">0xF11 Introduction To WAH</a></li>
                <li>
                    <a href="#0xf12-introduction-to-concise" aria-label="0xF12 Introduction To Concise">0xF12 Introduction To Concise</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="0x0-introduction">0x0 Introduction<a hidden class="anchor" aria-hidden="true" href="#0x0-introduction">#</a></h2>
<p>A bitmap, also known as a bit array or bitset, is a data structure that represents a fixed-size sequence of bits.  That is the value of the <em>ith</em> bit representing the existence of the the <em>ith object.</em>
Bare bitmap can cost much memory according to the total substantial data size, even if we have stored little infomation. Roaring bitmap provide a new method to compress the bitmap structure.</p>
<h2 id="0x1-related-infomation">0x1 Related Infomation:<a hidden class="anchor" aria-hidden="true" href="#0x1-related-infomation">#</a></h2>
<ul>
<li>blogs:
<ul>
<li>(Very Important Introduction) <a href="https://www.vikramoberoi.com/a-primer-on-roaring-bitmaps-what-they-are-and-how-they-work/?utm_source=blog.quastor.org&utm_medium=referral&utm_campaign=how-grab-implemented-rate-limiting">[Blog of Vikram Oberoi]:A primer on Roaring bitmaps: what they are and how they work</a></li>
<li><a href="https://www.cnblogs.com/charlieroro/p/17919505.html">[blog of charlieroro] roaring bitmaps</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1136054">【木东居士】：不深入而浅出 Roaring Bitmaps 的基本原理</a></li>
</ul>
</li>
<li>paper
<ul>
<li>Introduction: <a href="Better%20bitmap%20performance%20with%20Roaring%20bitmaps.pdf">Better bitmap performance with Roaring bitmaps.pdf</a></li>
<li>Opitmazition: <a href="Consistently%20faster%20and%20smaller%20compressed%20bitmaps%20with%20Roaring.pdf">Consistently faster and smaller compressed bitmaps with Roaring.pdf</a></li>
</ul>
</li>
</ul>
<h2 id="0x2-introduction-to-roaring-bitmap">0x2 Introduction TO Roaring Bitmap<a hidden class="anchor" aria-hidden="true" href="#0x2-introduction-to-roaring-bitmap">#</a></h2>
<h3 id="0x21-two-types-of-containers">0x21 two types of containers<a hidden class="anchor" aria-hidden="true" href="#0x21-two-types-of-containers">#</a></h3>
<p>We partition the range of 32-bit indexes ([0, n)) into chunks of $2^{16}$ integers sharing the same 16 most significant digits. We use specialized containers to store their 16 least significant bits.</p>
<p>(One chunk&rsquo; size is up to 8KB, that is 4096 integers.)</p>
<p>When a chunk contains no more than 4096 integers, we use a sorted array of packed 16-bit integers. When there are more than 4096 integers, we use a $2^{16}$​-bit bitmap. Thus, we have two types of containers: an array container for sparse chunks and a bitmap container for dense chunks.</p>
<p><strong>Since the size of a chunk is up to 8KB, we may save much memoy if the cardinality is small. Don&rsquo;t worry about the memory allocator, it can deal with the small memory with local buffer. And I believe it&rsquo;s the most important meaning of two types of containers.</strong></p>
<p><img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1714232020698-852891d5-53e1-4073-bf38-3b9f2fffc95d.2024_05_07_1715087143.png"></p>
<h3 id="0x22-conversion-between-the-two-types-of-container">0x22 conversion between the two types of container<a hidden class="anchor" aria-hidden="true" href="#0x22-conversion-between-the-two-types-of-container">#</a></h3>
<p><strong>timing</strong></p>
<ul>
<li>When removing an integer, a bitmap container might become an array container if its cardinality reaches 4096.</li>
<li>When adding an integer, an array container might become a bitmap container when its cardinality exceeds 4096.</li>
</ul>
<hr>
<p><strong>method</strong></p>
<ul>
<li>When this happens, a new container is created with the updated data while the old container is discarded.</li>
<li>Converting an array container to a bitmap container is done by creating a new bitmap container initialized with zeros, and setting the corresponding bits.</li>
<li>To convert a bitmap container to an array container, we extract the location of the set bits using an optimized algorithm</li>
</ul>
<p><img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1714140703751-4816ae74-12dc-4eab-b499-ed1f786bf183.2024_05_07_1715087159.png"></p>
<p><img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1714140720883-e0a87750-93f6-4962-b7f1-b1dc46055743.2024_05_07_1715087217.png"></p>
<h3 id="0x23-index-array">0x23 index array<a hidden class="anchor" aria-hidden="true" href="#0x23-index-array">#</a></h3>
<p>To check for the presence of a 32-bit integer x, we first seek the container corresponding to $x/2^{16}$ using binary search. If a bitmap container is found, we access the (x mod $2^{16}$)th bit. If an array container is found, we use a binary search again</p>
<blockquote>
<p>The containers are stored in a dynamic array with the shared 16 most-significant bits: this serves as a first-level index. The array keeps the containers sorted by the 16 most-significant bits.</p>
</blockquote>
<p><img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1714140793688-826bb436-f90a-4730-b85d-8cee646a7106.2024_05_07_1715087229.png"></p>
<h2 id="0x3-set-operations">0x3 set operations<a hidden class="anchor" aria-hidden="true" href="#0x3-set-operations">#</a></h2>
<p>There are</p>
<ul>
<li>Two basic opertions: union (bitwise OR) and intersection (bitwise AND);</li>
<li>And three container type combinations: bitmap vs bitmap, array vs array annd bitmap vs array</li>
</ul>
<h3 id="0x31-bitmap-vs-bitmap">0x31 bitmap vs bitmap<a hidden class="anchor" aria-hidden="true" href="#0x31-bitmap-vs-bitmap">#</a></h3>
<p><strong>union operation</strong>(<strong>the result must be a bitmap container</strong>) <strong>:</strong></p>
<p><img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1714140807012-1c9706c2-b1bb-4aab-b2b9-0aa1bcb2f030.2024_05_07_1715087239.png">
It might seem like computing bitwise ORs and computing the cardinality of the result</p>
<p>would be significantly slower than merely computing the bitwise ORs. However, four factors mitigate this potential problem</p>
<ol>
<li><strong>[built in cpu instructions]</strong>: popular processors (Intel, AMD, ARM) have fast instructions to compute the number of ones in a word. Intel and AMD’s <em>popcnt</em> instruction has a throughput as high as one
operation per CPU cycle.</li>
<li><strong>[Java Opitimization]</strong>: Recent Java implementations translate a call to Long.bitCount into such fast
instructions.</li>
<li><strong>[superscalar]:</strong> Popular processors are superscalar: they can execute several operations at once. Thus, while we retrieve the next data elements, compute their bitwise OR and store it in memory, the processor can apply the popcnt instruction on the last result and increment the cardinality counter accordingly.</li>
<li><strong>[enough L1 cache]</strong>: For inexpensive data processing operations, the processor may not run at full capacity due to cache misses.</li>
</ol>
<hr>
<p><strong>intersection operation:</strong></p>
<p>For computing intersections, we use a less direct route. First, we compute the cardinality of the result, using 1024 bitwise AND instructions. If the cardinality is larger than 4096, then we proceed as with the union, writing the result of bitwise ANDs to a new bitmap container. Otherwise, we create a new array container. We extract the set bits from the bitwise ANDs on the fly. See chapter &ldquo;0x22&rdquo; for detail</p>
<h3 id="0x32-bitmap-vs-array">0x32 bitmap vs array<a hidden class="anchor" aria-hidden="true" href="#0x32-bitmap-vs-array">#</a></h3>
<ul>
<li>intersection(<strong>the result must be an array container</strong>)：we iterate over the sorted dynamic array, and verify the existence of each 16-bit integer in the bitmap container. The result is written out to an array container</li>
<li>Unions(<strong>the result must be a bit map container</strong>)：we create a copy of the bitmap and simply iterate over the array, setting the corresponding bits</li>
</ul>
<h3 id="0x33-array-vs-array">0x33 Array vs Array<a hidden class="anchor" aria-hidden="true" href="#0x33-array-vs-array">#</a></h3>
<ul>
<li>For unions:
<ul>
<li>if the sum of the cardinalities is no more than 4096(<strong>the result must be an array container</strong>): we use a merge algorithm between the two arrays</li>
<li>otherwise: Otherwise, we set the bits corresponding to both arrays in a bitmap container. We then compute the cardinality using fast instructions. If the cardinality is no more than 4096, we convert the bitmap container to an array containe.</li>
</ul>
</li>
<li>intersection(<strong>the result must be an array container</strong>):
<ul>
<li>if the two arrays have cardinalities that differ by less than a factor of 64: merge</li>
<li>otherwise: galloping intersection</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Galloping</strong> is superior to a simple merge when one array ($r$) is much smaller than other one ($f$) because it can skip many comparisons. Starting from the beginning of both arrays, we pick the next available integer $r_i$ from the small array $r$ and seek an integer at least as large $f_j$ in the large array $f$ , looking first at the next value, then looking at a value twice as far, and so on. Then, we use binary search to advance in the second list to the first value larger or equal to $r_i$ .</p>
<p><a href="https://en.wikipedia.org/wiki/Exponential_search">Galloping(exponential search) Introduction</a></p>
<p>The initial value of <code>bound</code> can alway advance in each search.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Returns the position of key in the array arr of length size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">exponential_search</span><span class="p">(</span><span class="n">T</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="n">T</span> <span class="n">key</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">NOT_FOUND</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">bound</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">bound</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">bound</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">bound</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">binary_search</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bound</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="0x34-in-place-operations">0x34 in place operations<a hidden class="anchor" aria-hidden="true" href="#0x34-in-place-operations">#</a></h3>
<ul>
<li>When computing the union between two bitmap containers, we can modify one of the two bitmap containers instead of generating a new bitmap container. Similarly, for the intersection between two bitmap containers, we can modify one of the two containers if the cardinality of the result exceeds 4096</li>
<li>When computing the union between an array and a bitmap container, we can write the result to the bitmap container, by iterating over the values of the array container and setting the corresponding bits in the bitmap container. We can update the cardinality each time by checking whether the word value has been modified.</li>
</ul>
<h2 id="0x4-the-run-type-container">0x4 The &ldquo;run&rdquo; type container<a hidden class="anchor" aria-hidden="true" href="#0x4-the-run-type-container">#</a></h2>
<h3 id="0x41--to-introduction-to-run">0x41  To introduction to &ldquo;run&rdquo;<a hidden class="anchor" aria-hidden="true" href="#0x41--to-introduction-to-run">#</a></h3>
<p>The original Roaring has a limitation in some scenarios because it does not compress long runs of values. Indeed, given a bitset made of a few long runs (e.g., all integers in [10, 1000]), Roaring—as presented so far—can only offer suboptimal compression. If we consider the case of a bitmap made of all integers in [10, 1000], Roaring without support for runs would use 8 kB, whereas a few bytes ought to suffice.</p>
<ol>
<li>Such unnecessarily large bitmaps can stress memory bandwidth.</li>
<li>computing the intersection of two bitmaps representing the ranges [10, 1000] and [500, 10000] can be done in a few cycles when using RLE-compressed bitmaps. But the original Roaring would require intersecting two bitmap containers and possibly thousands of cycles. See chapter &ldquo;0xF1&rdquo; for detail.</li>
</ol>
<hr>
<p>To solve this problem, we decided to add a third type of container to Roaring, one that is ideally suited to coding data made of runs of consecutive values. The new container is <em>conceptually</em> simple: **given a run (e.g., [10, 1000]), we store the starting point (10) and its length minus one (990). By packing the starting points and the lengths in pairs, using 16 bits each, **we preserve the ability to support fast random access by binary search through the coded runs</p>
<p>The run container, <strong>is made of a packed array of pairs of 16-bit integers</strong>. The first value of each pair represents a starting value, whereas the second value is the length of a run. For example, we would store the values 11, 12, 13, 14, 15 as the pair 11, 4 where 4 means that beyond 11 itself, there are 4 contiguous values that follow.</p>
<p>In addition to this packed array, we need to <strong>maintain the number of runs</strong> stored in the packed array. Like the array container, the run container is stored in a dynamic array. During serialization, we <strong>write out the number of runs</strong>, followed by the corresponding packed array.</p>
<h3 id="0x42-decide-the-best-container">0x42 Decide The Best Container<a hidden class="anchor" aria-hidden="true" href="#0x42-decide-the-best-container">#</a></h3>
<p>To decide the best container type, <strong>we are motivated to minimize storage</strong>. In serialized form, a run container uses 2 + 4r bytes(16-bit integer is 2 bytes and we need a pair; plus the number of runs) given r runs, a bitmap container always uses 8192 bytes and an array container uses 2c + 2 bytes, where c is the cardinality. Therefore, we apply the following rules:</p>
<ul>
<li>All array containers are such that they use no more space than they would as a bitmap container: they contain no more than 4096 values.</li>
<li>Bitmap containers use less space than they would as array containers: they contain more than 4096 values.</li>
<li>A run container is only allowed to exist if it is smaller than either the array container or the bitmap container that could equivalently store the same values.
<ul>
<li>If the run container has cardinality greater than 4096 values, then the number of runs must be no more than $\lceil(8192 − 2)/4\rceil = 2047$  runs. (Or it must be converted to a bitmap container)</li>
<li>If the run container has cardinality no more than 4096, then the number of runs must be less than <strong>half the cardinality</strong>. (Or it must be converted to an array container)</li>
</ul>
</li>
</ul>
<p>**So, the critical step in deciding whether an array or bitmap container should be converted to a run container is to count the number of runs of consecutive numbers it contains. **</p>
<h3 id="0x43-compute-the-number-of-runs">0x43 Compute The Number Of Runs<a hidden class="anchor" aria-hidden="true" href="#0x43-compute-the-number-of-runs">#</a></h3>
<p>For array containers, we count this number by iterating through the 16-bit integers and comparing them two by two in a straightforward manner. Because array containers have at most 4096 integers, this computation is expected to be fast.</p>
<hr>
<p>For bitmap containers, the below algorithm shows how to compute the number of runs.</p>
<p><img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1714233519262-51a9cc7f-f364-4657-a05f-144704e3e8cf.2024_05_07_1715087279.png"></p>
<p>We can illustrate the core operation of the algorithm using a single 32-bit word containing 6 runs of consecutive ones:</p>
<p><img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1714234212202-1054aa9f-0e10-4459-a1da-790390a81620.2024_05_07_1715087290.png"></p>
<ul>
<li>We can verify that $\mathrm{bitCount}((C_i \ll 1)\ \mathrm{ANDNOT}\ C_i) = 6$, that is, we have effectively computed the number of runs.  ($a\ \mathrm{ANDNOT}\ b$is true iff a=1 and b=0)</li>
<li>In the case where a run continues up to the left-most bit, and does not continue in the next word, it does not get counted, but we add another term (($C_i \gg 63$) ANDNOT $C_i+1$ when using 64-bit words) to check for this case.</li>
</ul>
<p>Nevertheless, the computation may be expensive—exceeding the cost of computing the union or intersection between two bitmap containers. Thus, instead of always computing the number of runs exactly, we rely on the observation that no bitmap container with more than 2047 runs should be converted. As soon as we can produce a lower bound exceeding 2047 on the number of runs, we can stop. An exact computation of the number of runs is important only when our lower bound is less than 2048. <strong>In short: estimate the lower bound count of runs first, and only do the precise computation if the lower bound is less than 2048.</strong></p>
<p>There are several method to implement the heuristic algorithm, and see the paper for details.</p>
<p><img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1715086504011-260c924d-1b54-4c71-8070-e876236e8d5c.2024_05_07_1715087301.png"></p>
<h3 id="0x44-logical-operations">0x44 Logical operations<a hidden class="anchor" aria-hidden="true" href="#0x44-logical-operations">#</a></h3>
<p>There are many necessary logical operations, but we present primarily the <strong>union</strong> and <strong>intersection</strong>.</p>
<h4 id="0x441-bitmap-vs-bitmap">0x441 Bitmap vs Bitmap:<a hidden class="anchor" aria-hidden="true" href="#0x441-bitmap-vs-bitmap">#</a></h4>
<h2 id="0xf-appendix">0xF appendix<a hidden class="anchor" aria-hidden="true" href="#0xf-appendix">#</a></h2>
<h3 id="0xf1-rle-based-compressed-bitmaps">0xF1 RLE-based compressed bitmaps<a hidden class="anchor" aria-hidden="true" href="#0xf1-rle-based-compressed-bitmaps">#</a></h3>
<p>There are many RLE-based compression formats.</p>
<h4 id="0xf11-introduction-to-wah">0xF11 Introduction To WAH<a hidden class="anchor" aria-hidden="true" href="#0xf11-introduction-to-wah">#</a></h4>
<p>For example, <strong>WAH</strong> organizes the data in <em>literal</em> and <em>fill</em> words.</p>
<ul>
<li>Literal words contain a mix of W − 1 zeros and ones (e.g., $01011 · · · 01$) where W denotes the word size in bits: typically W = 32 or W = 64.</li>
<li>Fill words are made of just W − 1 ones or just W − 1 zeros (i.e., $11 · · · 11$ or $00 · · · 00$). WAH compresses sequences of consecutive identical fill words</li>
</ul>
<p>The most significant bit of each word distinguishes between fill and literal words</p>
<ul>
<li>When it is set to one, the remaining W −1 bits store the W −1 bits of a literal word.</li>
<li>When it is set to zero, the second most significant bit indicates the bit value whereas the remaining bits are used to store the number of consecutive identical fill words (the run length)</li>
</ul>
<h4 id="0xf12-introduction-to-concise">0xF12 Introduction To Concise<a hidden class="anchor" aria-hidden="true" href="#0xf12-introduction-to-concise">#</a></h4>
<p><strong>Concise</strong> is a variation that reduces the memory usage when the bitmap is _moderately sparse. _Instead of storing the run length using $W − 2$ bits, Concise uses only $W − 2 − \lceil log2(W )\rceil$ bits to indicate a run length $r$, reserving $\lceil log2(W )\rceil$ bits to store a value $p$. When $p$ is non-zero, we decode $r$ fill words, plus a single $W − 1$ bit word with its $p^{th}$ bit flipped.</p>
<p>Below is an example:
<img alt="image.png" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/1714231195835-441ff581-5a2b-49ad-b454-d875cbf5c3ae.2024_05_07_1715087318.png"></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share roaring bitmap on x"
            href="https://x.com/intent/tweet/?text=roaring%20bitmap&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2froaring_bitmap%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share roaring bitmap on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2froaring_bitmap%2f&amp;title=roaring%20bitmap&amp;summary=roaring%20bitmap&amp;source=http%3a%2f%2flocalhost%3a1313%2farticle%2froaring_bitmap%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share roaring bitmap on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2farticle%2froaring_bitmap%2f&title=roaring%20bitmap">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share roaring bitmap on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2farticle%2froaring_bitmap%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share roaring bitmap on whatsapp"
            href="https://api.whatsapp.com/send?text=roaring%20bitmap%20-%20http%3a%2f%2flocalhost%3a1313%2farticle%2froaring_bitmap%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share roaring bitmap on telegram"
            href="https://telegram.me/share/url?text=roaring%20bitmap&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2froaring_bitmap%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share roaring bitmap on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=roaring%20bitmap&u=http%3a%2f%2flocalhost%3a1313%2farticle%2froaring_bitmap%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
