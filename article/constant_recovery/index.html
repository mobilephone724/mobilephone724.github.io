<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>constant recovery with undo | PaperMod</title>
<meta name="keywords" content="">
<meta name="description" content="0x0 backgroud Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since recovering a long running transaction can take several hours.
This paper describes the overall design of “Constant Time Recovery” (CTR)">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="http://localhost:1313/article/constant_recovery/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/article/constant_recovery/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="http://localhost:1313/article/constant_recovery/">
  <meta property="og:site_name" content="PaperMod">
  <meta property="og:title" content="constant recovery with undo">
  <meta property="og:description" content="0x0 backgroud Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since recovering a long running transaction can take several hours.
This paper describes the overall design of “Constant Time Recovery” (CTR)">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="article">
    <meta property="article:published_time" content="2024-07-07T15:53:54+08:00">
    <meta property="article:modified_time" content="2024-07-07T15:53:54+08:00">
      <meta property="og:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://localhost:1313/images/papermod-cover.png">
<meta name="twitter:title" content="constant recovery with undo">
<meta name="twitter:description" content="0x0 backgroud Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since recovering a long running transaction can take several hours.
This paper describes the overall design of “Constant Time Recovery” (CTR)">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "较长的专题文章",
      "item": "http://localhost:1313/article/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "constant recovery with undo",
      "item": "http://localhost:1313/article/constant_recovery/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "constant recovery with undo",
  "name": "constant recovery with undo",
  "description": "0x0 backgroud Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since recovering a long running transaction can take several hours.\nThis paper describes the overall design of “Constant Time Recovery” (CTR)",
  "keywords": [
    
  ],
  "articleBody": "0x0 backgroud Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since recovering a long running transaction can take several hours.\nThis paper describes the overall design of “Constant Time Recovery” (CTR)\nRecovering the database to a consistent state requires undoing all operations performed by uncommitted transactions, and recovering a long running transaction can take several hours\n0x1 BACKGROUND ON SQL SERVER 0x11 DatabaseRecovery Following ARIES, the SQL Server recovery process has three distinct phases. Figure 2 demonstrates these phases and the portion of the log they process.\n(The oldest transaction can run across many checkpoints)\nanalysis: identifys: any transactions that must be rolled back LSN of the oldest dirty page in the system Checkpoint process captured all active transactions and the oldest dirty page LSN at the time of the checkpoint, so analysis can start from that redo: bringing the database back to the state it was at the time of the failure: Since Analysis has recomputed the Oldest Dirty Page LSN, Redo should only process the log from this point. Only applies the operation if the Page LSN is lower Processes the log starting from the beginning of the oldest active transaction. This allows recovery to reacquire all the locks held by active transactions and make the database available at the end of Redo for improved availability undo: rolling back any transactions that were active at the time of the failure. As Redo has reacquired the locks required by these transactions, the Undo process can be performed while the database is available and user queries will be blocked only if they attempt to access the data modified by the transactions pending undo. Undoing these operations is also logged using Compensation Log Records (CLR) to guarantee that the database is recoverable even after a failure in the middle of the Undo process 0x12 Multi-versionConcurrencyControl Versioning is performed at the row level: for every user data update, SQL Server updates the row in-place in the data page and pushes the old version of the row to an append-only version store, linking the current row version to the previous version\nThe versions are linked to each other using their physical locator\nGiven that these versions are only used for the purposes of SI, the version store doesn’t need to be preserved across restarts and is stored in SQL Server’s “TempDB”, a system database that is recycled every time the SQL Server process restarts. This allows for efficient version generation, as these operations are not logged.\n0x2 CONSTANTTIMERECOVERY 0x21 Overview Database recovery in constant time, regardless of the user workload and transaction sizes. Transaction rollback in constant time regardless of the transaction size. Continuous transaction log truncation, even in the presence of long running transactions. CTR achieves these by separating transactional operations into three distinct categories and handling their recovery using the most appropriate mechanism.\n0x22 three transactional operations categories 0x221 Data Modifications All data modifications are versioned, storing the earlier versions of each row in the version store that is now redesigned to be persistent and recoverable\n（笑死我了，刚刚还在感叹 version store 无需记录，重启即删多么方便）\nWhen a transaction rolls back, it is simply marked as “aborted”, indicating that any new transactions should ignore the versions generated by this transaction and access the earlier committed versions\nDuring database recovery\nAnalysis identifies the state of every transaction Redo recovers the row and the version store content as of the time of the failure. Undo marks the uncommitted transactions as aborted making all updates by these transactions invisible. This allows Undo to complete in constant time, regardless of the transaction sizes. （仍然和 aborted xact count 相关，但相比于 modified row count，几乎可以忽略不计） 0x222 System Operations System operations refer to internal operations the DBMS uses to maintain its internal data structures, such as space allocation and deallocation, B-Tree page splits, etc.\ndifficulty: These operations cannot be easily versioned Additionally, these operations are usually tied to user data modifications and can be a significant percentage of the operations performed by a long-running transaction. For example, a large data load allocates a large number of pages Solution: These operations are always performed by short-lived, system transactions that update the internal data structures and immediately commit When a failure occurs, these operations will not be undone, but the allocated space and other updated data structures will be lazily reclaimed and fixed up in the background. 0x223 Logical and Other Non-versioned Operations This last category refers to operations that cannot be versioned because they are either:\nlogical: such as lock acquisition operations that indicate that a certain lock must be acquired during recovery cache invalidation operations that are responsible for invalidating in-memory caches when a transaction rolls back they are modifying data structures that need to be accessed during start up must maintain a very specific format that does not allow versioning CTR leverages an additional log stream, SLog, that allows tracking only the relevant operations and not having to process the full transaction log for the corresponding transactions. 0x23 Persistent Version Store Persistent Version Store (PVS) allows row versions to be recoverable by storing them in the user database and logging them in the transaction log as regular user data.\nHence, at the end of Redo all versions are fully recovered and can be accessed by user transactions 0x231 In-row Version Store Since in most cases the difference between the two versions is small (for example when only a few columns are updated), we can simply store the diff between the two versions\nEven though computing and reapplying the diff requires additional CPU cycles, the cost of generating an off-row version, by accessing another page and logging the version as a separate operation, is significantly higher （再读另一个页代价更大） ![[attachments/Pasted image 20240714101730.png]]\n（ diff 怎么存储呢？定长的 id 字段可能不够！）\nDespite its benefits in most common cases, in-row versioning can negatively impact the performance of the system if it significantly increases the size of rows in the data pages. This is particularly problematic for B-Trees as it can lead to page splits. （diff 会占用大量空间，引起 page 数量膨胀，B树分裂代价高 ）\n0x232 Off-row Version Store It is implemented as an internal table that has no indexes since all version accesses are based on the version’s physical locator (Page Id, Slot Id) （纯 heap，无索引）\nEach version of user data is stored as a separate row in this table, having some columns for persisting version metadata and a generic binary column that contains the full version content, regardless of the schema of the user table this version belongs to. （存全量数据，而不仅是 diff)\nBy leveraging regular logging, off-row PVS is recovered using the traditional recovery mechanisms\n0x23 Logical Revert 0x231 overview CTR leverages the PVS to instantly roll back data modifications.\nWhen a query accesses a row, it first checks the state (active, committed or aborted) of the transaction that generated the latest version.\nIf the transaction is active or has been committed: visibility depends on the query isolation level. （ 事务提交，则看第一个 version ） but if the transaction is aborted, this version is definitely not visible and the query traverses the version chain to identify the version that belongs to a committed transaction and is visible. （ 事务回滚，则遍历 version chain ） Additionally, if a new transaction updates a row with an aborted version, it must first revert the effects of the aborted transaction before proceeding with the update. （ 做完 redo 后，the latest version 可能是 abort 状态，真正有效的 version 在 version chain 中，所以需要修复 the latest version ）\nCTR implements two different mechanisms for reverting the updates performed by aborted transactions:\nLogical Revert is the process of bringing the committed version of a row back to the main row in the data page,\nso that all queries can access it directly and versions in the version store are no longer required This process compares the state of the aborted and committed versions and performs the required compensating operation the revert operations are not versioned Since these transactions only revert a row at a time, they are guaranteed to be short-lived and don’t affect recovery time. Logical Revert is used by a background cleanup process to eliminate all updates performed by aborted transactions and eventually remove the aborted transactions from the system. ![[attachments/Pasted image 20240714110353.png]] overwrite the aborted version with the new version it is generating\nThis process minimizes the overhead for these operations and allows them to be almost as fast as if there was no aborted version. ![[attachments/Pasted image 20240714110439.png]] In CTR, the database is fully available, releasing all locks, while row versions are lazily cleaned up in the background.\n0x232 Transaction State Management For SI, visibility depends on the commit timestamp of the transaction that generated the version. Since SQL Server does not allow snapshot transactions to span server restarts, the commit timestamps can be stored in memory and need not be recovered. CTR, however, requires tracking the state of aborted transactions until all their versions have been logically reverted and are no longer accessible.\nCTR stores the aborted transaction information in the “Aborted Transaction Map” (ATM)\nRestore ATM after crash:\nWhen a transaction aborts, before releasing any locks, it will add its Transaction Id to the ATM and generate an “ABORT” log record indicating that it was aborted. （产生 ATM 信息） When a checkpoint occurs, the full content of the ATM is serialized into the transaction log as part of the checkpoint information. （ checkpoint 整理 ATM 信息 ） Since Analysis starts processing the log from the Checkpoint Begin LSN of the last successful checkpoint, or earlier, it will process this information regarding the aborted transactions and reconstruct the ATM. （ analysis 根据 checkpoint 重建 ATM ） Any transactions that aborted after the last checkpoint will not be included in the checkpoint, but Analysis will process their ABORT log records and add them to the map （ analysis 分析 checkpoint 后面事务的 ABORT log，并写入 ATM ） Following this process, Analysis can reconstruct the ATM as of the time of the failure, so that it is available when the database becomes available at the end of Redo.\nOnce all versions generated by an aborted transaction have been reverted, the transaction is no longer interesting for recovery and can be removed from the ATM.\nRemoving a transaction is also a logged operation, using a “FORGET” log record, to guarantee that the content of the ATM is recovered correctly. （Removing from ATM 也要新加日志？这也太复杂了。。。。）\n0x233 Short Transaction Optimization Maintaining the Aborted Transaction Map and forcing queries to visit additional versions incur a performance penalty, short OLTP transactions as they would significantly increase the size of the ATM\nWhen a transaction attempts to roll back, we evaluate the number of operations it performed and the amount of log it generated and qualify it as “short” if these don’t exceed certain thresholds.\nShort transactions will not go through the CTR rollback process, but use traditional undo, so that they are immediately removed from the system. （ 太多短事务导致 ATM 膨胀，解决方案为混用 CTR 和 undo？这么复杂么？ ）\n0x24 Non-versioned Operations A variety of operations that cannot be versioned because they are:\nLogical: such as acquiring coarse-grained locks invalidating various caches when a transaction rolls back accumulating row and page statistics Updating system metadata in data structures Updating critical system metadata required for starting up the database, before recovery can reconstruct versioning information, such as updates to the “boot page”, a special page that contains the core information required for initialization.（ ？这些东西还能做成page？，还有版本管理？这就是商业数据么？ ） To handle these operations while guaranteeing recovery in constant time, we are leveraging two different mechanisms:\n0x241 SLog: A Secondary Log Stream SLog is a secondary log stream designed to only track non-versioned operations that must be redone or undone using information from the corresponding log records.\nFor example, when altering the data type of a column in a large table, the transaction will have to update millions of rows, but SLog will only contain a handful log records, for acquiring the exclusive lock and invalidating metadata caches.\n",
  "wordCount" : "2014",
  "inLanguage": "en",
  "image": "http://localhost:1313/images/papermod-cover.png","datePublished": "2024-07-07T15:53:54+08:00",
  "dateModified": "2024-07-07T15:53:54+08:00",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/article/constant_recovery/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "PaperMod",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="PaperMod (Alt + H)">PaperMod</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/article" title="article">
                    <span>article</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://github.com/adityatelange/hugo-PaperMod/wiki/" title="WiKi">
                    <span>WiKi</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/article/">较长的专题文章</a></div>
    <h1 class="post-title entry-hint-parent">
      constant recovery with undo
    </h1>
    <div class="post-meta"><span title='2024-07-07 15:53:54 +0800 CST'>July 7, 2024</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;Theme PaperMod&nbsp;|&nbsp;<a href="https://github.com/adityatelange/hugo-PaperMod/tree/exampleSite/content/article/constant_recovery.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#0x0-backgroud" aria-label="0x0 backgroud">0x0 backgroud</a></li>
                <li>
                    <a href="#0x1-background-on-sql-server" aria-label="0x1 BACKGROUND ON SQL SERVER">0x1 BACKGROUND ON SQL SERVER</a><ul>
                        
                <li>
                    <a href="#0x11-databaserecovery" aria-label="0x11 DatabaseRecovery">0x11 DatabaseRecovery</a></li>
                <li>
                    <a href="#0x12-multi-versionconcurrencycontrol" aria-label="0x12 Multi-versionConcurrencyControl">0x12 Multi-versionConcurrencyControl</a></li></ul>
                </li>
                <li>
                    <a href="#0x2-constanttimerecovery" aria-label="0x2 CONSTANTTIMERECOVERY">0x2 CONSTANTTIMERECOVERY</a><ul>
                        
                <li>
                    <a href="#0x21-overview" aria-label="0x21 Overview">0x21 Overview</a></li>
                <li>
                    <a href="#0x22-three-transactional-operations-categories" aria-label="0x22 three transactional operations categories">0x22 three transactional operations categories</a><ul>
                        
                <li>
                    <a href="#0x221-data-modifications" aria-label="0x221 Data Modifications">0x221 Data Modifications</a></li>
                <li>
                    <a href="#0x222-system-operations" aria-label="0x222 System Operations">0x222 System Operations</a></li></ul>
                </li>
                <li>
                    <a href="#0x223-logical-and-other-non-versioned-operations" aria-label="0x223 Logical and Other Non-versioned Operations">0x223 Logical and Other Non-versioned Operations</a></li>
                <li>
                    <a href="#0x23-persistent-version-store" aria-label="0x23 Persistent Version Store">0x23 Persistent Version Store</a><ul>
                        
                <li>
                    <a href="#0x231-in-row-version-store" aria-label="0x231 In-row Version Store">0x231 In-row Version Store</a></li>
                <li>
                    <a href="#0x232-off-row-version-store" aria-label="0x232 Off-row Version Store">0x232 Off-row Version Store</a></li></ul>
                </li>
                <li>
                    <a href="#0x23-logical-revert" aria-label="0x23 Logical Revert">0x23 Logical Revert</a><ul>
                        
                <li>
                    <a href="#0x231-overview" aria-label="0x231 overview">0x231 overview</a></li>
                <li>
                    <a href="#0x232-transaction-state-management" aria-label="0x232 Transaction State Management">0x232 Transaction State Management</a></li>
                <li>
                    <a href="#0x233-short-transaction-optimization" aria-label="0x233 Short Transaction Optimization">0x233 Short Transaction Optimization</a></li></ul>
                </li>
                <li>
                    <a href="#0x24-non-versioned-operations" aria-label="0x24 Non-versioned Operations">0x24 Non-versioned Operations</a><ul>
                        
                <li>
                    <a href="#0x241-slog-a-secondary-log-stream" aria-label="0x241 SLog: A Secondary Log Stream">0x241 SLog: A Secondary Log Stream</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="0x0-backgroud">0x0 backgroud<a hidden class="anchor" aria-hidden="true" href="#0x0-backgroud">#</a></h2>
<p>Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, <strong>recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions</strong> which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since <strong>recovering a long running transaction can take several hours</strong>.</p>
<p>This paper describes the overall design of “<strong>Constant Time Recovery</strong>” (CTR)</p>
<p><strong>Recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions, and recovering a long running transaction can take several hours</strong></p>
<h2 id="0x1-background-on-sql-server"><strong>0x1 BACKGROUND ON SQL SERVER</strong><a hidden class="anchor" aria-hidden="true" href="#0x1-background-on-sql-server">#</a></h2>
<h3 id="0x11-databaserecovery"><strong>0x11 DatabaseRecovery</strong><a hidden class="anchor" aria-hidden="true" href="#0x11-databaserecovery">#</a></h3>
<p><strong>Following ARIES</strong>, the SQL Server recovery process has three distinct phases. Figure 2 demonstrates these phases and the portion of the log they process.</p>
<p><img alt="Untitled" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled.2024_08_08_1723123875.png"></p>
<p>(The oldest transaction can run across many checkpoints)</p>
<ul>
<li>analysis: identifys:
<ul>
<li>any transactions that must be rolled back</li>
<li>LSN of the oldest dirty page in the system
<ul>
<li>Checkpoint process captured all active transactions and the oldest dirty page LSN at the time of the checkpoint, so analysis can start from that</li>
</ul>
</li>
</ul>
</li>
<li>redo: <strong>bringing the database back to the state it was at the time of the failure:</strong>
<ul>
<li>Since Analysis has recomputed the <strong>Oldest Dirty Page LSN</strong>, Redo should only process the log from this point.
<ul>
<li>Only applies the operation if the Page LSN is lower</li>
</ul>
</li>
<li>Processes the log starting from the beginning of the <strong>oldest active transaction</strong>.
<ul>
<li>This allows recovery to <strong>reacquire all the locks held by active transactions</strong> and make the database <strong>available at the end of Redo for improved availability</strong></li>
</ul>
</li>
</ul>
</li>
<li>undo: <strong>rolling back any transactions that were active at the time of the failure.</strong>
<ul>
<li>As Redo has reacquired the locks required by these transactions, the Undo process can be performed while the database is available and user queries will be blocked only <strong>if they attempt to access the data modified by the transactions pending undo</strong>.</li>
<li>Undoing these operations is also logged using Compensation Log Records (<strong>CLR</strong>) to guarantee that the database is recoverable even after a failure in the middle of the Undo process</li>
</ul>
</li>
</ul>
<h3 id="0x12-multi-versionconcurrencycontrol"><strong>0x12 Multi-versionConcurrencyControl</strong><a hidden class="anchor" aria-hidden="true" href="#0x12-multi-versionconcurrencycontrol">#</a></h3>
<p>Versioning is performed at the row level: for every user data update, <strong>SQL Server updates the row in-place in the data page and pushes the old version of the row to an append-only version store</strong>, linking the current row version to the previous version</p>
<p>The versions are linked to each other using their physical locator</p>
<p><img alt="image-20240808213734702" loading="lazy" src="https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/image-20240808213734702.2024_08_08_1723124263.png"></p>
<p>Given that these versions are only used for the purposes of SI, the version store doesn’t need to be preserved across restarts and is stored in SQL Server’s “TempDB”, a system database that is recycled every time the SQL Server process restarts. This allows for efficient version generation, as these operations are not logged.</p>
<h2 id="0x2-constanttimerecovery"><strong>0x2 CONSTANTTIMERECOVERY</strong><a hidden class="anchor" aria-hidden="true" href="#0x2-constanttimerecovery">#</a></h2>
<h3 id="0x21-overview">0x21 <strong>Overview</strong><a hidden class="anchor" aria-hidden="true" href="#0x21-overview">#</a></h3>
<ul>
<li>Database recovery in constant time, regardless of the user workload and transaction sizes.</li>
<li>Transaction rollback in constant time regardless of the transaction size.</li>
<li>Continuous transaction log truncation, even in the presence of long running transactions.</li>
</ul>
<p>CTR achieves these by separating transactional operations into three distinct categories and handling their recovery using the most appropriate mechanism.</p>
<h3 id="0x22-three-transactional-operations-categories">0x22 three transactional operations categories<a hidden class="anchor" aria-hidden="true" href="#0x22-three-transactional-operations-categories">#</a></h3>
<h4 id="0x221-data-modifications">0x221 Data Modifications<a hidden class="anchor" aria-hidden="true" href="#0x221-data-modifications">#</a></h4>
<p>All data modifications are versioned, storing the earlier versions of each row in <strong>the version store that is now redesigned to be persistent and recoverable</strong></p>
<p>（笑死我了，刚刚还在感叹 version store 无需记录，重启即删多么方便）</p>
<p>When a transaction rolls back, it is simply marked as “aborted”, indicating that any new transactions should ignore the versions generated by this transaction and access the earlier committed versions</p>
<p>During database recovery</p>
<ul>
<li>Analysis identifies the state of every transaction</li>
<li><strong>Redo recovers the row and the version store</strong> content as of the time of the failure.</li>
<li><strong>Undo marks the uncommitted transactions as aborted</strong> making all updates by these
transactions invisible.
<ul>
<li>This allows Undo to complete in constant time, regardless of the transaction sizes.</li>
<li>（仍然和 aborted xact count 相关，但相比于 modified row count，几乎可以忽略不计）</li>
</ul>
</li>
</ul>
<h4 id="0x222-system-operations">0x222 System Operations<a hidden class="anchor" aria-hidden="true" href="#0x222-system-operations">#</a></h4>
<p>System operations refer to internal operations the DBMS uses to maintain its internal data structures, such as space allocation and deallocation, B-Tree page splits, etc.</p>
<ul>
<li>difficulty:
<ul>
<li>These operations cannot be easily versioned</li>
<li>Additionally, these operations are usually tied to user data modifications and can be a significant percentage of the operations performed by a long-running transaction.
<ul>
<li>For example, a large data load allocates a large number of pages</li>
</ul>
</li>
</ul>
</li>
<li>Solution:
<ul>
<li>These operations are always performed by short-lived, system transactions that update the internal data structures and immediately commit</li>
<li><strong>When a failure occurs, these operations will not be undone, but the allocated space and other updated data structures will be lazily reclaimed and fixed up in the background.</strong></li>
</ul>
</li>
</ul>
<h3 id="0x223-logical-and-other-non-versioned-operations">0x223 Logical and Other Non-versioned Operations<a hidden class="anchor" aria-hidden="true" href="#0x223-logical-and-other-non-versioned-operations">#</a></h3>
<p>This last category refers to operations that cannot be versioned because they are either:</p>
<ul>
<li>logical: such as
<ul>
<li>lock acquisition operations that indicate that a certain lock must be acquired during recovery</li>
<li>cache invalidation operations that are responsible for invalidating in-memory caches when a transaction rolls back</li>
</ul>
</li>
<li>they are modifying data structures that need to be accessed during start up
<ul>
<li>must maintain a very specific format that does not allow versioning
CTR leverages an additional log stream, SLog, that allows tracking only the relevant operations and not having to process the full transaction log for the corresponding transactions.</li>
</ul>
</li>
</ul>
<h3 id="0x23-persistent-version-store">0x23 Persistent Version Store<a hidden class="anchor" aria-hidden="true" href="#0x23-persistent-version-store">#</a></h3>
<p>Persistent Version Store (PVS) allows <strong>row versions to be recoverable</strong> by storing them in the user database and <strong>logging them in the transaction log as regular user</strong> data.</p>
<ul>
<li>Hence, at the end of Redo all versions are fully recovered and can be accessed by user transactions</li>
</ul>
<h4 id="0x231-in-row-version-store">0x231 In-row Version Store<a hidden class="anchor" aria-hidden="true" href="#0x231-in-row-version-store">#</a></h4>
<p>Since in most cases the difference between the two versions is small (for example when only a few columns are updated), we can simply store the diff between the two versions</p>
<ul>
<li>Even though computing and reapplying the diff requires additional CPU cycles, the cost of generating an off-row version, by accessing another page and logging the version as a separate operation, is significantly higher （再读另一个页代价更大）</li>
</ul>
<p>![[attachments/Pasted image 20240714101730.png]]</p>
<p>（ diff 怎么存储呢？定长的 id 字段可能不够！）</p>
<p>Despite its benefits in most common cases, in-row versioning can negatively impact the performance of the system if it significantly increases the size of rows in the data pages. This is particularly problematic for B-Trees as it can lead to page splits. （diff 会占用大量空间，引起 page 数量膨胀，B树分裂代价高 ）</p>
<h4 id="0x232-off-row-version-store">0x232 Off-row Version Store<a hidden class="anchor" aria-hidden="true" href="#0x232-off-row-version-store">#</a></h4>
<p>It is implemented as an internal table that has no indexes since all version accesses are based on the version’s physical locator (Page Id, Slot Id) （纯 heap，无索引）</p>
<p>Each version of user data is stored as a separate row in this table, having some columns for persisting version metadata and a generic binary column that contains the full version content, regardless of the schema of the user table this version belongs to. （存全量数据，而不仅是 diff)</p>
<p>By leveraging regular logging, off-row PVS is recovered using the traditional recovery mechanisms</p>
<h3 id="0x23-logical-revert">0x23 Logical Revert<a hidden class="anchor" aria-hidden="true" href="#0x23-logical-revert">#</a></h3>
<h4 id="0x231-overview">0x231 overview<a hidden class="anchor" aria-hidden="true" href="#0x231-overview">#</a></h4>
<p>CTR leverages the PVS to instantly roll back data modifications.</p>
<p>When a query accesses a row, it first checks the state (active, committed or aborted) of the transaction that generated the latest version.</p>
<ul>
<li>If the transaction is active or has been committed: visibility depends on the query isolation level. （ 事务提交，则看第一个 version ）</li>
<li>but if the transaction is aborted, this version is definitely not visible and the query traverses the version chain to identify the version that belongs to a committed transaction and is visible. （ 事务回滚，则遍历 version chain ）</li>
</ul>
<p>Additionally, if a new transaction updates a row with an aborted version, it must first revert the effects of the aborted transaction before proceeding with the update. （ 做完 redo 后，the latest version 可能是 abort 状态，真正有效的 version 在 version chain 中，所以需要修复 the latest version ）</p>
<p>CTR implements two different mechanisms for reverting the updates performed by aborted transactions:</p>
<p><strong>Logical Revert</strong> is the process of bringing the committed version of a row back to the main row in the data page,</p>
<ul>
<li>so that all queries can access it directly and versions in the version store are no longer required</li>
<li>This process compares the state of the aborted and committed versions and performs <strong>the required compensating operation</strong>
<ul>
<li>the revert operations are not versioned</li>
</ul>
</li>
<li>Since these transactions only revert a row at a time, they are guaranteed to be short-lived and don’t affect recovery time.</li>
<li>Logical Revert <strong>is used by a background cleanup process</strong> to eliminate all updates performed by aborted transactions and eventually remove the aborted transactions from the system.
![[attachments/Pasted image 20240714110353.png]]</li>
</ul>
<p><strong>overwrite</strong> the aborted version with the new version it is generating</p>
<ul>
<li>This process minimizes the overhead for these operations and allows them to be almost as fast as if there was no aborted version.
![[attachments/Pasted image 20240714110439.png]]</li>
</ul>
<p>In CTR, the database is fully available, releasing all locks, while row versions are lazily cleaned up in the background.</p>
<h4 id="0x232-transaction-state-management">0x232 Transaction State Management<a hidden class="anchor" aria-hidden="true" href="#0x232-transaction-state-management">#</a></h4>
<p>For SI, visibility depends on the commit timestamp of the transaction that generated the version. Since SQL Server does not allow snapshot transactions to span server restarts, the commit timestamps can be stored in memory and need not be recovered. <strong>CTR, however, requires tracking the state of aborted transactions until all their versions have been logically reverted and are no longer accessible.</strong></p>
<p>CTR stores the aborted transaction information in the “<strong>Aborted Transaction Map</strong>” (ATM)</p>
<p>Restore ATM after crash:</p>
<ul>
<li>When a transaction aborts, before releasing any locks, it will add its Transaction Id to the ATM and generate an “ABORT” log record indicating that it was aborted. （产生 ATM 信息）</li>
<li>When a checkpoint occurs, the full content of the ATM is serialized into the transaction log as part of the checkpoint information. （ checkpoint 整理 ATM 信息 ）</li>
<li>Since Analysis starts processing the log from the Checkpoint Begin LSN of the last successful checkpoint, or earlier, it will process this information regarding the aborted transactions and reconstruct the ATM. （ analysis 根据 checkpoint 重建 ATM ）</li>
<li>Any transactions that aborted after the last checkpoint will not be included in the checkpoint, but Analysis will process their ABORT log records and add them to the map （ analysis 分析 checkpoint 后面事务的 ABORT log，并写入 ATM ）</li>
</ul>
<p>Following this process, Analysis can reconstruct the ATM as of the time of the failure, so that it is available when the database becomes available at the end of Redo.</p>
<p>Once all versions generated by an aborted transaction have been reverted, the transaction is no longer interesting for recovery and can be removed from the ATM.</p>
<p>Removing a transaction is also a logged operation, using a “FORGET” log record, to guarantee that the content of the ATM is recovered correctly. （Removing from ATM 也要新加日志？这也太复杂了。。。。）</p>
<h4 id="0x233-short-transaction-optimization">0x233 Short Transaction Optimization<a hidden class="anchor" aria-hidden="true" href="#0x233-short-transaction-optimization">#</a></h4>
<p>Maintaining the <strong>Aborted Transaction Map</strong> and forcing queries to visit additional versions incur a performance penalty, <strong>short OLTP transactions as they would significantly increase the size of the ATM</strong></p>
<p>When a transaction attempts to roll back, we evaluate the <strong>number of operations</strong> it performed and the <strong>amount of log</strong> it generated and qualify it as “short” if these don’t exceed certain thresholds.</p>
<p>Short transactions will not go through the CTR rollback process, <strong>but use traditional undo</strong>, so that they are immediately removed from the system.
（ 太多短事务导致 ATM 膨胀，解决方案为混用 CTR 和 undo？这么复杂么？ ）</p>
<h3 id="0x24-non-versioned-operations">0x24 Non-versioned Operations<a hidden class="anchor" aria-hidden="true" href="#0x24-non-versioned-operations">#</a></h3>
<p>A variety of operations that cannot be versioned because they are:</p>
<ul>
<li>Logical: such as
<ul>
<li>acquiring coarse-grained locks</li>
<li>invalidating various caches when a transaction rolls back</li>
<li>accumulating row and page statistics</li>
</ul>
</li>
<li>Updating system metadata in data structures</li>
<li>Updating critical system metadata required for starting up the database, before recovery can reconstruct versioning information, such as updates to the “boot page”, a special page that contains the core information required for initialization.（ ？这些东西还能做成page？，还有版本管理？这就是商业数据么？ ）</li>
</ul>
<p>To handle these operations while guaranteeing recovery in constant time, we are leveraging two different mechanisms:</p>
<h4 id="0x241-slog-a-secondary-log-stream">0x241 SLog: A Secondary Log Stream<a hidden class="anchor" aria-hidden="true" href="#0x241-slog-a-secondary-log-stream">#</a></h4>
<p>SLog is a secondary log stream designed to <strong>only track non-versioned operations that must be redone or undone using information from the corresponding log records</strong>.</p>
<p>For example, when altering the data type of a column in a large table, the transaction will have to update millions of rows, but SLog will only contain a handful log records, for acquiring the exclusive lock and invalidating metadata caches.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share constant recovery with undo on x"
            href="https://x.com/intent/tweet/?text=constant%20recovery%20with%20undo&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2fconstant_recovery%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share constant recovery with undo on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2fconstant_recovery%2f&amp;title=constant%20recovery%20with%20undo&amp;summary=constant%20recovery%20with%20undo&amp;source=http%3a%2f%2flocalhost%3a1313%2farticle%2fconstant_recovery%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share constant recovery with undo on reddit"
            href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2farticle%2fconstant_recovery%2f&title=constant%20recovery%20with%20undo">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share constant recovery with undo on facebook"
            href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2farticle%2fconstant_recovery%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share constant recovery with undo on whatsapp"
            href="https://api.whatsapp.com/send?text=constant%20recovery%20with%20undo%20-%20http%3a%2f%2flocalhost%3a1313%2farticle%2fconstant_recovery%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share constant recovery with undo on telegram"
            href="https://telegram.me/share/url?text=constant%20recovery%20with%20undo&amp;url=http%3a%2f%2flocalhost%3a1313%2farticle%2fconstant_recovery%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share constant recovery with undo on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=constant%20recovery%20with%20undo&u=http%3a%2f%2flocalhost%3a1313%2farticle%2fconstant_recovery%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>© <a href="https://github.com/adityatelange/hugo-PaperMod/graphs/contributors">PaperMod Contributors</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
