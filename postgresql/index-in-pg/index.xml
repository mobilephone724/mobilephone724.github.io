<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hextra – Index In PostgreSQL</title>
    <link>https://mobilephone724.github.io/postgresql/index-in-pg/</link>
    <description>Recent content in Index In PostgreSQL on Hextra</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    
	  <atom:link href="https://mobilephone724.github.io/postgresql/index-in-pg/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Hot and Index</title>
      <link>https://mobilephone724.github.io/postgresql/index-in-pg/hot-and-index/</link>
      <pubDate>Fri, 13 Sep 2024 22:09:20 +0800</pubDate>
      
      <guid>https://mobilephone724.github.io/postgresql/index-in-pg/hot-and-index/</guid>
      <description>
        
        
        &lt;h2&gt;概述&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;概述&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;本文介绍 PostgreSQL 中 Heap Only Tuple(HOT) 技术以及创建索引相关的知识，主要包含以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HOT 的基本原理&lt;/li&gt;
&lt;li&gt;普通的创建索引 (Create Index) 流程&lt;/li&gt;
&lt;li&gt;同时创建索引 (Create Index Concurrently CIC) 的原理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文不包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;btree 等索引的具体实现方式&lt;/li&gt;
&lt;li&gt;PostgreSQL 对索引访问方式 (Access Method) 的抽象&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;HOT 基础&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;hot-基础&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#hot-%e5%9f%ba%e7%a1%80&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;简单而言, HOT(Heap Only Tuple) 指没有索引指向的元组，用于消除元组更新引起的索引膨胀，原理如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./hot_page.png&#34; alt=&#34;image-20240913221635357&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;索引指向 line_ptr_1 ，line_ptr_1 指向 tuple_1 ，tuple_1 被更新后成为 tuple_2，此时 tuple_1 指向 tuple_2&lt;/li&gt;
&lt;li&gt;索引指向 line_ptr_3 , line_ptr_3 指向 line_ptr_4 ，line_ptr_4 指向 tuple3&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，HOT 技术具有如下优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于被更新的元组，无需创建新的索引指针指向新元组&lt;/li&gt;
&lt;li&gt;旧元组可以被“普通操作”删除掉，并不一定需要 vacuum&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;HOT 链的构建&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;hot-链的构建&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#hot-%e9%93%be%e7%9a%84%e6%9e%84%e5%bb%ba&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;（一）：表 tbl(x int, y int) 在 x 上有索引，先插入一行  tuple_1=(x=1, y=1) ，结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_1.png&#34; alt=&#34;image-20240912110738151&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;（二）：当更新 tuple_1 为 (x=1,y=2) 时， 新增 lp_2, 和 tuple_2 ，但是不会新增索引指针，而是由 tuple_1 的 header 会记录 tuple_2 的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_2.png&#34; alt=&#34;image-20240912111405552&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;从可见性的角度思考，对于一个快照而言，一个 HOT 链上最多只有一个 tuple 可见。&lt;/p&gt;
&lt;p&gt;所以使用索引扫描时，会先找到 tuple_1 判断 tuple_ 1 是否符合可见性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 tuple_1 可见，那么立即返回，不在向下搜索。&lt;/li&gt;
&lt;li&gt;如果 tuple_1 不可见，再继续向下搜素。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（三）：再更新 tuple_1 为 tuple3=(x=1, y=3)，结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_3.png&#34; alt=&#34;image-20240912112236010&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;清理&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;清理&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%b8%85%e7%90%86&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;显然如果一个tuple一直被更新，那么这个链会很长，影响索引搜索的性能，所以需要去清理 HOT 链，清理分为两步，一个是 pruning （修剪），另一个是 defragmentation （碎片整理）&lt;/p&gt;
&lt;p&gt;（四）：pruning （修剪）：等 tuple_1 和 tuple_2 多所有事务都不可见时，则通过修改 line pointers，减少 hot 链的长度。 line pointer 2 可以被其他操作复用，但是 tuple_1 和 tuple_2 占用的空间仍没有被清理。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_4.png&#34; alt=&#34;image-20240912151435754&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;（五）：defragmentation （碎片整理）：将对应的 tuple 彻底删除，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_5.png&#34; alt=&#34;image-20240912151740670&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Create Index 的流程&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;create-index-的流程&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#create-index-%e7%9a%84%e6%b5%81%e7%a8%8b&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;该章节介绍普通的创建索引的大致过程，尤其是缓存一致性和对 HOT 的特殊处理&lt;/p&gt;
&lt;h3&gt;1 准备步骤&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;1-准备步骤&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#1-%e5%87%86%e5%a4%87%e6%ad%a5%e9%aa%a4&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;权限校验：包括&lt;/li&gt;
&lt;li&gt;选择索引名， access method （主要是确认 access method 是否存在）&lt;/li&gt;
&lt;li&gt;加锁：shared lock，阻止写入&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2 创建空索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;2-创建空索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#2-%e5%88%9b%e5%bb%ba%e7%a9%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;创建 heap &lt;code&gt;heap_create&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;build relcache&lt;/li&gt;
&lt;li&gt;创建文件 &lt;code&gt;smgrcreate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;记录依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;向 &lt;code&gt;pg_class&lt;/code&gt; , &lt;code&gt;pg_index&lt;/code&gt; , &lt;code&gt;pg_attribute&lt;/code&gt;  中写入对应的记录&lt;/li&gt;
&lt;li&gt;注册对应表的缓存无效信息，会在事务结束时发送 &lt;code&gt;CacheInvalidateRelcache&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3 调用对应的 index access method 创建索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-调用对应的-index-access-method-创建索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-%e8%b0%83%e7%94%a8%e5%af%b9%e5%ba%94%e7%9a%84-index-access-method-%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;这里和 HOT 关系较大，需要简单展开：&lt;/p&gt;
&lt;p&gt;在 index access method 内部，会使用回调函数 &lt;code&gt;heapam_index_build_range_scan&lt;/code&gt; 来扫描 heap，以确定有哪些 tuple 需要被创建索引。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;此时使用的快照为 &lt;code&gt;SnapshotAny&lt;/code&gt; ，即所有行都可见。&lt;/li&gt;
&lt;li&gt;每当扫描到一个 &lt;code&gt;tuple&lt;/code&gt; 时，像执行 vacuum 一样判断该 tuple 是否能被 vacuum。有一个 &lt;code&gt;tuple&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;对所有事务都不可见 &lt;code&gt;HEAPTUPLE_DEAD&lt;/code&gt;，那么显然不需要对他创建索引&lt;/li&gt;
&lt;li&gt;如果所有事务都可见 &lt;code&gt;HEAPTUPLE_LIVE&lt;/code&gt;，那么显然需要对他创建索引&lt;/li&gt;
&lt;li&gt;如果一些事务可见：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;HEAPTUPLE_RECENTLY_DEAD&lt;/code&gt; 被删除了，但是有些事务仍然可以看到？？？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INSERT_IN_PROGRESS&lt;/code&gt; 和 &lt;code&gt;DELETE_IN_PROGRESS&lt;/code&gt; ：考虑到大部分情况下 &lt;code&gt;create index&lt;/code&gt; 语句不会在事务块中执行，这里跳过。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;3-1 如何处理 &lt;code&gt;HEAPTUPLE_RECENTLY_DEAD&lt;/code&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-1-如何处理-heaptuple_recently_dead&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-1-%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-heaptuple_recently_dead&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4&gt;3-1-1 非 HOT&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-1-1-非-hot&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-1-1-%e9%9d%9e-hot&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;说明该 tuple 被删除了，但是有一些事务仍然对其可见，那么也需要加入到索引中。否则这些事务后续通过当前创建的索引就无法找到该元组。&lt;/p&gt;
&lt;p&gt;注意：在判断一个表有哪些索引时，使用快照是“最新的快照”，而非当前事务的快照。&lt;/p&gt;
&lt;h4&gt;3-1-2 HOT&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-1-2-hot&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-1-2-hot&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;如果该 tuple 在 HOT 链中，问题就有些棘手。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;此时不方便将 HOT 链破坏掉。（创建索引的时候直接修改 HEAP 中内容确实不算合理）&lt;/li&gt;
&lt;li&gt;但如果不破坏，就（必须）将该 tuple 加入到新索引中，而该 HOT 链可能和新索引冲突&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为此，PostgreSQL 采取了一种巧妙地方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不将该 tuple 加入到新索引中&lt;/li&gt;
&lt;li&gt;对于一些仍然可以访问该 tuple 的事务，阻止其使用新索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组织的方式为：pg_index 中有字段 &lt;code&gt;indcheckxmin&lt;/code&gt; 。当该字段为 true 时，如果有事务像用该索引，需要确保自己的 &lt;code&gt;TransactionXmin&lt;/code&gt; （逻辑）大于 &lt;code&gt;pg_index&lt;/code&gt;  中对应 tuple 的 &lt;code&gt;xmin&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TransactionXmin&lt;/code&gt; 表示当前事务的所有快照中，最小的的 xmin。（快照中， &lt;code&gt;xmin&lt;/code&gt; 前的事务都结束了）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pg_index&lt;/code&gt;  中对应 tuple 的 &lt;code&gt;xmin&lt;/code&gt; 表示 该索引创建的 xid&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;./indcheckxmin.png&#34; alt=&#34;image-20240908163824450&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;3-2 对 HOT 链上的元组构建索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-2-对-hot-链上的元组构建索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-2-%e5%af%b9-hot-%e9%93%be%e4%b8%8a%e7%9a%84%e5%85%83%e7%bb%84%e6%9e%84%e5%bb%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;由于创建新索引会导致已有的 HOT 链无效，这里还需讨论如何将已有 HOT 链中元组如何构建到索引中。考虑如下情形，现在需要对 &lt;code&gt;y&lt;/code&gt; 这一列创建索引，只需要将 tuple_3 加入到索引中(y=2)即可。由于一个 line pointer 只能在一个 HOT 链中，所以此时索引应该指向 lp_1（注意 tuple_1 有 y=1)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./build_on_hot.png&#34; alt=&#34;image-20240912154408429&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如果想去“优化“ 新HOT链的长度，让索引指向 lp_2 或者 lp_3，会产生很多问题，例如指向 lp_2，那么此时 tuple_2 还是 heap only tuple 么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./build_on_hot_2.png&#34; alt=&#34;image-20240912155430901&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Create Index Concurrently (CIC) 的原理解析&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;create-index-concurrently-cic-的原理解析&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#create-index-concurrently-cic-%e7%9a%84%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解决的问题：
&lt;ul&gt;
&lt;li&gt;同步创建索引 &lt;code&gt;create index concurrently&lt;/code&gt; 解决了创建索引期间，如何不阻塞正常执行 &lt;code&gt;DML&lt;/code&gt; 的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;思路：
&lt;ul&gt;
&lt;li&gt;和 &lt;code&gt;pg_repack&lt;/code&gt; , &lt;code&gt;pg_squeeze&lt;/code&gt; 等重写表的工具相似，内核中实现的同步创建索引也使用了 “存量 + 增量” 的方式。&lt;/li&gt;
&lt;li&gt;不同的是，官方提供的同步创建索引功能，几乎没有和任何其他特性耦合，例如没有使用触发器和逻辑复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;难点有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在不同的字段上，新创建一个索引会破坏 &lt;code&gt;heap&lt;/code&gt; 中的原 &lt;code&gt;HOT&lt;/code&gt; 链，创建的过程中也会影响到新的 &lt;code&gt;HOT&lt;/code&gt; 链。&lt;/li&gt;
&lt;li&gt;在不使用触发器和逻辑复制等功能的情况下，如何记录增量数据？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单流程：通过三个事务完成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务一：创建索引文件和修改系统表。 此时索引为 &lt;code&gt;not read&lt;/code&gt; + &lt;code&gt;not valid&lt;/code&gt;。但其他 SQL 需要遵循对应的 HOT 规则。&lt;/li&gt;
&lt;li&gt;事务二：获取快照 &lt;code&gt;A&lt;/code&gt; ，使用对该快照可见的元组创建索引。事务二结束后，其他 SQL 修改表时，也需要修改对应的索引。&lt;/li&gt;
&lt;li&gt;事务三：获取快照 &lt;code&gt;B&lt;/code&gt; ，将快照 &lt;code&gt;B&lt;/code&gt; 可见但快照 &lt;code&gt;A&lt;/code&gt; 不可见的元组插入索引&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;阶段一：创建空索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;阶段一创建空索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%98%b6%e6%ae%b5%e4%b8%80%e5%88%9b%e5%bb%ba%e7%a9%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;创建空索引的核心原因是：在将存量数据加入的索引中时，确保其他连接的修改不会破坏 HOT（更近一步的原因在阶段 2 描述）。方式为向 pg_index 中记录一个 &lt;code&gt;indisready==false &amp;amp;&amp;amp; indisvalid==false&lt;/code&gt; 的索引。所以问题在于：其他连接如何感知到该索引。&lt;/p&gt;
&lt;p&gt;每个连接都会缓存自己 &lt;code&gt;relcache&lt;/code&gt; 和 &lt;code&gt;syscache&lt;/code&gt; ，如果没有收到失效信息，这些缓存会一直保留。一般而言，事务开始时，会处理所有的缓存失效消息，在事务的执行的过程中，也有埋点来处理失效信息。但是处理结果不会返回给发送端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./empty_index.png&#34; alt=&#34;image-20240909222219633&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以为了保证其他连接都会看到新索引，在创建空索引的事务结束后，需要等到当前所有其他事务全部结束，才能开启第二阶段&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;代码实现与上述有所差别：&lt;/p&gt;
&lt;p&gt;“等待其他事务” 并不是通过巡检 &lt;code&gt;ProcArray&lt;/code&gt; 等方式实现，而是巧妙的使用了 &lt;code&gt;lmgr&lt;/code&gt; 层的 &lt;code&gt;WaitForLockers&lt;/code&gt; 实现：即等到没有连接持有该表的与 &lt;code&gt;ShareLock&lt;/code&gt; 相冲突的锁：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Now we must wait until no running transaction could have the table open
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * with the old list of indexes.  Use ShareLock to consider running
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * transactions that hold locks that permit writing to the table.  Note we
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * do not need to worry about xacts that open the table for writing after
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * this point; they will see the new index when they open it.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;WaitForLockers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;heaplocktag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ShareLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;（1）&lt;code&gt;SharedLock&lt;/code&gt;  与 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;select for update/share&lt;/code&gt; 相冲突，持有者两种锁时，都无法破坏 HOT 链。（2）当进程执行修改表的操作时，已经需要打开表获取 &lt;code&gt;relcache&lt;/code&gt; ，而在打开表操作时，会处理缓存失效信息。&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;pre&gt;&lt;code&gt;relation_open/try_relation_open -&amp;gt; LockRelationOid -&amp;gt; AcceptInvalidationMessages&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;./waitforlockers.png&#34; alt=&#34;image-20240910080804584&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;阶段二：使用存量数据创建索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;阶段二使用存量数据创建索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%98%b6%e6%ae%b5%e4%ba%8c%e4%bd%bf%e7%94%a8%e5%ad%98%e9%87%8f%e6%95%b0%e6%8d%ae%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在确保所有连接都发现了该索引时，可以使用存量数据创建索引&lt;/p&gt;
&lt;p&gt;该过程和普通的创建索引相似，但是进行 &lt;code&gt;heap&lt;/code&gt; 扫描时，使用的快照不同。在一般的索引创建中，使用的是 &lt;code&gt;SnapshotAny&lt;/code&gt; ，所有行都可见，而 CIC 中使用的是当前事务的快照。&lt;/p&gt;
&lt;p&gt;问题仍然出现在 HOT 链上，虽然对于创建索引的字段，当前不会产生新的 HOT 链，但是仍然会有旧的 HOT 链 ，所以构建索引的方式和普通地创建索引相同。&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始状态有 tuple_1 和 tuple_2 ，以及字段 a 上的索引。现对字段 b 创建建索引，&lt;/li&gt;
&lt;li&gt;tuple_1 对当前快照不可见（too old）&lt;/li&gt;
&lt;li&gt;tuple_2 可见。当把 tuple_2 加入到索引中时，索引值为 b=2，但索引入口指向 b=1 的元组（HOT链的开头），&lt;/li&gt;
&lt;li&gt;在阶段2中，有其他事务将 tuple_2 进行成了 tuple_3 ，将 c 改为了 2。该更新满足 HOT （a, b 都没有变），所以仍在 HOT 链上。但是 tuple_3 对当前快照（CIC）不可见 (in feature)，所以不处理。&lt;/li&gt;
&lt;li&gt;在阶段2中，有其他事务将 tuple_3 进行成了 tuple_4，将 b 改为了3。该更新不满足 HOT，所以索引 idx_a 需要创建新的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;./phase2_hot.png&#34; alt=&#34;image-20240912165540880&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当索引构建完毕后，将 pg_index 的中对应行的 &lt;code&gt;indisready&lt;/code&gt; 设置为 true，这样其他事务后续修改表时，会同步修改该索引。和阶段1相似，当前事务提交后，开启新的事物（xact3），等到其他事务都感知到 &lt;code&gt;indisready=true&lt;/code&gt; 时（同样使用 WaitForLockers 方案），开始阶段三。&lt;/p&gt;
&lt;h3&gt;阶段三： 增量数据的插入&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;阶段三-增量数据的插入&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%98%b6%e6%ae%b5%e4%b8%89-%e5%a2%9e%e9%87%8f%e6%95%b0%e6%8d%ae%e7%9a%84%e6%8f%92%e5%85%a5&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;该步骤的主要工作为把阶段二中遗漏的 tuple 加入索引中。方法为：使用当前的事务快照，将该快照可见的但是索引中没有的元组，加入索引中，具体做法为：&lt;/p&gt;
&lt;p&gt;（一）扫描索引，获取索引中所有的 ctid，并进行排序，得到 &lt;code&gt;Tuplesortstate&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（二）使用当前快照，进行全表扫描，对于每一行，在 &lt;code&gt;Tuplesortstate&lt;/code&gt; 搜索对应的 ctid。注意，如果是 heap only tuple，则使用其根 tuple 的 ctid。如果在 &lt;code&gt;Tuplesortstate&lt;/code&gt; 中没有找打，则向索引中插入对应的指针。&lt;/p&gt;
&lt;p&gt;举个例子： tuple_3 虽然是在阶段二中新增的 tuple ，但是其根 tuple，即 tuple_1 已经在索引中了，所以在阶段三中忽略。而 tuple_3 不在 HOT 链中，所以需要插入到元组中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./phase3_hot.png&#34; alt=&#34;image-20240912181510448&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;增量数据插入结束后，仍不能设置 &lt;code&gt;indisvalid=true&lt;/code&gt; ：考虑一个元组，它在阶段二中被创建，却在阶段三前被删除，所以此时它仍然不在索引中，但是可能有其他事务（事务 T）可以看到该元组；如果此时修改 &lt;code&gt;indisvalid=true&lt;/code&gt; 并提交，那么事务 T 使用该索引时，就无法获取到该元组 。故此时需要等事务 T 结束。：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./phase3_wait.png&#34; alt=&#34;image-20240912182449902&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以流程为将增量数据插入元组后，获取当前快照的 xmin，记为 xminlimit，并提交。之后开启新的事物，等待所有含有 &lt;code&gt;snap.xmin&amp;lt;xminlimit&lt;/code&gt; 的快照的事务全部提交，再设置 &lt;code&gt;indisvalid=true&lt;/code&gt; 并提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./phase3_wait_2.png&#34; alt=&#34;image-20240912184735020&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;提交后，所以事务（包括正在运行的）都可以使用新索引了。&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>HOT(Heap Only Tuple)</title>
      <link>https://mobilephone724.github.io/postgresql/index-in-pg/heap-only-tuple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://mobilephone724.github.io/postgresql/index-in-pg/heap-only-tuple/</guid>
      <description>
        
        
        &lt;h2&gt;概述&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;概述&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;简单而言, HOT(Heap Only Tuple) 指没有索引指向的元组 用于消除元组更新引起的索引膨胀，原理如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./hot_page.png&#34; alt=&#34;image-20240908114744268&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;索引指向 line_ptr_1 ，line_ptr_1 指向 tuple_1 ，tuple_1 被更新后成为 tuple_2，此时 tuple_1 指向 tuple_2&lt;/li&gt;
&lt;li&gt;索引指向 line_ptr_3 , line_ptr_3 指向 line_ptr_4 ，line_ptr_4 指向 tuple3&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，HOT 技术具有如下优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于被更新的元组，无需创建新的索引指针指向新元组&lt;/li&gt;
&lt;li&gt;旧元组可以被“普通操作”删除掉，并不一定需要 vacuum&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;related posts&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;related-posts&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#related-posts&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/455983543&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;postgreSQL HOT From ZhiHu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.postgresql.org/docs/current/storage-hot.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OFFICIAL DOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For more details , see &lt;code&gt;postgresql/src/backend/access/heap/README.HOT&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Main Commits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;282d2a03dd&lt;/code&gt;  HOT updates&lt;/li&gt;
&lt;li&gt;&lt;code&gt;6f10eb2111&lt;/code&gt;  Refactor heap_page_prune&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;TID&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;tid&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#tid&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;tuple 通过 t_ctid 字段指向其他 tuple&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/heap-tuple-header.2024_01_21_1705848176.png&#34; alt=&#34;image-20240121153315316&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;line pointer 通过 offset 指向其对应的 tuple&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/heap_page.2024_01_22_1705934933.png&#34; alt=&#34;image-20240122220305837&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;HOT 链的构建与清理&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;hot-链的构建与清理&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#hot-%e9%93%be%e7%9a%84%e6%9e%84%e5%bb%ba%e4%b8%8e%e6%b8%85%e7%90%86&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;构建&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;构建&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%9e%84%e5%bb%ba&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;（一）：表 tbl(x int, y int) 在 x 上有索引，先插入一行  tuple_1=(x=1, y=1) ，结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_1.png&#34; alt=&#34;image-20240912110738151&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;（二）：当更新 tuple_1 为 (x=1,y=2) 时， 新增 lp_2, 和 tuple_2 ，但是不会新增索引指针，而是由 tuple_1 的 header 会记录 tuple_2 的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_2.png&#34; alt=&#34;image-20240912111405552&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;从可见性的角度思考，对于一个快照而言，一个 HOT 链上最多只有一个 tuple 可见。&lt;/p&gt;
&lt;p&gt;所以使用索引扫描时，会先找到 tuple_1 判断 tuple_ 1 是否符合可见性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 tuple_1 可见，那么立即返回，不在向下搜索。&lt;/li&gt;
&lt;li&gt;如果 tuple_1 不可见，再继续向下搜素。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（三）：再更新 tuple_1 为 tuple3=(x=1, y=3)，结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_3.png&#34; alt=&#34;image-20240912112236010&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;清理&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;清理&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%b8%85%e7%90%86&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;显然如果一个tuple一直被更新，那么这个链会很长，影响索引搜索的性能，所以需要去清理 HOT 链，清理分为两步，一个是 pruning （修剪），另一个是 defragmentation （碎片整理）&lt;/p&gt;
&lt;p&gt;（四）：pruning （修剪）：等 tuple_1 和 tuple_2 多所有事务都不可见时，则通过修改 line pointers，减少 hot 链的长度。 line pointer 2 可以被其他操作复用，但是 tuple_1 和 tuple_2 占用的空间仍没有被清理。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_4.png&#34; alt=&#34;image-20240912151435754&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;（五）：defragmentation （碎片整理）：将对应的 tuple 彻底删除，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./index_insert_5.png&#34; alt=&#34;image-20240912151740670&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;清理时机&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;清理时机&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%b8%85%e7%90%86%e6%97%b6%e6%9c%ba&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;??（好复杂，后面再说）&lt;/p&gt;
&lt;h1&gt;Low Level Design&lt;/h1&gt;&lt;h2&gt;Key functions&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;key-functions&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#key-functions&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;heap_page_prune&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;heap_page_prune&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#heap_page_prune&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4&gt;&lt;code&gt;heap_page_prune_opt&lt;/code&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;heap_page_prune_opt&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#heap_page_prune_opt&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Optionally prune and repair fragmentation in the specified page.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;heap_page_prune_opt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;minfree&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RelationGetTargetPageFreeSpace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;minfree&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minfree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BLCKSZ&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;PageIsFull&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;PageGetHeapFreeSpace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minfree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ConditionalLockBufferForCleanup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;PageIsFull&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;PageGetHeapFreeSpace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minfree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nf&#34;&gt;heap_page_prune&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;h4&gt;&lt;code&gt;heap_page_prune&lt;/code&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;heap_page_prune-1&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#heap_page_prune-1&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Prune and repair fragmentation in the specified page.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;heap_page_prune&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FirstOffsetNumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxoff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;OffsetNumberNext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;heap_prune_chain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nredirected&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ndead&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nunused&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;heap_page_prune_execute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;h4&gt;&lt;code&gt;heap_prune_chain&lt;/code&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;heap_prune_chain&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#heap_prune_chain&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Prune specified line pointer or a HOT chain originating at line pointer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;heap_prune_chain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* while not end of the chain */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(;;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;PageGetItemId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/* Unused item obviously isn&amp;#39;t part of the chain */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ItemIdIsUsed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ItemIdIsRedirected&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nchain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;			&lt;span class=&#34;cm&#34;&gt;/* not at start of chain */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;chainitems&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nchain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ItemIdGetRedirect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rootlp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ItemIdIsDead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;htup&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HeapTupleHeader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;PageGetItem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;     * Check the tuple XMIN against prior XMAX, if any
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;     */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;TransactionIdIsValid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;priorXmax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;TransactionIdEquals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HeapTupleHeaderGetXmin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;htup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;priorXmax&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;cm&#34;&gt;/* record each item of this chain */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     &lt;span class=&#34;n&#34;&gt;chainitems&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nchain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HTSV_Result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;htsv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;HEAPTUPLE_DEAD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;tupdead&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;HEAPTUPLE_RECENTLY_DEAD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;heap_prune_record_prunable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                    &lt;span class=&#34;nf&#34;&gt;HeapTupleHeaderGetUpdateXid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;htup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;OffsetNumberIsValid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;latestdead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nchain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chainitems&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;latestdead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nf&#34;&gt;heap_prune_record_unused&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chainitems&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;ndeleted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nchain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;cm&#34;&gt;/* The whole chain is dead */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nf&#34;&gt;heap_prune_record_dead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rootoffnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;						&lt;span class=&#34;cm&#34;&gt;/* Or just redirect */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nf&#34;&gt;heap_prune_record_redirect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prstate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rootoffnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chainitems&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;heap_prune_record_redirect&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;code&gt;heap_page_prune_execute&lt;/code&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;heap_page_prune_execute&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#heap_page_prune_execute&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Perform the actual page changes needed by heap_page_prune&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;heap_page_prune_execute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* redirect */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nredirected&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;ItemIdSetRedirect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fromlp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tooff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* dead */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ndead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;ItemIdSetDead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;cm&#34;&gt;/* unused */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nunused&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nf&#34;&gt;ItemIdSetUnused&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;PageRepairFragmentation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;page_verify_redirects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;h4&gt;search HOT chain&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;search-hot-chain&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#search-hot-chain&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;heap_hot_search_buffer&lt;/code&gt; search HOT chain for tuple satisfying snapshot&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;heap_hot_search_buffer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;blkno&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ItemPointerGetBlockNumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ItemPointerGetOffsetNumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(;;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;PageGetItemId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;offnum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;heapTuple&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t_data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HeapTupleHeader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;PageGetItem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;

      </description>
    </item>
    
    <item>
      <title>create index basics</title>
      <link>https://mobilephone724.github.io/postgresql/index-in-pg/create-index-basics/</link>
      <pubDate>Sun, 08 Sep 2024 14:41:35 +0800</pubDate>
      
      <guid>https://mobilephone724.github.io/postgresql/index-in-pg/create-index-basics/</guid>
      <description>
        
        
        &lt;h2&gt;0 概述&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;0-概述&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#0-%e6%a6%82%e8%bf%b0&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;本文介绍普通的创建索引的大致过程（或者说 access method 对应的框架），包括从入口函数，到进入对应的 &lt;code&gt;access method&lt;/code&gt; 的过程。不包括 &lt;code&gt;access method&lt;/code&gt; 的内部实现。分区表，表达式索引等非主要特性这里省略。&lt;/p&gt;
&lt;h2&gt;1 准备步骤&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;1-准备步骤&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#1-%e5%87%86%e5%a4%87%e6%ad%a5%e9%aa%a4&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;权限校验：包括&lt;/li&gt;
&lt;li&gt;选择索引名， access method （主要是确认 access method 是否存在）&lt;/li&gt;
&lt;li&gt;加锁：shared lock，阻止写入&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;2 创建空索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;2-创建空索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#2-%e5%88%9b%e5%bb%ba%e7%a9%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建 heap &lt;code&gt;heap_create&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;build relcache&lt;/li&gt;
&lt;li&gt;创建文件 &lt;code&gt;smgrcreate&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;记录依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;向 &lt;code&gt;pg_class&lt;/code&gt; , &lt;code&gt;pg_index&lt;/code&gt; , &lt;code&gt;pg_attribute&lt;/code&gt;  中写入对应的记录&lt;/li&gt;
&lt;li&gt;注册对应表的缓存无效信息，会在事务结束时发送 &lt;code&gt;CacheInvalidateRelcache&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;3 调用对应的 index access method 创建索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-调用对应的-index-access-method-创建索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-%e8%b0%83%e7%94%a8%e5%af%b9%e5%ba%94%e7%9a%84-index-access-method-%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这里和 HOT 关系较大，需要简单展开：&lt;/p&gt;
&lt;p&gt;在 index access method 内部，会使用回调函数 &lt;code&gt;heapam_index_build_range_scan&lt;/code&gt; 来扫描 heap，以确定有哪些 tuple 需要被创建索引。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;此时使用的快照为 &lt;code&gt;SnapshotAny&lt;/code&gt; ，即所有行都可见。&lt;/li&gt;
&lt;li&gt;每当扫描到一个 &lt;code&gt;tuple&lt;/code&gt; 时，像执行 vacuum 一样判断该 tuple 是否能被 vacuum。有一个 &lt;code&gt;tuple&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;对所有事务都不可见 &lt;code&gt;HEAPTUPLE_DEAD&lt;/code&gt;，那么显然不需要对他创建索引&lt;/li&gt;
&lt;li&gt;如果所有事务都可见 &lt;code&gt;HEAPTUPLE_LIVE&lt;/code&gt;，那么显然需要对他创建索引&lt;/li&gt;
&lt;li&gt;如果一些事务可见：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;HEAPTUPLE_RECENTLY_DEAD&lt;/code&gt; 被删除了，但是有些事务仍然可以看到？？？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INSERT_IN_PROGRESS&lt;/code&gt; 和 &lt;code&gt;DELETE_IN_PROGRESS&lt;/code&gt; ：考虑到大部分情况下 &lt;code&gt;create index&lt;/code&gt; 语句不会在事务块中执行，这里跳过。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;3-1 如何处理 &lt;code&gt;HEAPTUPLE_RECENTLY_DEAD&lt;/code&gt;&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-1-如何处理-heaptuple_recently_dead&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-1-%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-heaptuple_recently_dead&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4&gt;3-1-1 非 HOT&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-1-1-非-hot&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-1-1-%e9%9d%9e-hot&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;说明该 tuple 被删除了，但是有一些事务仍然对其可见，那么也需要加入到索引中。否则这些事务后续通过当前创建的索引就无法找到该元组。&lt;/p&gt;
&lt;p&gt;注意：在判断一个表有哪些索引时，使用快照是“最新的快照”，而非当前事务的快照。&lt;/p&gt;
&lt;h4&gt;3-1-2 HOT&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-1-2-hot&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-1-2-hot&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;如果该 tuple 在 HOT 链中，问题就有些棘手。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;此时不方便将 HOT 链破坏掉。（创建索引的时候直接修改 HEAP 中内容确实不算合理）&lt;/li&gt;
&lt;li&gt;但如果不破坏，就（必须）将该 tuple 加入到新索引中，而该 HOT 链可能和新索引冲突&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为此，PostgreSQL 采取了一种巧妙地方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不将该 tuple 加入到新索引中&lt;/li&gt;
&lt;li&gt;对于一些仍然可以访问该 tuple 的事务，阻止其使用新索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组织的方式为：pg_index 中有字段 &lt;code&gt;indcheckxmin&lt;/code&gt; 。当该字段为 true 时，如果有事务像用该索引，需要确保自己的 &lt;code&gt;TransactionXmin&lt;/code&gt; （逻辑）大于 &lt;code&gt;pg_index&lt;/code&gt;  中对应 tuple 的 &lt;code&gt;xmin&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;TransactionXmin&lt;/code&gt; 表示当前事务的所有快照中，最小的的 xmin。（快照中， &lt;code&gt;xmin&lt;/code&gt; 前的事务都结束了）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pg_index&lt;/code&gt;  中对应 tuple 的 &lt;code&gt;xmin&lt;/code&gt; 表示 该索引创建的 xid&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;./indcheckxmin.png&#34; alt=&#34;image-20240908163824450&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;3-2 对 HOT 链上的元组构建索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;3-2-对-hot-链上的元组构建索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#3-2-%e5%af%b9-hot-%e9%93%be%e4%b8%8a%e7%9a%84%e5%85%83%e7%bb%84%e6%9e%84%e5%bb%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;由于创建新索引会导致已有的 HOT 链无效，这里还需讨论如何将已有 HOT 链中元组如何构建到索引中。考虑如下情形，现在需要对 &lt;code&gt;y&lt;/code&gt; 这一列创建索引，只需要将 tuple_3 加入到索引中(y=2)即可。由于一个 line pointer 只能在一个 HOT 链中，所以此时索引应该指向 lp_1（注意 tuple_1 有 y=1)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./build_on_hot.png&#34; alt=&#34;image-20240912154408429&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;如果想去“优化“ 新HOT链的长度，让索引指向 lp_2 或者 lp_3，会产生很多问题，例如指向 lp_2，那么此时 tuple_2 还是 heap only tuple 么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./build_on_hot_2.png&#34; alt=&#34;image-20240912155430901&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>create index concurrently</title>
      <link>https://mobilephone724.github.io/postgresql/index-in-pg/create-index-concurrently/</link>
      <pubDate>Tue, 13 Aug 2024 21:18:43 +0800</pubDate>
      
      <guid>https://mobilephone724.github.io/postgresql/index-in-pg/create-index-concurrently/</guid>
      <description>
        
        
        &lt;h2&gt;概述&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;概述&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;解决的问题：
&lt;ul&gt;
&lt;li&gt;同步创建索引 &lt;code&gt;create index concurrently&lt;/code&gt; 解决了创建索引期间，如何不阻塞正常执行 &lt;code&gt;DML&lt;/code&gt; 的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;思路：
&lt;ul&gt;
&lt;li&gt;和 &lt;code&gt;pg_repack&lt;/code&gt; , &lt;code&gt;pg_squeeze&lt;/code&gt; 等重写表的工具相似，内核中实现的同步创建索引也使用了 “存量 + 增量” 的方式。&lt;/li&gt;
&lt;li&gt;不同的是，官方提供的同步创建索引功能，几乎没有和任何其他特性耦合，例如没有使用触发器和逻辑复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;难点有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在不同的字段上，新创建一个索引会破坏 &lt;code&gt;heap&lt;/code&gt; 中的原 &lt;code&gt;HOT&lt;/code&gt; 链，创建的过程中也会影响到新的 &lt;code&gt;HOT&lt;/code&gt; 链。&lt;/li&gt;
&lt;li&gt;在不使用触发器和逻辑复制等功能的情况下，如何记录增量数据？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单流程：通过三个事务完成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事务一：创建索引文件和修改系统表。 此时索引为 &lt;code&gt;not read&lt;/code&gt; + &lt;code&gt;not valid&lt;/code&gt;。但其他 SQL 需要遵循对应的 HOT 规则。&lt;/li&gt;
&lt;li&gt;事务二：获取快照 &lt;code&gt;A&lt;/code&gt; ，使用对该快照可见的元组创建索引。事务二结束后，其他 SQL 修改表时，也需要修改对应的索引。&lt;/li&gt;
&lt;li&gt;事务三：获取快照 &lt;code&gt;B&lt;/code&gt; ，将快照 &lt;code&gt;B&lt;/code&gt; 可见但快照 &lt;code&gt;A&lt;/code&gt; 不可见的元组插入索引&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;阶段一：创建空索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;阶段一创建空索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%98%b6%e6%ae%b5%e4%b8%80%e5%88%9b%e5%bb%ba%e7%a9%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;创建空索引的核心原因是：在将存量数据加入的索引中时，确保其他连接的修改不会破坏 HOT（更近一步的原因在阶段 2 描述）。方式为向 pg_index 中记录一个 &lt;code&gt;indisready==false &amp;amp;&amp;amp; indisvalid==false&lt;/code&gt; 的索引。所以问题在于：其他连接如何感知到该索引。&lt;/p&gt;
&lt;p&gt;每个连接都会缓存自己 &lt;code&gt;relcache&lt;/code&gt; 和 &lt;code&gt;syscache&lt;/code&gt; ，如果没有收到失效信息，这些缓存会一直保留。一般而言，事务开始时，会处理所有的缓存失效消息，在事务的执行的过程中，也有埋点来处理失效信息。但是处理结果不会返回给发送端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./empty_index.png&#34; alt=&#34;image-20240909222219633&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以为了保证其他连接都会看到新索引，在创建空索引的事务结束后，需要等到当前所有其他事务全部结束，才能开启第二阶段&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;代码实现与上述有所差别：&lt;/p&gt;
&lt;p&gt;“等待其他事务” 并不是通过巡检 &lt;code&gt;ProcArray&lt;/code&gt; 等方式实现，而是巧妙的使用了 &lt;code&gt;lmgr&lt;/code&gt; 层的 &lt;code&gt;WaitForLockers&lt;/code&gt; 实现：即等到没有连接持有该表的与 &lt;code&gt;ShareLock&lt;/code&gt; 相冲突的锁：&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Now we must wait until no running transaction could have the table open
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * with the old list of indexes.  Use ShareLock to consider running
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * transactions that hold locks that permit writing to the table.  Note we
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * do not need to worry about xacts that open the table for writing after
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * this point; they will see the new index when they open it.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;WaitForLockers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;heaplocktag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ShareLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;（1）&lt;code&gt;SharedLock&lt;/code&gt;  与 &lt;code&gt;select&lt;/code&gt; 和 &lt;code&gt;select for update/share&lt;/code&gt; 相冲突，持有者两种锁时，都无法破坏 HOT 链。（2）当进程执行修改表的操作时，已经需要打开表获取 &lt;code&gt;relcache&lt;/code&gt; ，而在打开表操作时，会处理缓存失效信息。&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;pre&gt;&lt;code&gt;relation_open/try_relation_open -&amp;gt; LockRelationOid -&amp;gt; AcceptInvalidationMessages&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;&lt;img src=&#34;waitforlockers.png&#34; alt=&#34;image-20240910080804584&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;阶段二：使用存量数据创建索引&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;阶段二使用存量数据创建索引&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%98%b6%e6%ae%b5%e4%ba%8c%e4%bd%bf%e7%94%a8%e5%ad%98%e9%87%8f%e6%95%b0%e6%8d%ae%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在确保所有连接都发现了该索引时，可以使用存量数据创建索引&lt;/p&gt;
&lt;p&gt;该过程和普通的创建索引相似，但是进行 &lt;code&gt;heap&lt;/code&gt; 扫描时，使用的快照不同。在一般的索引创建中，使用的是 &lt;code&gt;SnapshotAny&lt;/code&gt; ，所有行都可见，而 CIC 中使用的是当前事务的快照。&lt;/p&gt;
&lt;p&gt;问题仍然出现在 HOT 链上，虽然对于创建索引的字段，当前不会产生新的 HOT 链，但是仍然会有旧的 HOT 链 ，所以构建索引的方式和普通地创建索引相同。&lt;/p&gt;
&lt;p&gt;举个例子:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始状态有 tuple_1 和 tuple_2 ，以及字段 a 上的索引。现对字段 b 创建建索引，&lt;/li&gt;
&lt;li&gt;tuple_1 对当前快照不可见（too old）&lt;/li&gt;
&lt;li&gt;tuple_2 可见。当把 tuple_2 加入到索引中时，索引值为 b=2，但索引入口指向 b=1 的元组（HOT链的开头），&lt;/li&gt;
&lt;li&gt;在阶段2中，有其他事务将 tuple_2 进行成了 tuple_3 ，将 c 改为了 2。该更新满足 HOT （a, b 都没有变），所以仍在 HOT 链上。但是 tuple_3 对当前快照（CIC）不可见 (in feature)，所以不处理。&lt;/li&gt;
&lt;li&gt;在阶段2中，有其他事务将 tuple_3 进行成了 tuple_4，将 b 改为了3。该更新不满足 HOT，所以索引 idx_a 需要创建新的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;./phase2_hot.png&#34; alt=&#34;image-20240912165540880&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;当索引构建完毕后，将 pg_index 的中对应行的 &lt;code&gt;indisready&lt;/code&gt; 设置为 true，这样其他事务后续修改表时，会同步修改该索引。和阶段1相似，当前事务提交后，开启新的事物（xact3），等到其他事务都感知到 &lt;code&gt;indisready=true&lt;/code&gt; 时（同样使用 WaitForLockers 方案），开始阶段三。&lt;/p&gt;
&lt;h2&gt;阶段三： 增量数据的插入&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;阶段三-增量数据的插入&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e9%98%b6%e6%ae%b5%e4%b8%89-%e5%a2%9e%e9%87%8f%e6%95%b0%e6%8d%ae%e7%9a%84%e6%8f%92%e5%85%a5&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;该步骤的主要工作为把阶段二中遗漏的 tuple 加入索引中。方法为：使用当前的事务快照，将该快照可见的但是索引中没有的元组，加入索引中，具体做法为：&lt;/p&gt;
&lt;p&gt;（一）扫描索引，获取索引中所有的 ctid，并进行排序，得到 &lt;code&gt;Tuplesortstate&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（二）使用当前快照，进行全表扫描，对于每一行，在 &lt;code&gt;Tuplesortstate&lt;/code&gt; 搜索对应的 ctid。注意，如果是 heap only tuple，则使用其根 tuple 的 ctid。如果在 &lt;code&gt;Tuplesortstate&lt;/code&gt; 中没有找打，则向索引中插入对应的指针。&lt;/p&gt;
&lt;p&gt;举个例子： tuple_3 虽然是在阶段二中新增的 tuple ，但是其根 tuple，即 tuple_1 已经在索引中了，所以在阶段三中忽略。而 tuple_3 不在 HOT 链中，所以需要插入到元组中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./phase3_hot.png&#34; alt=&#34;image-20240912181510448&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;增量数据插入结束后，仍不能设置 &lt;code&gt;indisvalid=true&lt;/code&gt; ：考虑一个元组，它在阶段二中被创建，却在阶段三前被删除，所以此时它仍然不在索引中，但是可能有其他事务（事务 T）可以看到该元组；如果此时修改 &lt;code&gt;indisvalid=true&lt;/code&gt; 并提交，那么事务 T 使用该索引时，就无法获取到该元组 。故此时需要等事务 T 结束。：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./phase3_wait.png&#34; alt=&#34;image-20240912182449902&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;所以流程为将增量数据插入元组后，获取当前快照的 xmin，记为 xminlimit，并提交。之后开启新的事物，等待所有含有 &lt;code&gt;snap.xmin&amp;lt;xminlimit&lt;/code&gt; 的快照的事务全部提交，再设置 &lt;code&gt;indisvalid=true&lt;/code&gt; 并提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;./phase3_wait_2.png&#34; alt=&#34;image-20240912184735020&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;提交后，所以事务（包括正在运行的）都可以使用新索引了。&lt;/p&gt;
&lt;h2&gt;FAQ&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;faq&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#faq&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;1 为什么需要保证阶段二中：其他连接的修改不会破坏 HOT&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;1-为什么需要保证阶段二中其他连接的修改不会破坏-hot&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#1-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e4%bf%9d%e8%af%81%e9%98%b6%e6%ae%b5%e4%ba%8c%e4%b8%ad%e5%85%b6%e4%bb%96%e8%bf%9e%e6%8e%a5%e7%9a%84%e4%bf%ae%e6%94%b9%e4%b8%8d%e4%bc%9a%e7%a0%b4%e5%9d%8f-hot&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h2&gt;draft&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;draft&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#draft&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;h3&gt;Official document&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;official-document&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#official-document&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;a href=&#34;https://www.postgresql.org/docs/current/sql-createindex.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.postgresql.org/docs/current/sql-createindex.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Creating an index can interfere with regular operation of a database. Normally PostgreSQL locks the table to be indexed against writes and performs the entire index build with a single scan of the table. Other transactions can still read the table, but if they try to insert, update, or delete rows in the table they will block until the index build is finished. This could have a severe effect if the system is a live production database. Very large tables can take many hours to be indexed, and even for smaller tables, an index build can lock out writers for periods that are unacceptably long for a production system.&lt;/p&gt;
&lt;p&gt;PostgreSQL supports building indexes without locking out writes. This method is invoked by specifying the &lt;code&gt;CONCURRENTLY&lt;/code&gt; option of &lt;code&gt;CREATE INDEX&lt;/code&gt;. When this option is used, PostgreSQL must perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.&lt;/p&gt;
&lt;p&gt;In a concurrent index build, &lt;strong&gt;the index is actually entered as an “invalid” index into the system catalogs in one transaction, then two table scans occur in two more transactions&lt;/strong&gt;. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. &lt;strong&gt;After the second scan, the index build must wait for any transactions that have a snapshot (see &lt;a href=&#34;https://www.postgresql.org/docs/current/mvcc.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chapter 13&lt;/a&gt;) predating the second scan to terminate&lt;/strong&gt;, including transactions used by any phase of concurrent index builds on other tables, if the indexes involved are partial or have columns that are not simple column references. Then finally the index can be marked “valid” and ready for use, and the &lt;code&gt;CREATE INDEX&lt;/code&gt; command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.&lt;/p&gt;
&lt;p&gt;If a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the &lt;code&gt;CREATE INDEX&lt;/code&gt; command will fail but leave behind an “invalid” index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql &lt;code&gt;\\d&lt;/code&gt; command will report such an index as &lt;code&gt;INVALID&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Others’ blog&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;others-blog&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#others-blog&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.notion.so/PostgreSQL-create-index-concurrently-4ebd2ea38bb24324bc0e165e017daea1?pvs=21&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PostgreSQL create index concurrently原理分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://postgrespro.com/blog/pgsql/3994098&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://postgrespro.com/blog/pgsql/3994098&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://postgrespro.com/blog/pgsql/4161264&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://postgrespro.com/blog/pgsql/4161264&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;核心问题&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;核心问题&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;两次快照读的原因&lt;/li&gt;
&lt;li&gt;怎么“正好只”补充两次快照之间的增量数据？&lt;/li&gt;
&lt;li&gt;merge 是怎么实现的？&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * validate_index - support code for concurrent index builds
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * We do a concurrent index build by first inserting the catalog entry for the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * index via index_create(), marking it not indisready and not indisvalid.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Then we commit our transaction and start a new one, then we wait for all
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * transactions that could have been modifying the table to terminate.  Now
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * we know that any subsequently-started transactions will see the index and
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * honor its constraints on HOT updates; so while existing HOT-chains might
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * be broken with respect to the index, no currently live tuple will have an
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * incompatible HOT update done to it.  We now build the index normally via
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * index_build(), while holding a weak lock that allows concurrent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * insert/update/delete.  Also, we index only tuples that are valid
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * as of the start of the scan (see table_index_build_scan), whereas a normal
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * build takes care to include recently-dead tuples.  This is OK because
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * we won&amp;#39;t mark the index valid until all transactions that might be able
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * to see those tuples are gone.  The reason for doing that is to avoid
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * bogus unique-index failures due to concurrent UPDATEs (we might see
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * different versions of the same row as being valid when we pass over them,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * if we used HeapTupleSatisfiesVacuum).  This leaves us with an index that
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * does not contain any tuples added to the table while we built the index.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Next, we mark the index &amp;#34;indisready&amp;#34; (but still not &amp;#34;indisvalid&amp;#34;) and
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * commit the second transaction and start a third.  Again we wait for all
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * transactions that could have been modifying the table to terminate.  Now
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * we know that any subsequently-started transactions will see the index and
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * insert their new tuples into it.  We then take a new reference snapshot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * which is passed to validate_index().  Any tuples that are valid according
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * to this snap, but are not in the index, must be added to the index.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * (Any tuples committed live after the snap will be inserted into the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * index by their originating transaction.  Any tuples committed dead before
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * the snap need not be indexed, because we will wait out all transactions
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * that might care about them before we mark the index valid.)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * validate_index() works by first gathering all the TIDs currently in the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * index, using a bulkdelete callback that just stores the TIDs and doesn&amp;#39;t
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * ever say &amp;#34;delete it&amp;#34;.  (This should be faster than a plain indexscan;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * also, not all index AMs support full-index indexscan.)  Then we sort the
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * TIDs, and finally scan the table doing a &amp;#34;merge join&amp;#34; against the TID list
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * to see which tuples are missing from the index.  Thus we will ensure that
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * all tuples valid according to the reference snapshot are in the index.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Building a unique index this way is tricky: we might try to insert a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * tuple that is already dead or is in process of being deleted, and we
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * mustn&amp;#39;t have a uniqueness failure against an updated version of the same
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * row.  We could try to check the tuple to see if it&amp;#39;s already dead and tell
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * index_insert() not to do the uniqueness check, but that still leaves us
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * with a race condition against an in-progress update.  To handle that,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * we expect the index AM to recheck liveness of the to-be-inserted tuple
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * before it declares a uniqueness error.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * After completing validate_index(), we wait until all transactions that
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * were alive at the time of the reference snapshot are gone; this is
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * necessary to be sure there are none left with a transaction snapshot
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * older than the reference (and hence possibly able to see tuples we did
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * not index).  Then we mark the index &amp;#34;indisvalid&amp;#34; and commit.  Subsequent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * transactions will be able to use it for queries.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Doing two full table scans is a brute-force strategy.  We could try to be
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * cleverer, eg storing new tuples in a special area of the table (perhaps
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * making the table append-only by setting use_fsm).  However that would
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * add yet more locking issues.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;

      </description>
    </item>
    
  </channel>
</rss>
