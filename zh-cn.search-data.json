{"/computer_science/":{"data":{"":"这里记录一些暂时不归类的计算机科学知识"},"title":"Computer_science"},"/computer_science/cublasdgemmtutor/":{"data":{"":"","basic-use#basic use":"Definition of this function\ncublasStatus_t cublasDgemm(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb, int m, int n, int k, const double *alpha, const double *A, int lda, const double *B, int ldb, const double *beta, double *C, int ldc) Basic information of parameters is show in this page. Simply put, $C = \\alpha A \\times B + \\beta C $ .But it may remains confused for fresher. Below is an simple example.\n/* A is matrix in gpu memory looks like * 1 2 3 * 4 5 6 * 7 8 9 * and ptr_A is a pointer to A * * B is matrix in gpu memory looks like * 1 2 * 3 4 * 5 6 * and ptr_A is a pointer to A * * While memory is one-dimensional while matrix is two-dimensional, I * suggeset that all matrix in gpu memory are stored in column major for * convevient use of cublas. In this case, A in memory is like * [1, 4, 7, 2, 5, 8, 3, 6, 9]. * C is a matrix to store the product of A * B */ //get handle and stat of this function cublasHandle_t handle; cublasStatus_t stat = cublasCreate(\u0026handle); if (stat != CUBLAS_STATUS_SUCCESS) { printf(\"CUBLAS initialization failed\\n\"); return EXIT_FAILURE; } //setting alpha and cuda double alpha = 1.0, beta = 0.0; stat = cublasDgemm(\thandle, CUBLAS_OP_N,\t// we use matrix A instead of A^T CUBLAS_OP_N,\t// we use matrix B instead of B^T 3,\t// the row of A 2,\t// the col of B 3,\t// the row of B(ro col of A) \u0026alpha, devPtrA, 3,\t// the leading dimension of A devPtrB, 3,\t// the leading dimension of B \u0026beta, devPtrC, 3);\t// the leading dimension of C /* * if we want to compute C = A^T * B */ stat = cublasDgemm(\thandle, CUBLAS_OP_T,\t// we use matrix A^T instead of A CUBLAS_OP_N,\t// we use matrix A instead of B^T 3,\t// the row of A^T 2,\t// the col of B 3,\t// the row of B(or col of A^T) \u0026alpha, devPtrA, 3,\t// the leading dimension of A^T. // So whether or not A or A^T, the leading dimension // of A or A^T is the row of A, decided when A is // initialized in memory devPtrB, 3,\t// the leading dimension of B \u0026beta, devPtrC, 3);\t// the leading dimension of C if (stat != CUBLAS_STATUS_SUCCESS) { printf(\"cublasSgemm failed\\n\"); return EXIT_FAILURE; } An obvious question is what is leading dimension for we have know the column and row of A and B, no more information is need to finish this computation.\nMy understanding of leading dimension is the offest to get the element in next column at the same row. An implement to compute the product of submatrix. below is an example. A and B are the same matrix in the previous example.\nAnd what we want to compute is $A[0:1][0:1] \\times B[1:2][0:1]$.\nstat = cublasDgemm(\thandle, CUBLAS_OP_N,\t// we use matrix A[0:1][0:1] instead of A[0:1][0:1]^T CUBLAS_OP_N,\t// we use matrix B[1:2][0:1] instead of B[1:2][0:1]^T 2,\t// the row of A[0:1][0:1] 2,\t// the col of B[1:2][0:1] 2,\t// the row of A[0:1][0:1](or col of B[1:2][0:1]) \u0026alpha, devPtrA,\t// pointer to A[0][0] 3,\t// the offset of A[0][0] to A[0][1] is 3 of double size devPtrB + 1,\t// pointer to B[1][0] 3,\t// the offset of B[1][0] to B[1][1] is 3 of double size \u0026beta, devPtrC, 2);\t// the leading dimension of C So it’s the use of leading dimension which makes matrix production more flexible","concept#concept":"concept cublasDgemm is a convenient function in cublas to compute the product of two matrix, while letter ‘D’ in cublasDgemm means double.\nBefore reading this post, basic cuda functions like cudaMalloc are what you are supposed to know."},"title":"cublasDgemm"},"/computer_science/database-log/":{"data":{"":"","primitive-operation-if-transactions#Primitive Operation if Transactions":"There are three address spaces that transaction interact in important ways:\nThe space of disk blocks holding the database elements. The memory address space managed by buffer manager. The local address space of the transaction. To describe a transaction, we need some operation notions:(X below is a database element while t is a local varible, and we suppose a database element is no larger than a single block)\nINPUT(X): copy disk block containing X to memroy buffer READ(X, t): Copy X to transaction’s local varible t no matter where X is, which means INPUT(X) may be executed first before READ(X,t). WRITE(X, t): Copy the value of t to X no matter where X is. OUTPUT(X): Copy the block containing X from its buffer to disk ","undo-logging#undo logging":"Undo log makes repairs to the database state by undoing the effects of transactions that may not completed before the crash.\nAn Undo log has the form [T,X,v] which means transaction T has changed the database elememnt X, and its before value was v. The log record is a response to a WRITE action into memory, not an OUTPUT action.\nAn undo log is suffcient to allow recovery from system failure, provided transactions and buffer manager obey two rules:\nIf transaction T modifies database element X, then the log record of form \u003cT,X,v\u003e must be written to disk before the new value of X is written to disk If a transaction commits, the its commit log record must be written to disk only after all database elements changed by the transaction have been written to disk, but as soon there after is possible If a transaction aborts, recovery manager is need to repair the values. When recovering, the recovery manager scan the log from the end. As it travels, it remembers all thos transactions T for which it has seen a [COMMIT T] record or [ABORT T] record, the:\nIf T’s COMMIT record is found, do nothing. Otherwise, T is an incomplete transaction, or aborted transaction. The recovery manager must change the value of X in the database to v,in case X had been altered just before the crash. After this, the recovery manager must write a log record [ABORT T] for each incomplete transaction T that was not previously aborted, and then flush the log "},"title":"Basic Knowledge of Database Log"},"/computer_science/fwrapv/":{"data":{"":"c - What does -fwrapv do? - Stack Overflow\n-fwrapv tells the compiler that overflow of signed integer arithmetic must be treated as well-defined behavior, even though it is undefined in the C standard.\nIt has two meaning full results:\nINT_MAX + 1 is overflowed to INT_MIN correctly. This is almost the default behavior in gcc. Don’t let the compiler assume x + 1 \u003e x. See the program below\n╭─ycz at 9f38a58b120d in /home/dev 24-08-05 - 13:28:02 ╰─○ cat test.c #include \u003cstdio.h\u003e #define INT_MAX 0x7FFFFFFF static int compare(int x) {return x + 1 \u003e x;} int main() { int x = 0; printf(\"%d is bigger than %d?\\n%d\\n\", x + 1, x, compare(x)); x = INT_MAX; printf(\"%d is bigger than %d?\\n%d\\n\", x + 1, x, compare(x)); return 0; } ╭─ycz at 9f38a58b120d in /home/dev 24-08-05 - 13:28:06 ╰─○ gcc test.c \u0026\u0026 ./a.out 1 is bigger than 0? 1 -2147483648 is bigger than 2147483647? 1 ╭─ycz at 9f38a58b120d in /home/dev 24-08-05 - 13:28:13 ╰─○ gcc test.c -fwrapv \u0026\u0026 ./a.out 1 is bigger than 0? 1 -2147483648 is bigger than 2147483647? 0 "},"title":"\"-fwrapv\" option in gcc"},"/computer_science/google-f1/":{"data":{"":"","abstract#Abstract":" a protocol for schema evolution in a globally distributed database management system with shared data, stateless servers, and no global membership. asynchronous all servers can access and update all data during a schema change ","background#BackGround":"In this section, we:\nseparate the interface provided by the key–value store from its implementation show how we map traditional relational database features into this unique setting Key-value store F1 assumes the key–value store supports three operations put: insert a value with a given key del: delete a value with a given key get: returns any stored values whose key matches a given prefix Note that put and del reference exactly one key–value pair, while get may return multiple key–value pairs\nTwo more requirements Commit timestamps: Every key–value pair has a last-modified timestamp which is updated atomically by the key–value store Atomic test-and-set support: Multiple get and put operations can be executed atomically Relational schema An F1 schema is a set of table definitions that enable F1 to interpret the database located in the key–value store Each table definition has: a list of columns a list of secondary indexes a list of integrity constraints(foreign key or index uniqueness constraints) a list of optimistic locks. required columns that cannot be read directly by client transactions A subset of columns in a table forms the primary key of the table We call a column required if its value must be present in every row. All primary-key columns are implicitly required, while non-key columns may be either required or optional Row representation one pair for each non-primary-key column\nEach key logically includes\nthe name of the table, the primary key values of the containing row, the name of the column whose value is stored in the pair Although this appears to needlessly repeat all primary key values in the key for each column value, in practice, F1’s physical storage format eliminates this redundancy\nA secondary index covers a non-empty subset of columns on a table is itself represented by a set of key–value pairs in the key– value store Each row in the indexed table has an associated index key–value pair The key for this pair is formed by concatenating the table name the index name the row’s indexed column values and the row’s primary key values We denote the index key for row $r$ in index $I$ as $k_r(I)$ the special exists column doesn’t have the associated value Relational operations F1 supports a set of standard relational operations:\n$insert(R,vk_r,vc_r)$ inserts row r to table R with primary key values $vk_r$ and non-key column values $vc_r$. Insert fails if a row with the same primary key values already exists in table R. $delete (R, vk_r )$ $update(R,vk_r,vc_r)$ $query(\\vec{R},\\vec{C},P)$ :returns a projection $\\vec{C}$ of rows from tables in $\\vec{R}$ that satisfy predicate $P$ . ","introduction#INTRODUCTION":" Schema evolution: the ability to change a database’s definition without the loss of data F1 is built on top of Spanner, a globally distributed KV data store Main feature The main features of F1 that impact schema changes are:\nMassively distributed: An instance of F1 consists of hundreds of individual F1 servers Relational schema: Each F1 server has a copy of a relational schema that describes tables, columns, indexes, and constraints. Any modification to the schema requires a distributed schema change to update all servers Shared data storage: All F1 servers in all datacenters have access to all data stored in Spanner. Stateless servers: F1 servers must tolerate machine failures, preemption(取代), and loss of access to network resources clients may connect to any F1 server, even for different statements in the same transaction. No global membership: no reliable mechanism for determining currently running F1 servers, and explicit global synchronization is not possible several constraints on the schema change process:\nFull data availability: the availability of the data managed by F1 is paramount(至为重要的) it is unacceptable to take even a portion of the database offline during a schema change (e.g., locking a column to build an index). Minimal performance impact: the F1 schema changes rapidly to support new features Asynchronous schema change In other words, different F1 servers may transition to using a new schema at different times These requirements influenced the design in several ways\nSince all data must be as available as possible, we do not restrict access to data undergoing reorganization. Because the schema change must have minimal impact on user transactions, we allow transactions to span an arbitrary number of schema changes, although we do not automatically rewrite queries to conform to the schema in use Applying schema changes asynchronously on individual F1 servers means that multiple versions of the schema may be in use simultaneously An example Consider a schema change from schema S1 to schema S2 that adds index I on table R Assume two different servers, M1 and M2, execute the following sequence of operations: Server M2, using schema S2, inserts a new row r to table R. Because S2 contains index I, server M2 also adds a new index entry corresponding to r to the key– value store. Server M1, using schema S1, deletes r. Because S1 does not contain I, M1 removes r from the key–value store but fails to remove the corresponding index entry in I. The second delete leaves the database corrupt. We consider not only changes to the logical schema, such as the addition or removal of columns, but also changes to the physical schema like adding or removing secondary indexes.\nBy ensuring that:\nno more than two schema versions are in use at any given time those schema versions have specific properties? enables distributed schema changes in a way that\ndoes not require global membership, implicit or explicit synchronization between nodes, or the need to retain old schema versions once a schema change is complete"},"title":"Read Google F1"},"/computer_science/howtoknowwhoseisbigger/":{"data":{"":"","definiteness#Definiteness：":"Suppose Alice has number $i$ and Bob has number $j$ and $1\\leq i,j \\leq 9$. We need a protocol for them to decide whether $i \u003c j$ in the end(aside from their own values)","solution#Solution:":"Let $M$ be the set of all $N$-bit nonnegative integers\nLet $Q_N$ be the set of all one-one and onto function from $M$ to $M$\nAlice generates a public key from $Q_N$, called $E_a$, and the inverse function of $E_a$ is $D_a$ Bob picks a random value $x \\in M$, compute $k = E_a(x)$, then send $k - j$ to Alice Alice computes $y_u=D_a(k - j + u)$ for $u = 1,2,\\dots,9$ Alice generates a random prime $p$ of $N/2$-bit, and computes $z_u=y_u(\\mod p)$ for all $u$. Alice repeats step 4 until all $z_u$ differ by at least 2 in the $\\mod p$ sense Alice sends the $p$ and $z_1,z_2,\\dots,z_i,z_{i+1}+1,\\dots,z_{9} +1$ (all in $\\mod p$ sense)to Bob Bob looks at the $j$-th value(not counting p) sent from Alice, and decides that $i\\geq j$ if it is equal to $x \\mod p$, or $i\u003cj$ otherwise "},"title":"Alice and Bob how to know whose number is bigger without giving away their own's"},"/computer_science/linux-file/":{"data":{"":"","atomic-operations#Atomic Operations":"","close-function#\u003ccode\u003eclose\u003c/code\u003e function":"","creat-function#\u003ccode\u003ecreat\u003c/code\u003e function":"","devfd#\u003ccode\u003e/dev/fd\u003c/code\u003e":"The functions described in this chapter are often referred to as unbuffered I/O(which each read or write invokes a system call in the kernel), in contrast to the standard I/O routines\nFile Descriptors To the kernel, all open files are referred to by file descriptors. A file descriptor is a non-negative integer. When we open an existing file or create a new file, the kernel returns a file descriptor to the process. When we want to read or write a file, we identify the file with the file descriptor that was returned by open or creat as an argument to either read or write. By convention, UNIX System shells associate file descriptor 0 with the standard input of a process, file descriptor 1 with the standard output, and file descriptor 2 with the standard error File descriptors range from 0 through OPEN_MAX−1 open and openat code #include \u003cfcntl.h\u003e int open(const char *path, int oflag, ... /* mode_t mode */ ); int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ ); //Both return: file descriptor if OK, −1 on error This function has a multitude of options, which are specified by the oflag argument. This argument is formed by ORing together one or more of the following constants from the\u003cfcntl.h\u003e header\nO_SYNC Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. O_DSYNC Have each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written. The O_DSYNC flag affects a file’s attributes only when they need to be updated to reflect a change in the file’s data (for example, update the file’s size to reflect more data)\nO_RSYNC Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete\nThe fd parameter distinguishes the openat function from the open function. There are three possibilities\nThe path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function. The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated. The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function. openat solved two problems\nIt gives threads a way to use relative pathnames to open files in directories other than the current working directory while all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time it provides a way to avoid time-of-check-to-time-of-use (TOCTTOU) errors whose baisc idea is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. creat function #include \u003cfcntl.h\u003e int creat(const char *path, mode_t mode); This is equivalent to\nopen(path, O_WRONLY | O_CREAT | O_TRUNC, mode); close function #include \u003cunistd.h\u003e int close(int fd); When a process terminates, all of its open files are closed automatically by the kernel\nlseek function Every open file has an associated ‘’current file offset,’’ normally a non-negative integer that measures the number of bytes from the beginning of the file.Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written An open file’s offset can be set explicitly by calling lseek #include \u003cunistd.h\u003e off_t lseek(int fd, off_t offset, int whence); If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of the file If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. The offset can be positive or negative If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. The offset can be positive or negative Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset off_t currpos; currpos = lseek(fd, 0, SEEK_CUR); This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE and returns −1 Normally,a file’s current offset must be a non-negative integer . Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0. The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0. A hole in a file isn’t required to have storage backing it on disk read function #include \u003cunistd.h\u003e ssize_t read(int fd, void *buf, size_t nbytes); If the read is successful, the number of bytes read is returned. If the end of file is encountered, 0 is returned. There are several cases in which the number of bytes actually read is less than the amount requested:\nWhen reading from a regular file, if the end of file is reached before the requested number of bytes has been read. When reading from a terminal device. When reading from a network When reading from a pipe or FIFO. When reading from a record-oriented device When interrupted by a signal and a partial amount of data has already been read. classic definition int read(int fd, char *buf, unsigned nbytes); difference\nvoid * to char * 0 for end-of-file and -1 for an error write function #include \u003cunistd.h\u003e ssize_t write(int fd, const void *buf, size_t nbytes) The return value is usually equal to the nbytes argument; otherwise, an error has occurred. A common cause for a write error is either filling up a disk or exceeding the file size limit for a given process\nI/O efficiency an example\n#include \"apue.h\" #define BUFFSIZE 4096 int main(void) { int n; char buf[BUFFSIZE]; while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) \u003e 0) if (write(STDOUT_FILENO, buf, n) != n) err_sys(\"write error\"); if (n \u003c 0) err_sys(\"read error\"); exit(0); } some caveats\nIt reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed The program doesn’t close the input file or output file. This example works for both text files and binary file how we chose the BUFFSIZE value?\nfile sharing The UNIX System supports the sharing of open files among different processes.\nThe kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing\nEvery process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are The file descriptor flags A pointer to a file table entry The kernel maintains a file table for all open files. Each file table entry contains The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14 The current file offset A pointer to the v-node table entry for the file Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on If two independent processes have the same file open, we could have the arrangement\nEach process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file.\nAfter each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended). If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry (Note that this is not the same as if the file was opened with the O_APPEND flag) The lseek function modifies only the current file offset in the file table entry. No I/O takes place It is possible for more than one file descriptor entry to point to the same file table entry. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor\nNote the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry\nAtomic Operations Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls\n#include \u003cunistd.h\u003e ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset); //Returns: number of bytes read, 0 if end of file, −1 on error ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); //Returns: number of bytes written if OK, −1 on error If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure).\ndup and dup2 Functions An existing file descriptor is duplicated by either of the following functions\n#include \u003cunistd.h\u003e int dup(int fd); int dup2(int fd, int fd2); //Both return: new file descriptor if OK, −1 on error With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec\nsync,fsync , and fdatasync function Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write\nTo ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided.\n#include \u003cunistd.h\u003e int fsync(int fd); int fdatasync(int fd); //Returns: 0 if OK, −1 on error void sync(void); The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place.The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update.\nThe function fsync refers only to a single file, specified by the file descriptor fd, and waits for the disk writes to complete before returning.(database)\nThe fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously\nfcntl function #include \u003cfcntl.h\u003e int fcntl(int fd, int cmd, ... /* int arg */ ); //Returns: depends on cmd if OK (see following), −1 on error The fcntl function is used for five different purposes\nDuplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC) Get/set file descriptor flags (cmd = F_GETFD or F_SETFD) Get/set file status flags (cmd = F_GETFL or F_SETFL) Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN) Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW) ioctl function The ioctl function has always been the catchall for I/O operations. Terminal I/O was the biggest user of this function\n#include \u003cunistd.h\u003e /* System V */ #include \u003csys/ioctl.h\u003e /* BSD and Linux */ int ioctl(int fd, int request, ...); //Returns: −1 on error, something else if OK Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the header.\nEach device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices\n/dev/fd Newer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on\nIn the function call\nfd = open(\"/dev/fd/0\", mode); most systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to\nfd = dup(0); the descriptors 0 and fd share the same file table entry\nFor example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call succeeds, we still can’t write to fd.\nThe main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames, like cat - to cat /dev/fd/0\nThe special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness.","dup-and-dup2-functions#dup and dup2 Functions":"","fcntl-function#\u003ccode\u003efcntl\u003c/code\u003e function":"","file-descriptors#File Descriptors":"","file-sharing#file sharing":"","io-efficiency#I/O efficiency":"","ioctl-function#\u003ccode\u003eioctl\u003c/code\u003e function":"","lseek-function#\u003ccode\u003elseek\u003c/code\u003e function":"","open-and-openat#\u003ccode\u003eopen\u003c/code\u003e and \u003ccode\u003eopenat\u003c/code\u003e":"","read-function#\u003ccode\u003eread\u003c/code\u003e function":"","syncfsync--and-fdatasync-function#\u003ccode\u003esync\u003c/code\u003e,\u003ccode\u003efsync\u003c/code\u003e , and \u003ccode\u003efdatasync\u003c/code\u003e function":"","write-function#\u003ccode\u003ewrite\u003c/code\u003e function":""},"title":"APUE/Chapter3: file and I/O"},"/computer_science/reversed_inode/":{"data":{"":"","0x0-what-is-inode#0x0 what is inode":"","0x1-how-many-inodes-are-there#0x1 \u003cstrong\u003eHow many inodes are there?\u003c/strong\u003e":"0x0 what is inode From https://en.wikipedia.org/wiki/Inode\nThe inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory. Each inode stores the attributes and disk block locations of the object’s data\nFrom https://www.redhat.com/sysadmin/inodes-linux-filesystem\nBy definition, an inode is an index node. It serves as a unique identifier for a specific piece of metadata on a given filesystem. Each piece of metadata describes what we think of as a file. That’s right, inodes operate on each filesystem, independent of the others.\nOnce you create a file, directory and so on, an inode is consumed. So it’s important to remain enough inodes.\n0x1 How many inodes are there? The inode upper limit is determined once the filesystem is initialized.\nFor ext4, there are two method to appoint the number\nbytes-per-inode : This is the default method to determine the number of inodes. This option approves an method to help estimate the inodes you may need through the average file size. mke2fs creates an inode for every bytes-per-inode bytes of space on the disk. The larger the bytes-per-inode ratio, the fewer inodes will be created. The default value is 16k. If you create too many 8k files, the inode will run out before the disk space. So the disk space is wasted If you create too many 32k files, the disk space will run out before the inode. So the inode is wasted number-of-inodes : Overrides the default calculation of the number of inodes that should be reserved for the filesystem. See https://wiki.archlinux.org/title/Ext4 for detail"},"title":"Number of Reversed Inode"},"/computer_science/zero2rsa/":{"data":{"":"","rsa算法#RSA算法":"算法流程 生成秘钥 选择连个大质数 $p$ 和 $q$ ，计算 $n=p * q$ 计算 $\\phi(n)=(p-1)(q-1)$ 选择正整数 $e$ 满足 $1 \u003c e \u003c \\phi(n)$ ，且 $\\mathrm{gcd}(e,\\phi(n))=1$ 计算 $e$ 对 $\\phi(n)$ 的模逆元 $d$ ，即 $ed\\ \\equiv 1\\ (\\mathrm{mod}\\ \\phi(n))$ 得到公钥对 $(n,e)$ ，私钥对 $(n, d)$ 加密 加密的数为 $m$ ，满足 $0\\leq m \u003c n$ 计算 $c=m^e\\ \\mathrm{mod}\\ n$ ，则 $c$ 就是密文 解密 $m=c^d\\ \\mathrm{mod}\\ n$ 算法证明 显然，核心点在于证明 $m=c^d\\ \\mathrm{mod}\\ n$​ 。\n简答化简可得， $c^d\\ \\mathrm{mod}\\ n=(m^e\\ \\mathrm{mod}\\ n)^d\\ \\mathrm{mod}\\ n=m^{ed}\\ \\mathrm{mod}\\ n$​\n根据 $ed\\ \\equiv 1\\ (\\mathrm{mod}\\ \\phi(n))$ ，可知存在 $k$ 使得 $ed=k\\phi(n)+1$ ，带入 $m^{ed}\\ \\mathrm{mod}\\ n$ 得，\n$$ \\begin{align} m^{ed}\\ \\mathrm{mod}\\ n\u0026= m^{k\\phi(n)+1}\\ \\mathrm{mod}\\ n \\newline \u0026= ((m^{\\phi(n)} \\mathrm{mod}\\ n)^k*(m\\ \\mathrm{mod}\\ n))\\ \\mathrm{mod}\\ n \\newline \u0026= (m(m^{\\phi(n)} \\mathrm{mod}\\ n)^k) \\ \\mathrm{mod}\\ n \\end{align} $$\n通常情况 当 $\\mathrm{gcd}(m,n)=1$ 时（即 $m\\neq hp$ 且 $m\\neq hq$ 时），根据欧拉定理 $m^{\\phi(n)}\\ \\equiv 1\\ (\\mathrm{mod}\\ n)$ ，可知 $m^{\\phi(n)} \\mathrm{mod}\\ n=1$​\n则 $m^{ed}\\ \\mathrm{mod}\\ n = m\\ \\mathrm{mod}\\ n=m$\n特殊情况 当 $m=hp$ 时，（ $m=hq$ 同理）有 $m^{\\phi(n)} \\mathrm{mod}\\ n = (hp)^{(p-1)(q-1)}\\mathrm{mod}\\ pq$\n而因为 $q$ 是质数，根据费马小定理，有 $((hp)^{k(p-1)})^{q-1}\\ \\equiv 1\\ (\\mathrm{mod}\\ q)$ 。故\n$$ \\begin{align} ((hp)^{k(p-1)})^{q-1}hp\\ \u0026\\equiv hp\\ (\\mathrm{mod}\\ q) \\newline (hp)^{k(p-1)(q-1)+1}\\ \u0026\\equiv hp\\ (\\mathrm{mod}\\ q) \\newline (hp)^{(cd)}\\ \u0026\\equiv hp\\ (\\mathrm{mod}\\ q) \\end{align} $$\n故存在 $t$ 满足\n$$ (hp)^{ed}=tq+hp $$\n注意，等式左侧是 $p$ 的倍数，而 $p$ 是质数，故 $t$ 必定是 $p$ 的倍数，设 $t=t’p$ ，则\n$$ \\begin{align} (hp)^{ed}\u0026=t’pq+hp=t’n+hp \\newline m^{ed}\\ \u0026\\equiv m\\ (\\mathrm{mod}\\ n) \\newline m^{ed-1} \\ \u0026\\equiv 1\\ (\\mathrm{mod}\\ n) \\newline m^{k\\phi(n)} \\ \u0026\\equiv 1\\ (\\mathrm{mod}\\ n) \\end{align} $$\n同理 $m^{ed}\\ \\mathrm{mod}\\ n = (m(m^{\\phi(n)} \\mathrm{mod}\\ n)^k) \\ \\mathrm{mod}\\ n = m\\ \\mathrm{mod}\\ n=m$","中国剩余定理#中国剩余定理":"方程组\n$$ \\begin{equation} \\begin{cases} x\\ \\equiv a_1\\ (\\mathrm{mod}\\ m_1)\\newline x\\ \\equiv a_2\\ (\\mathrm{mod}\\ m_2)\\newline …\\newline x\\ \\equiv a_n\\ (\\mathrm{mod}\\ m_n)\\newline \\end{cases} \\end{equation} $$\n其中对于任意 $i\\neq j$ 有 $\\mathrm{gcd}(m_i,m_j)=1$ ，对于任意 $a_1,a_2,…,a_n$ 有解。\n证明：如下\n存在性\n令 $M=m_1m_2,…m_n=\\prod\\limits_{i=1}^{n}m_i$， $M_i=M/m_i$ 显然有 $\\mathrm{gcd}(M_i,m_i)=1$ ，故存在 $t_i$ 满足 $M_it_i\\ \\equiv 1\\ (\\mathrm{mod}\\ m_i)$ 故对于 $x\\ \\equiv a_1\\ (\\mathrm{mod}\\ m_1)$ ，有 $a_iM_it_i\\ \\equiv a_i\\ (\\mathrm{mod}\\ m_i)$ 故可得 $x$ 的一个解 $x=\\sum\\limits_{i=1}^{n}a_iM_it_i$ 完备性\n若 $x_1,x_2$ 都是方程组的解，那么对于任意 $i\\in \\lbrace 1,2,…,n \\rbrace$ ，有 $(x_1-x_2)\\ \\mathrm{mod}\\ m_i=0$ 故 $x_1-x_2=kM$ 所以通解为 ${kM+}\\sum\\limits_{i=1}^{n}a_iM_it_i$ ","从0证明rsa#从0证明RSA":"RSA 算法（即一个非对称加密算法）除了应用非常广泛外，其特性也非常吸引人（起码非常吸引我）。我在网上找了很多关于RSA的证明，要么不够详细（例如缺失对前置定理的证明），要么需要引出较多复杂的数论概念。作者本身水平不高，试图绕过这些复杂的概念，从初等数学的开始，完备地证明RSA。\n关于RSA的背景知识可能很多，可以慢慢阅读，我在此尝试从初等数学开始证明。这些背景知识的证明有一定的顺序，如果读者发现某个证明看不懂，可以向前翻阅。\n参考的文章如下：（因为参考的文章太多，大概率不全）\n费马小定理 中国剩余定理 阮一峰的博客——RSA算法原理（一） 阮一峰的博客——RSA算法原理（二） 初等数论笔记Part 1： 欧拉定理 算法学习笔记(9)：逆元 ","模逆元#模逆元":"简介 定义： $a$ 对 $n$ 的模逆元是满足 $ab\\equiv 1\\ (\\mathrm{mod}\\ n)$ 的 $b$​\n模逆元的存在性：模逆元存在的充要条件是 $\\mathrm{gcd}(a,n)=1$​\n为证明该存在性定理，需要先证明引理2\n引理2 若 $\\mathrm{gcd}(a,n)=g$ ，则存在 $x,y\\in Z$，满足 $ax+ny=g$\n证明：\n设集合 $S=\\lbrace ax+ny|x,y\\in Z \\rbrace $，显然，存在 $s\\in S$ 并且 $s\u003e0$ 设 $d$ 为 $S$ 中最小的，大于 $0$ 的元素 若 $a\\ \\mathrm{mod}\\ p\\neq 0$ ，则存在 $k,r$ 满足 $a=kd+r$ ，其中 $0 \u003c r \u003c k$ ，带入 $d=ax_0+ny_0$ ，得到 $r=a(1-kx_0)+n(-ky_0)$ 。 显然 $r\\in S$ ，又 $0 \u003c r \u003c k$ ，这与 $d$ 为 $S$ 中最小的大于 $0$ 的假设不符。 故 $a\\ \\mathrm{mod}\\ d=0$ ，同理 $n\\ \\mathrm{mod}\\ d=0$ 所以 $d$ 为 $a$ 和 $n$ 共同的因数。设 $g=ld$ ， $l\\geq0$ 且 $l\\in Z$ ，那么有 $g=ld=a(lx_0)+n(ly_0)$ 。 证明模逆元 现在证明模逆元\n充分性\n已知 $\\mathrm{gcd}(a,n)=1$ ，则有 $1=ax_0+ny_0$ $(ax_0+ny_0)\\ \\mathrm{mod}\\ n = ax_0 \\ \\mathrm{mod}\\ n $​ $(ax_0+ny_0)\\ \\mathrm{mod}\\ n= 1 \\ \\mathrm{mod}\\ n=1$ 故 $ax_0 \\ \\mathrm{mod}\\ n=1$ 即 $ax_0\\ \\equiv 1\\ (\\mathrm{mod}\\ n)$ ， $b=x_0$ 必要性：\n已经存在 $b$ 满足 $ab\\ \\equiv 1\\ (\\mathrm{mod}\\ n)$​ 则存在 $y,k$ 满足 $(ab+ny)\\ \\mathrm{mod}\\ n=1$ 则存在 $k$ 满足 $ab+ny-1=kn$ 即 $ab + n(y-k)=1$ 根据引理2，有 $\\mathrm{gcd}(a,n)\\leq 1$ ，显然只有 $\\mathrm{gcd}(a,n)=1$ ","欧拉公式#欧拉公式":"简介 函数 $\\phi(n)$ 为 $\\lbrace 1,2,…,n \\rbrace$ 中和 $n$ 互质的数的数量 例如 $\\phi(8)=4$ ，因为 $\\mathrm{gcd}(\\lbrace 1,3,5,7 \\rbrace,4)=1$ 性质 （性质1）\n对于质数 $n$ ，有 $\\phi(n)=n-1$\n（性质2）\n若存在质数 $p$ 满足 $n=p^k$ ，则 $\\phi(n)=p^k-p^k/p=n(1-1/p)$ 。思路为 $\\lbrace 1,2,…,n \\rbrace$ 中除去 $p$ 的倍数\n（性质3）\n若 $\\mathrm{gcd}(m,n)=1$ ，则 $\\phi(mn)=\\phi(m)\\phi(n)$ ​。证明如下：\n对于任意 $0 \u003c N \u003c mn$ ，有 $N=k_1m+p=k_2n+q$ 。假设 $N$ 满足 $\\mathrm{gcd}(N,mn)=1$ 显然， $\\mathrm{gcd}(N,m)=1$ ，故 $\\mathrm{gcd}(k_1m+p,m)=1$ ，显然 $\\mathrm{gcd}(p,m)=1$ 。同理 $\\mathrm{gcd}(q,n)$ 。 对于方程组 $$ \\begin{equation} \\begin{cases} N\\ \\equiv p\\ (\\mathrm{mod}\\ m)\\newline N\\ \\equiv q\\ (\\mathrm{mod}\\ n) \\end{cases} \\end{equation} $$\n根据中国剩余定理，有解 $N=kmn+t_ppn+t_qqm$ 。\n每有一组 $(p,q)$ ，该方程组就有一个解。注意 $\\mathrm{gcd}(p,m)=1$ ,且 $\\mathrm{gcd}(q,n)$ 。\n（性质4）\n对于 $n=\\prod\\limits_{i=1}^rp_i^{k_i}$ ，有 $\\phi(n)=\\phi(\\prod\\limits_{i=1}^rp_i^{k_i})=\\prod\\limits_{i=1}^r\\phi(p_i^{k_i})=\\prod\\limits_{i=1}^r(n(1-1/p_i))=n^r\\prod\\limits_{i=1}^r(1-1/p_i)$","欧拉定理#欧拉定理":"简介 若 $n,a$ 为正整数，且 $\\mathrm{gcd}(n,a)=1$ 则 $a^{\\phi(n)}\\ \\equiv 1\\ (\\mathrm{mod}\\ n)$​\n欧拉定理的证明 设 $\\Phi(n)=\\lbrace c_1,c_2,…,c_{\\phi(n)} \\rbrace$ 为小于 $n$ 且与 $n$ 互质的数的集合，即 $\\mathrm{gcd}(c_i,n)=1$。\n若 $\\mathrm{gcd}(a,n)=1$ ，考虑集合 $\\Phi_a(n)=\\lbrace (ac_1)\\ \\mathrm{mod}\\ n,(ac_2)\\ \\mathrm{mod}\\ n,…,(ac_{\\phi(n)})\\ \\mathrm{mod}\\ n \\rbrace$ 。我们证明 $\\Phi(n)=\\Phi_a(n)$\n先证明 $\\Phi_a(n)$ 中没有重复的元素，若 $ac_i\\ \\equiv ac_j\\ (\\mathrm{mod}\\ n)$ ,则 $c_i\\ \\equiv c_j\\ (\\mathrm{mod}\\ n)$ ，这显然错误。\n再证明 $\\mathrm{gcd}(ac_i\\ \\mathrm{mod}\\ n, n)=1$ 。设 $ac_i=k_in+r_i$ ，若 $\\mathrm{gcd}(r_i,n)=g$ ，则 $ac_i=g(k_i(n/g)+(r_i/g))$ 。等式右侧是 $g$ 的倍数，而左侧显然不是（ $a$ 和 $c$ 都与 $n$ 互质）\n所以：\n$$ \\prod\\limits_{i=1}^{\\phi(n)}c_i \\ \\equiv \\prod\\limits_{i=1}^{\\phi(n)}c_ia(\\ \\mathrm{mod}\\ n) $$\n即\n$$ \\prod\\limits_{i=1}^{\\phi(n)}c_i \\ \\equiv a^{\\phi(n)}\\prod\\limits_{i=1}^{\\phi(n)}c_i(\\ \\mathrm{mod}\\ n) $$\n显然 $\\mathrm{gcd}(\\prod\\limits_{i=1}^{\\phi(n)}c_i,n)=1$\n故\n$$ a^{\\phi(n)}\\ \\equiv 1\\ (\\mathrm{mod}\\ n) $$","费马小定理#费马小定理":"简介 如果 $p$ 是质数且 $\\mathrm{gcd}(a,p)=1$ , 那么 $a^{p-1}\\equiv 1\\ (\\mathrm{mod}\\ p)$\n在证明该定理前，先证明一个简单的引理\n引理1 如果 $p$ 是质数，且 $\\mathrm{gcd}(a,p)=1$ , 那么\n$$ \\lbrace ka \\ \\mathrm{mod}\\ p | k = \\lbrace 1,2,…,p -1 \\rbrace \\rbrace= \\lbrace 1,2,3,…,p-1 \\rbrace $$\n即二者存在一对一的关系。由于这两个集合的元素个数相同，所以只要证明左侧集合没有重复元素即可\n证明：假设存在 $k_1$ 和 $k_2$ 满足 $1 \\leq k_1 \u003c k_2 \\leq p-1$ ，且 $k_1a\\ \\mathrm{mod}\\ p = k_2a\\ \\mathrm{mod}\\ p$ . 那么可知\n$$ (k_1+p-k_2)a\\ \\mathrm{mod}\\ p = pa\\ \\mathrm{mod}\\ p=0 $$\n即 $(k_1+p-k_2)a\\ \\mathrm{mod}\\ p=0$ 。由于 $p$ 是质数，那么 $(k_1+p-k_2)a$ 一定是 $p$​​ 的倍数，这显然不可能。\n证明费马小定理 $$ \\begin{align} (1a)(2a)(3a)…((p-1)a)\\ \\mathrm{mod}\\ p \u0026= (a^{p-1}(p-1)!)\\ \\mathrm{mod}\\ p \\newline (1a\\ \\mathrm{mod}\\ p)(2a\\ \\mathrm{mod}\\ p)…((p-1)a\\ \\mathrm{mod}\\ p) \u0026= (a^{p-1}(p-1)!)\\ \\mathrm{mod}\\ p\\newline (p-1)! \u0026= (a^{p-1}(p-1)!)\\ \\mathrm{mod}\\ p \\end{align} $$\n整理得 $a^{p-1}\\equiv 1\\ (\\mathrm{mod}\\ p)$​"},"title":"ZERO TO RSA"},"/daily_advance_of_a_pawn/":{"data":{"":"一些乱七八糟的内容"},"title":"日拱一卒"},"/paper_reading/":{"data":{"":"论文阅读专题"},"title":"Paper_reading"},"/paper_reading/constant_recovery/":{"data":{"":"","0x0-backgroud#0x0 backgroud":"","0x1-background-on-sql-server#\u003cstrong\u003e0x1 BACKGROUND ON SQL SERVER\u003c/strong\u003e":"","0x2-constanttimerecovery#\u003cstrong\u003e0x2 CONSTANTTIMERECOVERY\u003c/strong\u003e":"0x0 backgroud Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since recovering a long running transaction can take several hours.\nThis paper describes the overall design of “Constant Time Recovery” (CTR)\nRecovering the database to a consistent state requires undoing all operations performed by uncommitted transactions, and recovering a long running transaction can take several hours\n0x1 BACKGROUND ON SQL SERVER 0x11 DatabaseRecovery Following ARIES, the SQL Server recovery process has three distinct phases. Figure 2 demonstrates these phases and the portion of the log they process.\n(The oldest transaction can run across many checkpoints)\nanalysis: identifys: any transactions that must be rolled back LSN of the oldest dirty page in the system Checkpoint process captured all active transactions and the oldest dirty page LSN at the time of the checkpoint, so analysis can start from that redo: bringing the database back to the state it was at the time of the failure: Since Analysis has recomputed the Oldest Dirty Page LSN, Redo should only process the log from this point. Only applies the operation if the Page LSN is lower Processes the log starting from the beginning of the oldest active transaction. This allows recovery to reacquire all the locks held by active transactions and make the database available at the end of Redo for improved availability undo: rolling back any transactions that were active at the time of the failure. As Redo has reacquired the locks required by these transactions, the Undo process can be performed while the database is available and user queries will be blocked only if they attempt to access the data modified by the transactions pending undo. Undoing these operations is also logged using Compensation Log Records (CLR) to guarantee that the database is recoverable even after a failure in the middle of the Undo process 0x12 Multi-versionConcurrencyControl Versioning is performed at the row level: for every user data update, SQL Server updates the row in-place in the data page and pushes the old version of the row to an append-only version store, linking the current row version to the previous version\nThe versions are linked to each other using their physical locator\nGiven that these versions are only used for the purposes of SI, the version store doesn’t need to be preserved across restarts and is stored in SQL Server’s “TempDB”, a system database that is recycled every time the SQL Server process restarts. This allows for efficient version generation, as these operations are not logged.\n0x2 CONSTANTTIMERECOVERY 0x21 Overview Database recovery in constant time, regardless of the user workload and transaction sizes. Transaction rollback in constant time regardless of the transaction size. Continuous transaction log truncation, even in the presence of long running transactions. CTR achieves these by separating transactional operations into three distinct categories and handling their recovery using the most appropriate mechanism.\n0x22 three transactional operations categories 0x221 Data Modifications All data modifications are versioned, storing the earlier versions of each row in the version store that is now redesigned to be persistent and recoverable\n（笑死我了，刚刚还在感叹 version store 无需记录，重启即删多么方便）\nWhen a transaction rolls back, it is simply marked as “aborted”, indicating that any new transactions should ignore the versions generated by this transaction and access the earlier committed versions\nDuring database recovery\nAnalysis identifies the state of every transaction Redo recovers the row and the version store content as of the time of the failure. Undo marks the uncommitted transactions as aborted making all updates by these transactions invisible. This allows Undo to complete in constant time, regardless of the transaction sizes. （仍然和 aborted xact count 相关，但相比于 modified row count，几乎可以忽略不计） 0x222 System Operations System operations refer to internal operations the DBMS uses to maintain its internal data structures, such as space allocation and deallocation, B-Tree page splits, etc.\ndifficulty: These operations cannot be easily versioned Additionally, these operations are usually tied to user data modifications and can be a significant percentage of the operations performed by a long-running transaction. For example, a large data load allocates a large number of pages Solution: These operations are always performed by short-lived, system transactions that update the internal data structures and immediately commit When a failure occurs, these operations will not be undone, but the allocated space and other updated data structures will be lazily reclaimed and fixed up in the background. 0x223 Logical and Other Non-versioned Operations This last category refers to operations that cannot be versioned because they are either:\nlogical: such as lock acquisition operations that indicate that a certain lock must be acquired during recovery cache invalidation operations that are responsible for invalidating in-memory caches when a transaction rolls back they are modifying data structures that need to be accessed during start up must maintain a very specific format that does not allow versioning CTR leverages an additional log stream, SLog, that allows tracking only the relevant operations and not having to process the full transaction log for the corresponding transactions. 0x23 Persistent Version Store Persistent Version Store (PVS) allows row versions to be recoverable by storing them in the user database and logging them in the transaction log as regular user data.\nHence, at the end of Redo all versions are fully recovered and can be accessed by user transactions 0x231 In-row Version Store Since in most cases the difference between the two versions is small (for example when only a few columns are updated), we can simply store the diff between the two versions\nEven though computing and reapplying the diff requires additional CPU cycles, the cost of generating an off-row version, by accessing another page and logging the version as a separate operation, is significantly higher （再读另一个页代价更大） ![[attachments/Pasted image 20240714101730.png]]\n（ diff 怎么存储呢？定长的 id 字段可能不够！）\nDespite its benefits in most common cases, in-row versioning can negatively impact the performance of the system if it significantly increases the size of rows in the data pages. This is particularly problematic for B-Trees as it can lead to page splits. （diff 会占用大量空间，引起 page 数量膨胀，B树分裂代价高 ）\n0x232 Off-row Version Store It is implemented as an internal table that has no indexes since all version accesses are based on the version’s physical locator (Page Id, Slot Id) （纯 heap，无索引）\nEach version of user data is stored as a separate row in this table, having some columns for persisting version metadata and a generic binary column that contains the full version content, regardless of the schema of the user table this version belongs to. （存全量数据，而不仅是 diff)\nBy leveraging regular logging, off-row PVS is recovered using the traditional recovery mechanisms\n0x23 Logical Revert 0x231 overview CTR leverages the PVS to instantly roll back data modifications.\nWhen a query accesses a row, it first checks the state (active, committed or aborted) of the transaction that generated the latest version.\nIf the transaction is active or has been committed: visibility depends on the query isolation level. （ 事务提交，则看第一个 version ） but if the transaction is aborted, this version is definitely not visible and the query traverses the version chain to identify the version that belongs to a committed transaction and is visible. （ 事务回滚，则遍历 version chain ） Additionally, if a new transaction updates a row with an aborted version, it must first revert the effects of the aborted transaction before proceeding with the update. （ 做完 redo 后，the latest version 可能是 abort 状态，真正有效的 version 在 version chain 中，所以需要修复 the latest version ）\nCTR implements two different mechanisms for reverting the updates performed by aborted transactions:\nLogical Revert is the process of bringing the committed version of a row back to the main row in the data page,\nso that all queries can access it directly and versions in the version store are no longer required This process compares the state of the aborted and committed versions and performs the required compensating operation the revert operations are not versioned Since these transactions only revert a row at a time, they are guaranteed to be short-lived and don’t affect recovery time. Logical Revert is used by a background cleanup process to eliminate all updates performed by aborted transactions and eventually remove the aborted transactions from the system. ![[attachments/Pasted image 20240714110353.png]] overwrite the aborted version with the new version it is generating\nThis process minimizes the overhead for these operations and allows them to be almost as fast as if there was no aborted version. ![[attachments/Pasted image 20240714110439.png]] In CTR, the database is fully available, releasing all locks, while row versions are lazily cleaned up in the background.\n0x232 Transaction State Management For SI, visibility depends on the commit timestamp of the transaction that generated the version. Since SQL Server does not allow snapshot transactions to span server restarts, the commit timestamps can be stored in memory and need not be recovered. CTR, however, requires tracking the state of aborted transactions until all their versions have been logically reverted and are no longer accessible.\nCTR stores the aborted transaction information in the “Aborted Transaction Map” (ATM)\nRestore ATM after crash:\nWhen a transaction aborts, before releasing any locks, it will add its Transaction Id to the ATM and generate an “ABORT” log record indicating that it was aborted. （产生 ATM 信息） When a checkpoint occurs, the full content of the ATM is serialized into the transaction log as part of the checkpoint information. （ checkpoint 整理 ATM 信息 ） Since Analysis starts processing the log from the Checkpoint Begin LSN of the last successful checkpoint, or earlier, it will process this information regarding the aborted transactions and reconstruct the ATM. （ analysis 根据 checkpoint 重建 ATM ） Any transactions that aborted after the last checkpoint will not be included in the checkpoint, but Analysis will process their ABORT log records and add them to the map （ analysis 分析 checkpoint 后面事务的 ABORT log，并写入 ATM ） Following this process, Analysis can reconstruct the ATM as of the time of the failure, so that it is available when the database becomes available at the end of Redo.\nOnce all versions generated by an aborted transaction have been reverted, the transaction is no longer interesting for recovery and can be removed from the ATM.\nRemoving a transaction is also a logged operation, using a “FORGET” log record, to guarantee that the content of the ATM is recovered correctly. （Removing from ATM 也要新加日志？这也太复杂了。。。。）\n0x233 Short Transaction Optimization Maintaining the Aborted Transaction Map and forcing queries to visit additional versions incur a performance penalty, short OLTP transactions as they would significantly increase the size of the ATM\nWhen a transaction attempts to roll back, we evaluate the number of operations it performed and the amount of log it generated and qualify it as “short” if these don’t exceed certain thresholds.\nShort transactions will not go through the CTR rollback process, but use traditional undo, so that they are immediately removed from the system. （ 太多短事务导致 ATM 膨胀，解决方案为混用 CTR 和 undo？这么复杂么？ ）\n0x24 Non-versioned Operations A variety of operations that cannot be versioned because they are:\nLogical: such as acquiring coarse-grained locks invalidating various caches when a transaction rolls back accumulating row and page statistics Updating system metadata in data structures Updating critical system metadata required for starting up the database, before recovery can reconstruct versioning information, such as updates to the “boot page”, a special page that contains the core information required for initialization.（ ？这些东西还能做成page？，还有版本管理？这就是商业数据么？ ） To handle these operations while guaranteeing recovery in constant time, we are leveraging two different mechanisms:\n0x241 SLog: A Secondary Log Stream SLog is a secondary log stream designed to only track non-versioned operations that must be redone or undone using information from the corresponding log records.\nFor example, when altering the data type of a column in a large table, the transaction will have to update millions of rows, but SLog will only contain a handful log records, for acquiring the exclusive lock and invalidating metadata caches."},"title":"constant recovery with undo"},"/paper_reading/mesi/":{"data":{"":"","0x0-why-we-need-memory-barrier#0x0 why we need memory barrier":"","0x1-cache-structure#0x1 \u003cstrong\u003eCache Structure\u003c/strong\u003e":" paper Introduction: Memory Barriers: a Hardware View for Software Hackers 0x0 why we need memory barrier In short, because reordering memory references allows much better performance, and so memory barriers are needed to force ordering in things like synchronization primitives whose correct operation depends on ordered memory references.\n0x1 Cache Structure 0x11 some cases of cache miss(not important) The cache miss means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is fetched from memory.\ncapacity miss: After some time, the CPU’s cache will fill, and sub- sequent misses will likely need to eject an item from the cache in order to make room for the newly fetched item\nassociativity miss: occur in set-associative caches.\nAn “associativity cache miss” refers to a specific type of cache miss that can occur in set-associative caches.\nIn a set-associative cache, the cache memory is divided into sets, and each set contains multiple cache lines (or cache blocks). When the CPU needs to access data in memory, it first checks the cache to see if the data is present. The cache lookup is done by first identifying the set that the data would be stored in, and then searching through the multiple cache lines within that set to see if the data is present.\nAn associativity cache miss occurs when the data the CPU needs is not found in any of the cache lines within the identified set. This means the CPU has to go to main memory to fetch the data, which is slower than finding it in the cache.\nThe number of cache lines per set is called the “associativity” of the cache. Caches with higher associativity (more cache lines per set) generally have lower associativity cache miss rates, but they are also more complex and expensive to implement. The goal is to find the right balance of associativity to minimize cache misses without making the cache design overly complex.\nwrite miss: Before a given CPU writes to that data item, it must first cause it to be removed, or “invalidated”, from other CPUs’ caches. Once this invalidation has completed, the CPU may safely modify the data item. If the data item was present in this CPU’s cache, but was read- only, this process is termed a “write miss”.\ncache structure: one cache address can store two(or more?) sets of data.","0x2-cache-coherence-protocols#0x2 Cache-Coherence Protocols":"0x21 Four state: MESI States The four types of states represent the state of a cache line in one cpu.\nHere, we use “I” to represent the cpu.\nmodified: I have changed the value in private cache and not written it back to memory. Others can’t access the memory until change their states(signal me). exclusive: I haven’t changed the value in private cache. (But may change it later, transfer to modified state) Others can’t access the memory until change their states(signal me). shared Others can read the memory without consulting me. invalid: the cache line holds no data. 0x22 Messages between the cpus(and memory): MESI Protocol Messages Read: a request for reading a line Read Response: The line data for a previous read. Either of memory or other cpu. Invalidate: invalidate the line in all other cpus Invalidate Acknowledge: successful response to a previous Invalidate message Read Invalidate: a atomic combination of “read” and “invalidate”. Requires both a “read response” and a set of “in- validate acknowledge” messages in reply. Writeback: write a line to memory 0x23 State Machine: MESI State Diagram Transitions are explained below:\n(a): write back to memory (b): modify the data in cache (c): I haven’t written back to memory but another cpu requests it (and will change it). So I return the value in cache and invalidate the private one without writing back to memory (d): I want to change a cache, so I emit a “invalidate” to other cpus. Now all others have acknowledge me, so I read and change my private cache. (e): Similar to “(d)”, but don’t need to read in memory. (f): Similar to (c), I haven’t written back to memory but another cpu requests it (but will not change it), so I return my private value. (g): Similar to (f) (h): similar to “(d)”, but don’t modify it now (i): similar to “(c)”, but don’t need to return my private value since that in memory is still the newest. (j): Similar to “(d)” (k): read in memory( or other cpu) (l): receive a “invalidate” message Examples are in the paper.","0x3-optimize-1-stores-result-in-unnecessary-stalls#0x3 Optimize 1: Stores Result in Unnecessary Stalls":"Consider to modify a cache that isn’t in modified or exclusive state.\nProblem: there is no real reason to force CPU 0 to stall for so long — after all, regardless of what data happens to be in the cache line that CPU 1 sends it, CPU 0 is going to unconditionally overwrite it. Solution: Add “store buffers” between each CPU and its cache CPU0 write to its store buffer immediately When CPU0 is acknowledged, the data will be moved from the store buffer to the cache line 0x31: Store Forwarding problem Thinking of the program below:\nCPU0 has value b CPU1 has value a = 0 in exclusive mode a = 1; b = a + 1; assert(b == 2); step1: cpu0 invalidate cpu1 with “a” , change private cache line to 1, and write it to store buffer.\nstep2: cpu0 receive the value “a” from cpu1. The value is 0, and it’s stored in private cache.(Note that the value in the store buffer is 1)\nstep3: cpu0 executes “b = a + 1”, load “a” from cache, and its value is 0\nstep4: cpu0 store the value of “b” to cache, whose value is 1\nstep5: cpu0 move the value of “a” from store buffer(1) to cache(0)\nstep6: CPU0 executes assert(b==2), which fails.\nThe problem is that we have two copies of “a”, one in the cache and the other in the store buffer.\nThe hardware guys took pity and implemented “store forwarding”, where each CPU refers to (or “snoops”) its store buffer as well as its cache when performing loads\nIn other words, a given CPU’s stores are directly forwarded to its subsequent loads, without hav- ing to pass through the cache.\n0x32 Store Buffers and Memory Barriers Think of the program below\nvoid foo(void) { a=1; b=1; } void bar(void) { while (b == 0) continue; assert(a == 1); } cpu0 executes foo own “b” cpu1 executes bar own “a” The problem is that, cpu1 reads “a” before being acknowledged that other cpus have changed it. Although CPU0 can continue to execute before writing it to stored buffer, but CPU1 doesn’t know that.\nThe hardware designers cannot help directly here, since the CPUs have no idea which variables are related, let alone how they might be related\nTherefore, the hardware designers provide memory-barrier instructions to allow the software to tell the CPU about such relations. The program fragment must be updated to contain the memory barrier:\nvoid foo(void) { a=1; smp_mb(); b=1; } void bar(void) { while (b == 0) continue; assert(a == 1); } The memory barrier smp_mb() will cause the CPU to flush its store buffer before applying subsequent stores to their cache lines. The CPU could either\nsimply stall until the store buffer was empty before proceeding, or it could only use the store buffer to hold subsequent stores until all of the prior entries in the store buffer had been applied. This is to prevent other cpus from getting the subsequent value before getting the prior entries So that, CPU0 will\nwait for the “invalidate acknowledge” message of “a” before executing “b=1;” or\n(1)while executing smp_mb ,marks all current store-buffer entries (namely, the a=1) (2) while executing “b=1”, only stores it store buffer. (3) wait “invalidate acknowledge” of “a” (4) store the value of b in stored buffer and send a “invalidate” message ","0x4-optimize-2-store-sequences-result-in-unnecessary-stalls#0x4 Optimize 2: Store Sequences Result in Unnecessary Stalls":" Once the stored buffer is full or a memory barrier is encountered, the CPU must once again wait for invalidations to complete in order to drain its store buffer before it can continue executing invalidate acknowledge messages can take so long: they must ensure that the corre- sponding cache line is actually invalidated, and this invalidation can be delayed if the cache is busy, for example, if the CPU is intensively loading and storing data, all of which resides in the cache. However, the CPU need not actually invalidate the cache line before sending the acknowledgement.\n0x42 Invalidate Queues and Invalidate Acknowledge A CPU with an invalidate queue may acknowledge an invalidate message as soon as it is placed in the queue, instead of having to wait until the corresponding line is actually invalidated.\n0x43 Invalidate Queues and Memory Barriers Thinking of the following code:\nvoid foo(void) { a=1; smp_mb(); b=1; } void bar(void) { while (b == 0) continue; assert(a == 1); } CPU0: execute foo a is shared state b is exclusive CPU1: execute bar Once again, the CPU designers cannot do much about this situation However, the memory-barrier instructions can interact with the invalidate queue. When a given CPU executes a memory barrier, it marks all the entries currently in its invalidate queue, and forces any subsequent load to wait until all marked entries have been applied to the CPU’s cache.\nvoid foo(void) { a=1; smp_mb(); b=1; } void bar(void) { while (b == 0) continue; smp_mb(); assert(a == 1); } So that, CPU0 will\n(1) executes the smp_mb(), marking the entry in its invalidate queue. (2) start executing the assert(a==1), but a is in the invalidate queue, CPU 1 must stall this load until that entry in the invalidate queue has been applied. ","0x5-summary-read-and-write-memory-barriers#0x5 Summary: Read and Write Memory Barriers":"In the previous section, memory barriers were used to mark entries in both the store buffer and the inval- idate queue. But in our code fragment, foo() had no reason to do anything with the invalidate queue, and bar() similarly had no reason to do anything with the store queue.\nMany CPU architectures therefore provide weaker memory-barrier instructions that do only one or the other of these two.\nread memory barrier: marks only the invalidate queue forces any subsequent load to wait until all marked entries have been applied from the invalidate queue write memory barrier: marks only the store buffer. only use the store buffer to hold subsequent stores until all of the prior entries in the store buffer had been applied. void foo(void) { a=1; smp_wmb(); b=1; } void bar(void) { while (b == 0) continue; smp_rmb(); assert(a == 1); } "},"title":"MESI AND MEMORY_BARRIER: paper reading"},"/paper_reading/roaring_bitmap/":{"data":{"":"","0x0-introduction#0x0 Introduction":"","0x1-related-infomation#0x1 Related Infomation:":"","0x2-introduction-to-roaring-bitmap#0x2 Introduction TO Roaring Bitmap":"","0x3-set-operations#0x3 set operations":"","0x4-the-run-type-container#0x4 The \u0026ldquo;run\u0026rdquo; type container":"0x0 Introduction A bitmap, also known as a bit array or bitset, is a data structure that represents a fixed-size sequence of bits. That is the value of the ith bit representing the existence of the the ith object. Bare bitmap can cost much memory according to the total substantial data size, even if we have stored little infomation. Roaring bitmap provide a new method to compress the bitmap structure.\n0x1 Related Infomation: blogs: (Very Important Introduction) [Blog of Vikram Oberoi]:A primer on Roaring bitmaps: what they are and how they work [blog of charlieroro] roaring bitmaps 【木东居士】：不深入而浅出 Roaring Bitmaps 的基本原理 paper Introduction: Better bitmap performance with Roaring bitmaps.pdf Opitmazition: Consistently faster and smaller compressed bitmaps with Roaring.pdf 0x2 Introduction TO Roaring Bitmap 0x21 two types of containers We partition the range of 32-bit indexes ([0, n)) into chunks of $2^{16}$ integers sharing the same 16 most significant digits. We use specialized containers to store their 16 least significant bits.\n(One chunk’ size is up to 8KB, that is 4096 integers.)\nWhen a chunk contains no more than 4096 integers, we use a sorted array of packed 16-bit integers. When there are more than 4096 integers, we use a $2^{16}$​-bit bitmap. Thus, we have two types of containers: an array container for sparse chunks and a bitmap container for dense chunks.\nSince the size of a chunk is up to 8KB, we may save much memoy if the cardinality is small. Don’t worry about the memory allocator, it can deal with the small memory with local buffer. And I believe it’s the most important meaning of two types of containers.\n0x22 conversion between the two types of container timing\nWhen removing an integer, a bitmap container might become an array container if its cardinality reaches 4096. When adding an integer, an array container might become a bitmap container when its cardinality exceeds 4096. method\nWhen this happens, a new container is created with the updated data while the old container is discarded. Converting an array container to a bitmap container is done by creating a new bitmap container initialized with zeros, and setting the corresponding bits. To convert a bitmap container to an array container, we extract the location of the set bits using an optimized algorithm 0x23 index array To check for the presence of a 32-bit integer x, we first seek the container corresponding to $x/2^{16}$ using binary search. If a bitmap container is found, we access the (x mod $2^{16}$)th bit. If an array container is found, we use a binary search again\nThe containers are stored in a dynamic array with the shared 16 most-significant bits: this serves as a first-level index. The array keeps the containers sorted by the 16 most-significant bits.\n0x3 set operations There are\nTwo basic opertions: union (bitwise OR) and intersection (bitwise AND); And three container type combinations: bitmap vs bitmap, array vs array annd bitmap vs array 0x31 bitmap vs bitmap union operation(the result must be a bitmap container) :\nIt might seem like computing bitwise ORs and computing the cardinality of the result\nwould be significantly slower than merely computing the bitwise ORs. However, four factors mitigate this potential problem\n[built in cpu instructions]: popular processors (Intel, AMD, ARM) have fast instructions to compute the number of ones in a word. Intel and AMD’s popcnt instruction has a throughput as high as one operation per CPU cycle. [Java Opitimization]: Recent Java implementations translate a call to Long.bitCount into such fast instructions. [superscalar]: Popular processors are superscalar: they can execute several operations at once. Thus, while we retrieve the next data elements, compute their bitwise OR and store it in memory, the processor can apply the popcnt instruction on the last result and increment the cardinality counter accordingly. [enough L1 cache]: For inexpensive data processing operations, the processor may not run at full capacity due to cache misses. intersection operation:\nFor computing intersections, we use a less direct route. First, we compute the cardinality of the result, using 1024 bitwise AND instructions. If the cardinality is larger than 4096, then we proceed as with the union, writing the result of bitwise ANDs to a new bitmap container. Otherwise, we create a new array container. We extract the set bits from the bitwise ANDs on the fly. See chapter “0x22” for detail\n0x32 bitmap vs array intersection(the result must be an array container)：we iterate over the sorted dynamic array, and verify the existence of each 16-bit integer in the bitmap container. The result is written out to an array container Unions(the result must be a bit map container)：we create a copy of the bitmap and simply iterate over the array, setting the corresponding bits 0x33 Array vs Array For unions: if the sum of the cardinalities is no more than 4096(the result must be an array container): we use a merge algorithm between the two arrays otherwise: Otherwise, we set the bits corresponding to both arrays in a bitmap container. We then compute the cardinality using fast instructions. If the cardinality is no more than 4096, we convert the bitmap container to an array containe. intersection(the result must be an array container): if the two arrays have cardinalities that differ by less than a factor of 64: merge otherwise: galloping intersection Galloping is superior to a simple merge when one array ($r$) is much smaller than other one ($f$) because it can skip many comparisons. Starting from the beginning of both arrays, we pick the next available integer $r_i$ from the small array $r$ and seek an integer at least as large $f_j$ in the large array $f$ , looking first at the next value, then looking at a value twice as far, and so on. Then, we use binary search to advance in the second list to the first value larger or equal to $r_i$ .\nGalloping(exponential search) Introduction\nThe initial value of bound can alway advance in each search.\n// Returns the position of key in the array arr of length size. template \u003ctypename T\u003e int exponential_search(T arr[], int size, T key) { if (size == 0) { return NOT_FOUND; } int bound = 1; while (bound \u003c size \u0026\u0026 arr[bound] \u003c key) { bound *= 2; } return binary_search(arr, key, bound/2, min(bound + 1, size)); } 0x34 in place operations When computing the union between two bitmap containers, we can modify one of the two bitmap containers instead of generating a new bitmap container. Similarly, for the intersection between two bitmap containers, we can modify one of the two containers if the cardinality of the result exceeds 4096 When computing the union between an array and a bitmap container, we can write the result to the bitmap container, by iterating over the values of the array container and setting the corresponding bits in the bitmap container. We can update the cardinality each time by checking whether the word value has been modified. 0x4 The “run” type container 0x41 To introduction to “run” The original Roaring has a limitation in some scenarios because it does not compress long runs of values. Indeed, given a bitset made of a few long runs (e.g., all integers in [10, 1000]), Roaring—as presented so far—can only offer suboptimal compression. If we consider the case of a bitmap made of all integers in [10, 1000], Roaring without support for runs would use 8 kB, whereas a few bytes ought to suffice.\nSuch unnecessarily large bitmaps can stress memory bandwidth. computing the intersection of two bitmaps representing the ranges [10, 1000] and [500, 10000] can be done in a few cycles when using RLE-compressed bitmaps. But the original Roaring would require intersecting two bitmap containers and possibly thousands of cycles. See chapter “0xF1” for detail. To solve this problem, we decided to add a third type of container to Roaring, one that is ideally suited to coding data made of runs of consecutive values. The new container is conceptually simple: **given a run (e.g., [10, 1000]), we store the starting point (10) and its length minus one (990). By packing the starting points and the lengths in pairs, using 16 bits each, **we preserve the ability to support fast random access by binary search through the coded runs\nThe run container, is made of a packed array of pairs of 16-bit integers. The first value of each pair represents a starting value, whereas the second value is the length of a run. For example, we would store the values 11, 12, 13, 14, 15 as the pair 11, 4 where 4 means that beyond 11 itself, there are 4 contiguous values that follow.\nIn addition to this packed array, we need to maintain the number of runs stored in the packed array. Like the array container, the run container is stored in a dynamic array. During serialization, we write out the number of runs, followed by the corresponding packed array.\n0x42 Decide The Best Container To decide the best container type, we are motivated to minimize storage. In serialized form, a run container uses 2 + 4r bytes(16-bit integer is 2 bytes and we need a pair; plus the number of runs) given r runs, a bitmap container always uses 8192 bytes and an array container uses 2c + 2 bytes, where c is the cardinality. Therefore, we apply the following rules:\nAll array containers are such that they use no more space than they would as a bitmap container: they contain no more than 4096 values. Bitmap containers use less space than they would as array containers: they contain more than 4096 values. A run container is only allowed to exist if it is smaller than either the array container or the bitmap container that could equivalently store the same values. If the run container has cardinality greater than 4096 values, then the number of runs must be no more than $\\lceil(8192 − 2)/4\\rceil = 2047$ runs. (Or it must be converted to a bitmap container) If the run container has cardinality no more than 4096, then the number of runs must be less than half the cardinality. (Or it must be converted to an array container) **So, the critical step in deciding whether an array or bitmap container should be converted to a run container is to count the number of runs of consecutive numbers it contains. **\n0x43 Compute The Number Of Runs For array containers, we count this number by iterating through the 16-bit integers and comparing them two by two in a straightforward manner. Because array containers have at most 4096 integers, this computation is expected to be fast.\nFor bitmap containers, the below algorithm shows how to compute the number of runs.\nWe can illustrate the core operation of the algorithm using a single 32-bit word containing 6 runs of consecutive ones:\nWe can verify that $\\mathrm{bitCount}((C_i \\ll 1)\\ \\mathrm{ANDNOT}\\ C_i) = 6$, that is, we have effectively computed the number of runs. ($a\\ \\mathrm{ANDNOT}\\ b$is true iff a=1 and b=0) In the case where a run continues up to the left-most bit, and does not continue in the next word, it does not get counted, but we add another term (($C_i \\gg 63$) ANDNOT $C_i+1$ when using 64-bit words) to check for this case. Nevertheless, the computation may be expensive—exceeding the cost of computing the union or intersection between two bitmap containers. Thus, instead of always computing the number of runs exactly, we rely on the observation that no bitmap container with more than 2047 runs should be converted. As soon as we can produce a lower bound exceeding 2047 on the number of runs, we can stop. An exact computation of the number of runs is important only when our lower bound is less than 2048. In short: estimate the lower bound count of runs first, and only do the precise computation if the lower bound is less than 2048.\nThere are several method to implement the heuristic algorithm, and see the paper for details.\n0x44 Logical operations There are many necessary logical operations, but we present primarily the union and intersection.\n0x441 Bitmap vs Bitmap: ","0xf-appendix#0xF appendix":"0xF1 RLE-based compressed bitmaps There are many RLE-based compression formats.\n0xF11 Introduction To WAH For example, WAH organizes the data in literal and fill words.\nLiteral words contain a mix of W − 1 zeros and ones (e.g., $01011 · · · 01$) where W denotes the word size in bits: typically W = 32 or W = 64. Fill words are made of just W − 1 ones or just W − 1 zeros (i.e., $11 · · · 11$ or $00 · · · 00$). WAH compresses sequences of consecutive identical fill words The most significant bit of each word distinguishes between fill and literal words\nWhen it is set to one, the remaining W −1 bits store the W −1 bits of a literal word. When it is set to zero, the second most significant bit indicates the bit value whereas the remaining bits are used to store the number of consecutive identical fill words (the run length) 0xF12 Introduction To Concise Concise is a variation that reduces the memory usage when the bitmap is _moderately sparse. _Instead of storing the run length using $W − 2$ bits, Concise uses only $W − 2 − \\lceil log2(W )\\rceil$ bits to indicate a run length $r$, reserving $\\lceil log2(W )\\rceil$ bits to store a value $p$. When $p$ is non-zero, we decode $r$ fill words, plus a single $W − 1$ bit word with its $p^{th}$ bit flipped.\nBelow is an example: "},"title":"roaring bitmap"},"/post/20250301-1r5xzc.html":{"data":{"":"","column-oriented-storage#Column-Oriented Storage":"Basic idea: Although fact tables are often over 100 columns wide, a typical data warehouse query only accesses 4 or 5 of them at one time (SELECT *​ queries are rarely needed for analytics)\nThe idea behind column-oriented storage is simple: don’t store all the values from one row together, but store all the values from each column together instead. If each column is stored in a separate file, a query only needs to read and parse those columns that are used in that query, which can save a lot of work\n‍\nColumn Compression ​​\nOften, the number of distinct values in a column is small compared to the number of rows (for example, a retailer may have billions of sales transactions, but only 100,000 distinct products). We can now take a column with n distinct values and turn it into n separate bitmaps: one bitmap for each distinct value, with one bit for each row. The bit is 1 if the row has that value, and 0 if not.\n​WHERE product_sk IN (30, 68, 69):​ Load the three bitmaps for product_sk = 30, product_sk = 68, and product_sk = 69, and calculate the bitwise OR of the three bitmaps, which can be done very efficiently. ​WHERE product_sk = 31 AND store_sk = 3:​ Load the bitmaps for product_sk = 31 and store_sk = 3, and calculate the bitwise AND. This works because the columns contain the rows in the same order, so the kth bit in one column’s bitmap corresponds to the same row as the kth bit in another column’s bitmap. Writing to Column-Oriented Storage Column-oriented storage, compression, and sorting all help to make those read queries faster. However, they have the downside of making writes more difficult.\nFortunately, we have already seen a good solution earlier in this chapter: LSM-trees. All writes first go to an in-memory store, where they are added to a sorted structure and prepared for writing to disk\n‍\nAggregation: Data Cubes and Materialized Views If the same aggregates are used by many different queries, it can be wasteful to crunch through the raw data every time. Why not cache some of the counts or sums that queries use most often?\n​​\n‍","lsm-tree#LSM TREE":"Short introduction this time. The data structure may worth a deep study!. The following contents are from deepseek:\nLSM-Tree（日志结构合并树）简介 LSM-Tree（Log-Structured Merge-Tree）是一种高效处理高写入吞吐量的存储数据结构，广泛应用于现代数据库（如LevelDB、RocksDB、Cassandra）和存储引擎中。其核心设计目标是通过顺序写入优化写性能，同时通过分层合并（Compaction）平衡读写效率。\n核心设计思想 写入优化：\n内存缓冲（MemTable） ：所有写入操作首先进入内存中的有序结构（MemTable），避免直接随机写磁盘。 顺序写入磁盘（SSTable） ：当MemTable填满后，冻结为不可变的SSTable（Sorted String Table）并顺序写入磁盘，减少磁盘寻址开销。 分层存储与合并（Compaction） ：\n分层结构：磁盘上的SSTable按层级组织，通常分为多个层级（如Level 0到Level N），低层级数据较新，高层级数据较旧且合并后更大。 合并过程：后台定期将低层级的SSTable与高层级合并，消除重复数据（如删除标记），减少读取时的I/O放大问题。 关键组件 MemTable：\n基于内存的有序结构（如跳表或平衡树），支持快速插入和查询。 写入达到阈值后冻结，转为SSTable写入磁盘。 SSTable（Sorted String Table） ：\n不可变的有序键值存储文件，按主键排序。 包含索引（如稀疏索引）和Bloom Filter，加速点查询。 Compaction策略：\nSize-Tiered Compaction（大小分级）：合并同层大小相近的SSTable。 Leveled Compaction（分层合并）：每层仅保留一个SSTable，合并时跨层优化，减少空间放大。 工作流程 写入路径：\n写入MemTable → MemTable写满后转为SSTable → 写入磁盘Level 0。 读取路径：\n先查询MemTable → 未命中则逐层查询SSTable（Level 0到N）。 使用Bloom Filter快速过滤不存在的键，减少磁盘访问。 合并流程：\n后台线程选择层级中的SSTable进行合并，生成新的高层级SSTable，并删除旧文件。 优缺点分析 优点 缺点 ✅ 高写入吞吐量（顺序写优化） ❌ 读取延迟可能较高（需查多层级） ✅ 天然支持数据压缩和去重 ❌ Compaction可能占用CPU/IO资源 ✅ 适合SSD（减少随机写磨损） ❌ 范围查询效率依赖层级合并策略 应用场景 写密集型系统：日志存储、时序数据库（如InfluxDB）、物联网设备数据采集。 分布式数据库：Cassandra、HBase底层存储引擎。 消息队列：Kafka的日志存储（类似LSM思想）。 对比B-Tree 特性 LSM-Tree B-Tree 写入性能 高（顺序写） 低（随机写导致页分裂） 读取性能 点查询依赖Bloom Filter，范围查询较慢 点查询和范围查询均高效 存储开销 可能有写放大（Compaction） 空间利用率高，但需维护页结构 适用场景 写多读少，SSD环境 读多写少，传统硬盘环境 优化技术 Bloom Filter：加速点查询，减少不必要的磁盘访问。 分层索引：为SSTable建立稀疏索引，快速定位数据块。 并行Compaction：多线程合并减少对前台业务的影响。 Tiered vs Leveled Compaction：根据负载选择合并策略（写优化 vs 读优化）。 总结 LSM-Tree通过顺序写入和分层合并机制，在高吞吐写入场景中表现卓越，尤其适合现代SSD存储和分布式系统。尽管读取效率可能低于B-Tree，但通过Bloom Filter和合理的数据分层策略，仍能满足多数实时需求。理解其核心原理和权衡，是设计高性能存储系统的关键。\n‍"},"title":"2025-03-01"},"/postgresql/build_from_source/":{"data":{"":"","download-through-git#Download through git":"See official docs for detail. Below is a simple example:\nexport user=dev export src_dir=postgresql export build_dir=/home/${user}/build export data_dir=/home/${user}/data export superuser=postgres export defaultdb=test ${build_dir}/bin/pg_ctl -D ${data_dir} stop rm -rf ${build_dir} rm -rf ${data} cd ~ #start from home/${user} git clone https://git.postgresql.org/git/postgresql.git cd ${src_dir} git clean -xdf # may be too dangerous # delete for add some configures accordingly ./configure \\ --prefix=${build_dir} \\ --enable-cassert \\ --with-tcl \\ --with-perl \\ --with-python \\ --enable-debug \\ --without-icu \\ --with-openssl \\ CC=/usr/bin/gcc \\ CFLAGS='-O0 -pipe -Wall -g3' make -j8 \u0026\u0026 make install make -C contrib install ${build_dir}/bin/initdb --username=${superuser} --pgdata=${data_dir} ${build_dir}/bin/pg_ctl -D ${data_dir} -l ${data_dir}/logfile start ${build_dir}/bin/psql -U${superuser} postgres -c \"create database ${defaultdb};\" echo \"----------------- all finished -----------------------\" echo \"use ************** \" echo \"[ ${build_dir}/bin/psql -U${superuser} ${defaultdb} ] \" echo \"to connect postgresql\" cd .. ‍"},"title":"Build PostgreSQL From Source"},"/postgresql/column-schema-change/":{"data":{"":"In PostgreSQL, the adding and dropping a column is an instant ddl(This name seems only to be used in mysql, but I like it). In this article, I try to explain the implement of that.\nThe reference:\nhttps://www.postgresql.org/docs/current/sql-altertable.html ","basic-concepts#Basic Concepts":"instant ddl For a table with $n$ tuples, if a ddl post can be performed in time $O(1)$ ,we call this ddl instant. So to implement an instant ddl, the data organization must remain unchanged. Instead, only the schema information can be changed, along withthe method to used to interpret the table’s binary data according to the schema.\nIn this scenario, pg only changes the pg_attribute catalog, which records the attributes[#todo is this OK] of each relations.\nheap page representation Before illustrate the situation where interpreting the binary data with two different schemas, we figure out the way to organize the heap pages."},"title":"Column Schema Change"},"/postgresql/every_data_pg/":{"data":{"":"","0x01-8级锁的不对称性#0x01-8级锁的不对称性":"2024-08-17 00:14:26 +0800\n用于创建索引的 SHARE LOCK，虽然和修改时需要的 ROW EXCL 锁冲突，却不和自己冲突。虽然创建索引时不能插入数据，但是可以创建其他索引。 SHARE 这个名字非常贴切。\n注意：create index 可以事务块中执行\ntest=# begin transaction; BEGIN test=*# insert into test values (1); INSERT 0 1 test=*# create index on test (a); CREATE INDEX test=*# commit; COMMIT 而为了不阻塞读写，持有 SHARE UPDATE EXCL 锁的行为， 例如 vacuum , create index concurrent ，大都不能在事务块中进行。原因可能是这些操作需要感知其他正在执行的事务的状态(status of running processes)，其行为超出了一般意义上 MVCC 的。"},"title":"Everyday PostgreSQL"},"/postgresql/hashjoin/":{"data":{"":"","code-level-detail#Code level Detail":"utility ExecHashGetBucketAndBatch : hash value to bucket number and batch number ExecHashGetBucketAndBatch(HashJoinTable hashtable, uint32 hashvalue, int *bucketno, int *batchno) { uint32 nbuckets = (uint32) hashtable-\u003enbuckets; uint32 nbatch = (uint32) hashtable-\u003enbatch; if (nbatch \u003e 1) { *bucketno = hashvalue \u0026 (nbuckets - 1); ### tricky way as MOD *batchno = pg_rotate_right32(hashvalue, hashtable-\u003elog2_nbuckets) \u0026 (nbatch - 1); ### rotate hashvalue and MOD nbatch } else { *bucketno = hashvalue \u0026 (nbuckets - 1); *batchno = 0; } } ExecHashTableInsert : insert hash value ExecHashTableInsert ExecHashGetBucketAndBatch(hashtable, hashvalue, \u0026bucketno, \u0026batchno); if (batchno == hashtable-\u003ecurbatch) ### put into hash table hashTuple = (HashJoinTuple) dense_alloc hashtable-\u003espaceUsed += hashTupleSize; ### For single batch, we may increase the nbucket if (hashtable-\u003enbatch == 1) if (ntuples \u003e (hashtable-\u003enbuckets_optimal * NTUP_PER_BUCKET) \u0026\u0026 xxx) hashtable-\u003enbuckets_optimal *= 2; hashtable-\u003elog2_nbuckets_optimal += 1; ### For multi-batches, we may increase the batches if (hashtable-\u003espaceUsed + hashtable-\u003enbuckets_optimal * sizeof(HashJoinTuple) + \u003e hashtable-\u003espaceAllowed) ExecHashIncreaseNumBatches() else ### put the tuple into a temp file for later batches ExecHashJoinSaveTuple() ExecHashIncreaseNumBatches : increase batches ExecHashIncreaseNumBatches nbatch = oldnbatch * 2; ### double nbatches ### init/update batchfiles if (hashtable-\u003einnerBatchFile == NULL) hashtable-\u003einnerBatchFile = palloc0_array(BufFile *, nbatch); hashtable-\u003eouterBatchFile = palloc0_array(BufFile *, nbatch); PrepareTempTablespaces(); else hashtable-\u003einnerBatchFile = repalloc0_array() hashtable-\u003eouterBatchFile ### resize nbuckets? if (hashtable-\u003enbuckets_optimal != hashtable-\u003enbuckets) hashtable-\u003enbuckets = hashtable-\u003enbuckets_optimal; hashtable-\u003elog2_nbuckets = hashtable-\u003elog2_nbuckets_optimal; hashtable-\u003ebuckets.unshared = repalloc_array() ### scan through allchunks while (oldchunks != NULL) nextchunk = oldchunks-\u003enext.unshared ### scan through all tuples in the chunk idx = 0 while (idx \u003c oldchunks-\u003eused) HashJoinTuple hashTuple = (HashJoinTuple) (HASH_CHUNK_DATA(oldchunks) + idx); ... ### where should the tuple go? ExecHashGetBucketAndBatch(hashtable, hashTuple-\u003ehashvalue, \u0026bucketno, \u0026batchno); if (batchno == curbatch) ### keep the tuple but copy it into the new chunk copyTuple = (HashJoinTuple) dense_alloc(hashtable, hashTupleSize); hashtable-\u003ebuckets.unshared[bucketno] = copyTuple; else ### dump it out ExecHashJoinSaveTuple() idx += MAXALIGN(hashTupleSize); pfree(oldchunks); oldchunks = nextchunk; ExecHashJoinSaveTuple : save a tuple to a batch file. BufFileWrite(file, \u0026hashvalue, sizeof(uint32)); BufFileWrite(file, tuple, tuple-\u003et_len); ### len is record in MinimalTupleData structure single worker build state MultiExecProcNode MultiExecPrivateHash for (;;) slot = ExecProcNode(outerNode); if (ExecHashGetHashValue()) bucketNumber = ExecHashGetSkewBucket if (bucketNumber != INVALID_SKEW_BUCKET_NO) ### skew tuple ExecHashSkewTableInsert else ExecHashTableInsert\t### normal tuple hashtable-\u003etotalTuples += 1; xxx","high-level-view#high level view":"See Queries in PostgreSQL: 6. Hashing\nOne-pass hash join Note that join in PostgreSql, we scan the right relation first, which means that the right relation is the “inner relation” and the left relation is the outer one. Two-pass hash join Since we can’t allocate as much memory as we want, instead of building a hash table of the entire table, PG split the tables to several batches where all tuples have the same hash value flag.\nBatches are splited by hash value. Use several bits in hash value as a flag so we can put the tuples into different batches.\nThere is a simple optimization that we can build the hash table in the first batch while scanning the inner table, and match the pair while scanning the outer table.\nparallel one-pass hash join With parallel workers, we can\nscan inner table and build shared hash table parallelly scan outer table parallelly Although in most cases, the neck of tp system is disk io, but parallel workers can still advance the speed efficiently. Because:\nIn single process situation, the disk IO is synchronous，which means CPU is in idle while waiting IO. So, in the parallel case, CPU can be utilized more sufficiently. OS may has the technique to load the disk’s content in advance, which is perdicularly useful in sequence scan. So multi-workers can read data file content more efficiently. In hash join, the compute of hash value may cost more CPU resource than normal TP operation. parallel two-pass hash join Same as the basic two-pass hash join, parallel workers build batches parallelly, both in reading from inner/outer tuple and writing data to tmp file. Since no worker can obtain a whole batch’s data in the first scan, the technique described above can be used here.","low-level-complement#Low level complement":"Single process inner join What is inner join\nThis is the simplest join method in hash join. So we introduce a simple hash join state machine here. (See ExecHashJoinImpl for detail )\nSTART WITH: state ==\u003e HJ_BUILD_HASHTABLE case HJ_BUILD_HASHTABLE: state ==\u003e HJ_NEED_NEW_OUTER case HJ_NEED_NEW_OUTER: ### generate a new outer tuple state ==\u003e HJ_NEED_NEW_BATCH ### No more tuple in this batch. ==\u003e HJ_SCAN_BUCKET; ### Find a outer tuple. Can this one matches a inner one? case HJ_SCAN_BUCKET: ### Scan the selected hash bucket for matches to current outer state ==\u003e HJ_NEED_NEW_OUTER ### Whether we can find a match or not, we always generate a new outer tuple. case HJ_NEED_NEW_BATCH: ### Try to advance to next batch state ==\u003e HJ_NEED_NEW_OUTER; ==\u003e FINISH right join To complete right join, we can just emit each outer tuple even if there’s no matched innner tuple.\ncase HJ_SCAN_BUCKET: state ==\u003e HJ_FILL_OUTER_TUPLE ### Can not find a match. Is it a left join? ==\u003e HJ_NEED_NEW_OUTER case HJ_FILL_OUTER_TUPLE: state ==\u003e HJ_NEED_NEW_OUTER; ### Whether emit the outer tuple with null-filled left tuple or not, we always generate a new outer tuple. left join To complete this, we must remember whether a inner tuple has been matched. So\ncase HJ_NEED_NEW_OUTER: state ==\u003e HJ_FILL_INNER_TUPLES ### This batch has been finished, see if there are unmatched inner tuples. ==\u003e HJ_NEED_NEW_BATCH ==\u003e HJ_SCAN_BUCKET case HJ_FILL_INNER_TUPLES: state ==\u003e HJ_NEED_NEW_BATCH ### No more unmatched inner tuples, so start the next batch ==\u003e HJ_FILL_INNER_TUPLES ### return an unmatched inner tuple. summary Until now, we can generate a full state machine in non-parallel mode\nSTART WITH: state ==\u003e HJ_BUILD_HASHTABLE case HJ_BUILD_HASHTABLE: state ==\u003e HJ_NEED_NEW_OUTER case HJ_NEED_NEW_OUTER: ### generate a new outer tuple state ==\u003e HJ_FILL_INNER_TUPLES ### This batch has been finished, see if there are unmatched inner tuples. ==\u003e HJ_NEED_NEW_BATCH ### No more tuple in this batch. ==\u003e HJ_SCAN_BUCKET; ### Find a outer tuple. Can this one matches a inner one? case HJ_SCAN_BUCKET: ### Scan the selected hash bucket for matches to current outer state ==\u003e HJ_FILL_OUTER_TUPLE ### Can not find a match. Is it a left join? ==\u003e HJ_NEED_NEW_OUTER ### Whether we can find a match or not, we always generate a new outer tuple. case HJ_NEED_NEW_BATCH: ### Try to advance to next batch state ==\u003e HJ_NEED_NEW_OUTER; ==\u003e FINISH parallel hash Note that BarrierArriveAndWait will increase current phase. So each phase’s status is not be assigned directly but self-increased.\nLet introduce the state machine first\nSTART WITH: case HJ_BUILD_HASHTABLE: ### If multi-batch, we need to hash the outer relation up front. ExecParallelHashJoinPartitionOuter(node); state ==\u003e HJ_NEED_NEW_BATCH ### Select a batch to work on. case HJ_NEED_NEW_OUTER: ExecParallelHashJoinOuterGetTuple sts_parallel_scan_next case HJ_NEED_NEW_BATCH: ExecParallelHashJoinNewBatch() switch PHJ_BATCH_STATE case PHJ_BATCH_ELECT: ### One backend allocates the hash table ExecParallelHashTableAlloc ### Fall through case PHJ_BATCH_ALLOCATE: ### Wait for allocation to complete and Fall through case PHJ_BATCH_LOAD: ### Start (or join in) loading tuples and Fall through. case PHJ_BATCH_PROBE: ### This batch is ready to probe ExecParallelHashTableSetCurrentBatch return true; case PHJ_BATCH_SCAN: ### detach and go around again case PHJ_BATCH_FREE: state ==\u003e HJ_NEED_NEW_OUTER PHJ_BUILD_ELECT ==\u003e PHJ_BUILD_ALLOCATE ExecParallelHashJoinNewBatch "},"title":"hash join"},"/postgresql/index-in-pg/create-index-basics/":{"data":{"":"","0-概述#0 概述":"本文介绍普通的创建索引的大致过程（或者说 access method 对应的框架），包括从入口函数，到进入对应的 access method 的过程。不包括 access method 的内部实现。分区表，表达式索引等非主要特性这里省略。","1-准备步骤#1 准备步骤":" 权限校验：包括 选择索引名， access method （主要是确认 access method 是否存在） 加锁：shared lock，阻止写入 ","2-创建空索引#2 创建空索引":" 创建 heap heap_create build relcache 创建文件 smgrcreate 记录依赖 向 pg_class , pg_index , pg_attribute 中写入对应的记录 注册对应表的缓存无效信息，会在事务结束时发送 CacheInvalidateRelcache ","3-调用对应的-index-access-method-创建索引#3 调用对应的 index access method 创建索引":"这里和 HOT 关系较大，需要简单展开：\n在 index access method 内部，会使用回调函数 heapam_index_build_range_scan 来扫描 heap，以确定有哪些 tuple 需要被创建索引。\n此时使用的快照为 SnapshotAny ，即所有行都可见。 每当扫描到一个 tuple 时，像执行 vacuum 一样判断该 tuple 是否能被 vacuum。有一个 tuple 对所有事务都不可见 HEAPTUPLE_DEAD，那么显然不需要对他创建索引 如果所有事务都可见 HEAPTUPLE_LIVE，那么显然需要对他创建索引 如果一些事务可见： HEAPTUPLE_RECENTLY_DEAD 被删除了，但是有些事务仍然可以看到？？？ INSERT_IN_PROGRESS 和 DELETE_IN_PROGRESS ：考虑到大部分情况下 create index 语句不会在事务块中执行，这里跳过。 3-1 如何处理 HEAPTUPLE_RECENTLY_DEAD 3-1-1 非 HOT 说明该 tuple 被删除了，但是有一些事务仍然对其可见，那么也需要加入到索引中。否则这些事务后续通过当前创建的索引就无法找到该元组。\n注意：在判断一个表有哪些索引时，使用快照是“最新的快照”，而非当前事务的快照。\n3-1-2 HOT 如果该 tuple 在 HOT 链中，问题就有些棘手。\n此时不方便将 HOT 链破坏掉。（创建索引的时候直接修改 HEAP 中内容确实不算合理） 但如果不破坏，就（必须）将该 tuple 加入到新索引中，而该 HOT 链可能和新索引冲突 为此，PostgreSQL 采取了一种巧妙地方式\n不将该 tuple 加入到新索引中 对于一些仍然可以访问该 tuple 的事务，阻止其使用新索引。 组织的方式为：pg_index 中有字段 indcheckxmin 。当该字段为 true 时，如果有事务像用该索引，需要确保自己的 TransactionXmin （逻辑）大于 pg_index 中对应 tuple 的 xmin\nTransactionXmin 表示当前事务的所有快照中，最小的的 xmin。（快照中， xmin 前的事务都结束了） pg_index 中对应 tuple 的 xmin 表示 该索引创建的 xid 3-2 对 HOT 链上的元组构建索引 由于创建新索引会导致已有的 HOT 链无效，这里还需讨论如何将已有 HOT 链中元组如何构建到索引中。考虑如下情形，现在需要对 y 这一列创建索引，只需要将 tuple_3 加入到索引中(y=2)即可。由于一个 line pointer 只能在一个 HOT 链中，所以此时索引应该指向 lp_1（注意 tuple_1 有 y=1)。\n如果想去“优化“ 新HOT链的长度，让索引指向 lp_2 或者 lp_3，会产生很多问题，例如指向 lp_2，那么此时 tuple_2 还是 heap only tuple 么？"},"title":"create index basics"},"/postgresql/index-in-pg/create-index-concurrently/":{"data":{"":"","draft#draft":"Official document https://www.postgresql.org/docs/current/sql-createindex.html\nCreating an index can interfere with regular operation of a database. Normally PostgreSQL locks the table to be indexed against writes and performs the entire index build with a single scan of the table. Other transactions can still read the table, but if they try to insert, update, or delete rows in the table they will block until the index build is finished. This could have a severe effect if the system is a live production database. Very large tables can take many hours to be indexed, and even for smaller tables, an index build can lock out writers for periods that are unacceptably long for a production system.\nPostgreSQL supports building indexes without locking out writes. This method is invoked by specifying the CONCURRENTLY option of CREATE INDEX. When this option is used, PostgreSQL must perform two scans of the table, and in addition it must wait for all existing transactions that could potentially modify or use the index to terminate. Thus this method requires more total work than a standard index build and takes significantly longer to complete. However, since it allows normal operations to continue while the index is built, this method is useful for adding new indexes in a production environment. Of course, the extra CPU and I/O load imposed by the index creation might slow other operations.\nIn a concurrent index build, the index is actually entered as an “invalid” index into the system catalogs in one transaction, then two table scans occur in two more transactions. Before each table scan, the index build must wait for existing transactions that have modified the table to terminate. After the second scan, the index build must wait for any transactions that have a snapshot (see Chapter 13) predating the second scan to terminate, including transactions used by any phase of concurrent index builds on other tables, if the indexes involved are partial or have columns that are not simple column references. Then finally the index can be marked “valid” and ready for use, and the CREATE INDEX command terminates. Even then, however, the index may not be immediately usable for queries: in the worst case, it cannot be used as long as transactions exist that predate the start of the index build.\nIf a problem arises while scanning the table, such as a deadlock or a uniqueness violation in a unique index, the CREATE INDEX command will fail but leave behind an “invalid” index. This index will be ignored for querying purposes because it might be incomplete; however it will still consume update overhead. The psql \\\\d command will report such an index as INVALID:\nOthers’ blog PostgreSQL create index concurrently原理分析 https://postgrespro.com/blog/pgsql/3994098 https://postgrespro.com/blog/pgsql/4161264 核心问题 两次快照读的原因 怎么“正好只”补充两次快照之间的增量数据？ merge 是怎么实现的？ /* * validate_index - support code for concurrent index builds * * We do a concurrent index build by first inserting the catalog entry for the * index via index_create(), marking it not indisready and not indisvalid. * Then we commit our transaction and start a new one, then we wait for all * transactions that could have been modifying the table to terminate. Now * we know that any subsequently-started transactions will see the index and * honor its constraints on HOT updates; so while existing HOT-chains might * be broken with respect to the index, no currently live tuple will have an * incompatible HOT update done to it. We now build the index normally via * index_build(), while holding a weak lock that allows concurrent * insert/update/delete. Also, we index only tuples that are valid * as of the start of the scan (see table_index_build_scan), whereas a normal * build takes care to include recently-dead tuples. This is OK because * we won't mark the index valid until all transactions that might be able * to see those tuples are gone. The reason for doing that is to avoid * bogus unique-index failures due to concurrent UPDATEs (we might see * different versions of the same row as being valid when we pass over them, * if we used HeapTupleSatisfiesVacuum). This leaves us with an index that * does not contain any tuples added to the table while we built the index. * * Next, we mark the index \"indisready\" (but still not \"indisvalid\") and * commit the second transaction and start a third. Again we wait for all * transactions that could have been modifying the table to terminate. Now * we know that any subsequently-started transactions will see the index and * insert their new tuples into it. We then take a new reference snapshot * which is passed to validate_index(). Any tuples that are valid according * to this snap, but are not in the index, must be added to the index. * (Any tuples committed live after the snap will be inserted into the * index by their originating transaction. Any tuples committed dead before * the snap need not be indexed, because we will wait out all transactions * that might care about them before we mark the index valid.) * * validate_index() works by first gathering all the TIDs currently in the * index, using a bulkdelete callback that just stores the TIDs and doesn't * ever say \"delete it\". (This should be faster than a plain indexscan; * also, not all index AMs support full-index indexscan.) Then we sort the * TIDs, and finally scan the table doing a \"merge join\" against the TID list * to see which tuples are missing from the index. Thus we will ensure that * all tuples valid according to the reference snapshot are in the index. * * Building a unique index this way is tricky: we might try to insert a * tuple that is already dead or is in process of being deleted, and we * mustn't have a uniqueness failure against an updated version of the same * row. We could try to check the tuple to see if it's already dead and tell * index_insert() not to do the uniqueness check, but that still leaves us * with a race condition against an in-progress update. To handle that, * we expect the index AM to recheck liveness of the to-be-inserted tuple * before it declares a uniqueness error. * * After completing validate_index(), we wait until all transactions that * were alive at the time of the reference snapshot are gone; this is * necessary to be sure there are none left with a transaction snapshot * older than the reference (and hence possibly able to see tuples we did * not index). Then we mark the index \"indisvalid\" and commit. Subsequent * transactions will be able to use it for queries. * * Doing two full table scans is a brute-force strategy. We could try to be * cleverer, eg storing new tuples in a special area of the table (perhaps * making the table append-only by setting use_fsm). However that would * add yet more locking issues. ","faq#FAQ":"1 为什么需要保证阶段二中：其他连接的修改不会破坏 HOT ","概述#概述":" 解决的问题： 同步创建索引 create index concurrently 解决了创建索引期间，如何不阻塞正常执行 DML 的问题。 思路： 和 pg_repack , pg_squeeze 等重写表的工具相似，内核中实现的同步创建索引也使用了 “存量 + 增量” 的方式。 不同的是，官方提供的同步创建索引功能，几乎没有和任何其他特性耦合，例如没有使用触发器和逻辑复制。 难点有：\n在不同的字段上，新创建一个索引会破坏 heap 中的原 HOT 链，创建的过程中也会影响到新的 HOT 链。 在不使用触发器和逻辑复制等功能的情况下，如何记录增量数据？ 简单流程：通过三个事务完成\n事务一：创建索引文件和修改系统表。 此时索引为 not read + not valid。但其他 SQL 需要遵循对应的 HOT 规则。 事务二：获取快照 A ，使用对该快照可见的元组创建索引。事务二结束后，其他 SQL 修改表时，也需要修改对应的索引。 事务三：获取快照 B ，将快照 B 可见但快照 A 不可见的元组插入索引 ","阶段一创建空索引#阶段一：创建空索引":"创建空索引的核心原因是：在将存量数据加入的索引中时，确保其他连接的修改不会破坏 HOT（更近一步的原因在阶段 2 描述）。方式为向 pg_index 中记录一个 indisready==false \u0026\u0026 indisvalid==false 的索引。所以问题在于：其他连接如何感知到该索引。\n每个连接都会缓存自己 relcache 和 syscache ，如果没有收到失效信息，这些缓存会一直保留。一般而言，事务开始时，会处理所有的缓存失效消息，在事务的执行的过程中，也有埋点来处理失效信息。但是处理结果不会返回给发送端。\n所以为了保证其他连接都会看到新索引，在创建空索引的事务结束后，需要等到当前所有其他事务全部结束，才能开启第二阶段\n代码实现与上述有所差别：\n“等待其他事务” 并不是通过巡检 ProcArray 等方式实现，而是巧妙的使用了 lmgr 层的 WaitForLockers 实现：即等到没有连接持有该表的与 ShareLock 相冲突的锁：\n/* * Now we must wait until no running transaction could have the table open * with the old list of indexes. Use ShareLock to consider running * transactions that hold locks that permit writing to the table. Note we * do not need to worry about xacts that open the table for writing after * this point; they will see the new index when they open it. */ WaitForLockers(heaplocktag, ShareLock, true); （1）SharedLock 与 select 和 select for update/share 相冲突，持有者两种锁时，都无法破坏 HOT 链。（2）当进程执行修改表的操作时，已经需要打开表获取 relcache ，而在打开表操作时，会处理缓存失效信息。\nrelation_open/try_relation_open -\u003e LockRelationOid -\u003e AcceptInvalidationMessages ","阶段三-增量数据的插入#阶段三： 增量数据的插入":"该步骤的主要工作为把阶段二中遗漏的 tuple 加入索引中。方法为：使用当前的事务快照，将该快照可见的但是索引中没有的元组，加入索引中，具体做法为：\n（一）扫描索引，获取索引中所有的 ctid，并进行排序，得到 Tuplesortstate\n（二）使用当前快照，进行全表扫描，对于每一行，在 Tuplesortstate 搜索对应的 ctid。注意，如果是 heap only tuple，则使用其根 tuple 的 ctid。如果在 Tuplesortstate 中没有找打，则向索引中插入对应的指针。\n举个例子： tuple_3 虽然是在阶段二中新增的 tuple ，但是其根 tuple，即 tuple_1 已经在索引中了，所以在阶段三中忽略。而 tuple_3 不在 HOT 链中，所以需要插入到元组中。\n增量数据插入结束后，仍不能设置 indisvalid=true ：考虑一个元组，它在阶段二中被创建，却在阶段三前被删除，所以此时它仍然不在索引中，但是可能有其他事务（事务 T）可以看到该元组；如果此时修改 indisvalid=true 并提交，那么事务 T 使用该索引时，就无法获取到该元组 。故此时需要等事务 T 结束。：\n所以流程为将增量数据插入元组后，获取当前快照的 xmin，记为 xminlimit，并提交。之后开启新的事物，等待所有含有 snap.xmin\u003cxminlimit 的快照的事务全部提交，再设置 indisvalid=true 并提交。\n提交后，所以事务（包括正在运行的）都可以使用新索引了。","阶段二使用存量数据创建索引#阶段二：使用存量数据创建索引":"在确保所有连接都发现了该索引时，可以使用存量数据创建索引\n该过程和普通的创建索引相似，但是进行 heap 扫描时，使用的快照不同。在一般的索引创建中，使用的是 SnapshotAny ，所有行都可见，而 CIC 中使用的是当前事务的快照。\n问题仍然出现在 HOT 链上，虽然对于创建索引的字段，当前不会产生新的 HOT 链，但是仍然会有旧的 HOT 链 ，所以构建索引的方式和普通地创建索引相同。\n举个例子:\n初始状态有 tuple_1 和 tuple_2 ，以及字段 a 上的索引。现对字段 b 创建建索引， tuple_1 对当前快照不可见（too old） tuple_2 可见。当把 tuple_2 加入到索引中时，索引值为 b=2，但索引入口指向 b=1 的元组（HOT链的开头）， 在阶段2中，有其他事务将 tuple_2 进行成了 tuple_3 ，将 c 改为了 2。该更新满足 HOT （a, b 都没有变），所以仍在 HOT 链上。但是 tuple_3 对当前快照（CIC）不可见 (in feature)，所以不处理。 在阶段2中，有其他事务将 tuple_3 进行成了 tuple_4，将 b 改为了3。该更新不满足 HOT，所以索引 idx_a 需要创建新的指针 当索引构建完毕后，将 pg_index 的中对应行的 indisready 设置为 true，这样其他事务后续修改表时，会同步修改该索引。和阶段1相似，当前事务提交后，开启新的事物（xact3），等到其他事务都感知到 indisready=true 时（同样使用 WaitForLockers 方案），开始阶段三。"},"title":"create index concurrently"},"/postgresql/index-in-pg/heap-only-tuple/":{"data":{"":"","hot-链的构建与清理#HOT 链的构建与清理":"构建 （一）：表 tbl(x int, y int) 在 x 上有索引，先插入一行 tuple_1=(x=1, y=1) ，结果如下\n（二）：当更新 tuple_1 为 (x=1,y=2) 时， 新增 lp_2, 和 tuple_2 ，但是不会新增索引指针，而是由 tuple_1 的 header 会记录 tuple_2 的位置。\n从可见性的角度思考，对于一个快照而言，一个 HOT 链上最多只有一个 tuple 可见。\n所以使用索引扫描时，会先找到 tuple_1 判断 tuple_ 1 是否符合可见性：\n如果 tuple_1 可见，那么立即返回，不在向下搜索。 如果 tuple_1 不可见，再继续向下搜素。 （三）：再更新 tuple_1 为 tuple3=(x=1, y=3)，结果如下\n清理 显然如果一个tuple一直被更新，那么这个链会很长，影响索引搜索的性能，所以需要去清理 HOT 链，清理分为两步，一个是 pruning （修剪），另一个是 defragmentation （碎片整理）\n（四）：pruning （修剪）：等 tuple_1 和 tuple_2 多所有事务都不可见时，则通过修改 line pointers，减少 hot 链的长度。 line pointer 2 可以被其他操作复用，但是 tuple_1 和 tuple_2 占用的空间仍没有被清理。如图：\n（五）：defragmentation （碎片整理）：将对应的 tuple 彻底删除，如图","key-functions#Key functions":"heap_page_prune heap_page_prune_opt Optionally prune and repair fragmentation in the specified page.\nheap_page_prune_opt() { minfree = RelationGetTargetPageFreeSpace(); minfree = Max(minfree, BLCKSZ / 10); if (PageIsFull(page) || PageGetHeapFreeSpace(page) \u003c minfree) { if (!ConditionalLockBufferForCleanup(buffer)) continue; if (PageIsFull(page) || PageGetHeapFreeSpace(page) \u003c minfree) { heap_page_prune(); } } } heap_page_prune Prune and repair fragmentation in the specified page.\nheap_page_prune() { for (offnum = FirstOffsetNumber; offnum \u003c= maxoff; offnum = OffsetNumberNext(offnum)) { heap_prune_chain(\u0026prstate) } if (prstate.nredirected \u003e 0 || prstate.ndead \u003e 0 || prstate.nunused \u003e 0) { heap_page_prune_execute(); } } heap_prune_chain Prune specified line pointer or a HOT chain originating at line pointer.\nheap_prune_chain() { /* while not end of the chain */ for (;;) { lp = PageGetItemId(dp, offnum); /* Unused item obviously isn't part of the chain */ if (!ItemIdIsUsed(lp)) break; if (ItemIdIsRedirected(lp)) { if (nchain \u003e 0) break;\t/* not at start of chain */ chainitems[nchain++] = offnum; offnum = ItemIdGetRedirect(rootlp); continue; } if (ItemIdIsDead(lp)) break; htup = (HeapTupleHeader) PageGetItem(dp, lp); /* * Check the tuple XMIN against prior XMAX, if any */ if (TransactionIdIsValid(priorXmax) \u0026\u0026 !TransactionIdEquals(HeapTupleHeaderGetXmin(htup), priorXmax)) break; /* record each item of this chain */ chainitems[nchain++] = offnum; switch ((HTSV_Result) prstate-\u003ehtsv[offnum]) { case: HEAPTUPLE_DEAD: tupdead = true; break; case HEAPTUPLE_RECENTLY_DEAD: heap_prune_record_prunable(prstate, HeapTupleHeaderGetUpdateXid(htup)); ... } } if (OffsetNumberIsValid(latestdead)) { for (i = 1; (i \u003c nchain) \u0026\u0026 (chainitems[i - 1] != latestdead); i++) { heap_prune_record_unused(prstate, chainitems[i]); ndeleted++; } if (i \u003e= nchain) /* The whole chain is dead */ heap_prune_record_dead(prstate, rootoffnum); else\t/* Or just redirect */ heap_prune_record_redirect(prstate, rootoffnum, chainitems[i]); } } heap_prune_record_redirect\nheap_page_prune_execute Perform the actual page changes needed by heap_page_prune\nvoid heap_page_prune_execute() { /* redirect */ for (int i = 0; i \u003c nredirected; i++) { ItemIdSetRedirect(fromlp, tooff); } /* dead */ for (int i = 0; i \u003c ndead; i++) { ItemIdSetDead(lp); } /* unused */ for (int i = 0; i \u003c nunused; i++) { ItemIdSetUnused(lp); } PageRepairFragmentation(); page_verify_redirects(); } search HOT chain heap_hot_search_buffer search HOT chain for tuple satisfying snapshot\nbool heap_hot_search_buffer() { blkno = ItemPointerGetBlockNumber(tid); offnum = ItemPointerGetOffsetNumber(tid); for (;;) { lp = PageGetItemId(page, offnum); heapTuple-\u003et_data = (HeapTupleHeader) PageGetItem(page, lp); } } ","low-level-design#Low Level Design":"","related-posts#related posts":"postgreSQL HOT From ZhiHu\nOFFICIAL DOC\nFor more details , see postgresql/src/backend/access/heap/README.HOT\nMain Commits:\n282d2a03dd HOT updates 6f10eb2111 Refactor heap_page_prune ","tid#TID":"tuple 通过 t_ctid 字段指向其他 tuple\nline pointer 通过 offset 指向其对应的 tuple","概述#概述":"简单而言, HOT(Heap Only Tuple) 指没有索引指向的元组 用于消除元组更新引起的索引膨胀，原理如下图所示\n索引指向 line_ptr_1 ，line_ptr_1 指向 tuple_1 ，tuple_1 被更新后成为 tuple_2，此时 tuple_1 指向 tuple_2 索引指向 line_ptr_3 , line_ptr_3 指向 line_ptr_4 ，line_ptr_4 指向 tuple3 显然，HOT 技术具有如下优点\n对于被更新的元组，无需创建新的索引指针指向新元组 旧元组可以被“普通操作”删除掉，并不一定需要 vacuum ","清理时机#清理时机":"??（好复杂，后面再说）"},"title":"HOT(Heap Only Tuple)"},"/postgresql/index-in-pg/hot-and-index/":{"data":{"":"","create-index-concurrently-cic-的原理解析#Create Index Concurrently (CIC) 的原理解析":" 解决的问题： 同步创建索引 create index concurrently 解决了创建索引期间，如何不阻塞正常执行 DML 的问题。 思路： 和 pg_repack , pg_squeeze 等重写表的工具相似，内核中实现的同步创建索引也使用了 “存量 + 增量” 的方式。 不同的是，官方提供的同步创建索引功能，几乎没有和任何其他特性耦合，例如没有使用触发器和逻辑复制。 难点有：\n在不同的字段上，新创建一个索引会破坏 heap 中的原 HOT 链，创建的过程中也会影响到新的 HOT 链。 在不使用触发器和逻辑复制等功能的情况下，如何记录增量数据？ 简单流程：通过三个事务完成\n事务一：创建索引文件和修改系统表。 此时索引为 not read + not valid。但其他 SQL 需要遵循对应的 HOT 规则。 事务二：获取快照 A ，使用对该快照可见的元组创建索引。事务二结束后，其他 SQL 修改表时，也需要修改对应的索引。 事务三：获取快照 B ，将快照 B 可见但快照 A 不可见的元组插入索引 阶段一：创建空索引 创建空索引的核心原因是：在将存量数据加入的索引中时，确保其他连接的修改不会破坏 HOT（更近一步的原因在阶段 2 描述）。方式为向 pg_index 中记录一个 indisready==false \u0026\u0026 indisvalid==false 的索引。所以问题在于：其他连接如何感知到该索引。\n每个连接都会缓存自己 relcache 和 syscache ，如果没有收到失效信息，这些缓存会一直保留。一般而言，事务开始时，会处理所有的缓存失效消息，在事务的执行的过程中，也有埋点来处理失效信息。但是处理结果不会返回给发送端。\n所以为了保证其他连接都会看到新索引，在创建空索引的事务结束后，需要等到当前所有其他事务全部结束，才能开启第二阶段\n代码实现与上述有所差别：\n“等待其他事务” 并不是通过巡检 ProcArray 等方式实现，而是巧妙的使用了 lmgr 层的 WaitForLockers 实现：即等到没有连接持有该表的与 ShareLock 相冲突的锁：\n/* * Now we must wait until no running transaction could have the table open * with the old list of indexes. Use ShareLock to consider running * transactions that hold locks that permit writing to the table. Note we * do not need to worry about xacts that open the table for writing after * this point; they will see the new index when they open it. */ WaitForLockers(heaplocktag, ShareLock, true); （1）SharedLock 与 select 和 select for update/share 相冲突，持有者两种锁时，都无法破坏 HOT 链。（2）当进程执行修改表的操作时，已经需要打开表获取 relcache ，而在打开表操作时，会处理缓存失效信息。\nrelation_open/try_relation_open -\u003e LockRelationOid -\u003e AcceptInvalidationMessages 阶段二：使用存量数据创建索引 在确保所有连接都发现了该索引时，可以使用存量数据创建索引\n该过程和普通的创建索引相似，但是进行 heap 扫描时，使用的快照不同。在一般的索引创建中，使用的是 SnapshotAny ，所有行都可见，而 CIC 中使用的是当前事务的快照。\n问题仍然出现在 HOT 链上，虽然对于创建索引的字段，当前不会产生新的 HOT 链，但是仍然会有旧的 HOT 链 ，所以构建索引的方式和普通地创建索引相同。\n举个例子:\n初始状态有 tuple_1 和 tuple_2 ，以及字段 a 上的索引。现对字段 b 创建建索引， tuple_1 对当前快照不可见（too old） tuple_2 可见。当把 tuple_2 加入到索引中时，索引值为 b=2，但索引入口指向 b=1 的元组（HOT链的开头）， 在阶段2中，有其他事务将 tuple_2 进行成了 tuple_3 ，将 c 改为了 2。该更新满足 HOT （a, b 都没有变），所以仍在 HOT 链上。但是 tuple_3 对当前快照（CIC）不可见 (in feature)，所以不处理。 在阶段2中，有其他事务将 tuple_3 进行成了 tuple_4，将 b 改为了3。该更新不满足 HOT，所以索引 idx_a 需要创建新的指针 当索引构建完毕后，将 pg_index 的中对应行的 indisready 设置为 true，这样其他事务后续修改表时，会同步修改该索引。和阶段1相似，当前事务提交后，开启新的事物（xact3），等到其他事务都感知到 indisready=true 时（同样使用 WaitForLockers 方案），开始阶段三。\n阶段三： 增量数据的插入 该步骤的主要工作为把阶段二中遗漏的 tuple 加入索引中。方法为：使用当前的事务快照，将该快照可见的但是索引中没有的元组，加入索引中，具体做法为：\n（一）扫描索引，获取索引中所有的 ctid，并进行排序，得到 Tuplesortstate\n（二）使用当前快照，进行全表扫描，对于每一行，在 Tuplesortstate 搜索对应的 ctid。注意，如果是 heap only tuple，则使用其根 tuple 的 ctid。如果在 Tuplesortstate 中没有找打，则向索引中插入对应的指针。\n举个例子： tuple_3 虽然是在阶段二中新增的 tuple ，但是其根 tuple，即 tuple_1 已经在索引中了，所以在阶段三中忽略。而 tuple_3 不在 HOT 链中，所以需要插入到元组中。\n增量数据插入结束后，仍不能设置 indisvalid=true ：考虑一个元组，它在阶段二中被创建，却在阶段三前被删除，所以此时它仍然不在索引中，但是可能有其他事务（事务 T）可以看到该元组；如果此时修改 indisvalid=true 并提交，那么事务 T 使用该索引时，就无法获取到该元组 。故此时需要等事务 T 结束。：\n所以流程为将增量数据插入元组后，获取当前快照的 xmin，记为 xminlimit，并提交。之后开启新的事物，等待所有含有 snap.xmin\u003cxminlimit 的快照的事务全部提交，再设置 indisvalid=true 并提交。\n提交后，所以事务（包括正在运行的）都可以使用新索引了。","create-index-的流程#Create Index 的流程":"该章节介绍普通的创建索引的大致过程，尤其是缓存一致性和对 HOT 的特殊处理\n1 准备步骤 权限校验：包括 选择索引名， access method （主要是确认 access method 是否存在） 加锁：shared lock，阻止写入 2 创建空索引 创建 heap heap_create build relcache 创建文件 smgrcreate 记录依赖 向 pg_class , pg_index , pg_attribute 中写入对应的记录 注册对应表的缓存无效信息，会在事务结束时发送 CacheInvalidateRelcache 3 调用对应的 index access method 创建索引 这里和 HOT 关系较大，需要简单展开：\n在 index access method 内部，会使用回调函数 heapam_index_build_range_scan 来扫描 heap，以确定有哪些 tuple 需要被创建索引。\n此时使用的快照为 SnapshotAny ，即所有行都可见。 每当扫描到一个 tuple 时，像执行 vacuum 一样判断该 tuple 是否能被 vacuum。有一个 tuple 对所有事务都不可见 HEAPTUPLE_DEAD，那么显然不需要对他创建索引 如果所有事务都可见 HEAPTUPLE_LIVE，那么显然需要对他创建索引 如果一些事务可见： HEAPTUPLE_RECENTLY_DEAD 被删除了，但是有些事务仍然可以看到？？？ INSERT_IN_PROGRESS 和 DELETE_IN_PROGRESS ：考虑到大部分情况下 create index 语句不会在事务块中执行，这里跳过。 3-1 如何处理 HEAPTUPLE_RECENTLY_DEAD 3-1-1 非 HOT 说明该 tuple 被删除了，但是有一些事务仍然对其可见，那么也需要加入到索引中。否则这些事务后续通过当前创建的索引就无法找到该元组。\n注意：在判断一个表有哪些索引时，使用快照是“最新的快照”，而非当前事务的快照。\n3-1-2 HOT 如果该 tuple 在 HOT 链中，问题就有些棘手。\n此时不方便将 HOT 链破坏掉。（创建索引的时候直接修改 HEAP 中内容确实不算合理） 但如果不破坏，就（必须）将该 tuple 加入到新索引中，而该 HOT 链可能和新索引冲突 为此，PostgreSQL 采取了一种巧妙地方式\n不将该 tuple 加入到新索引中 对于一些仍然可以访问该 tuple 的事务，阻止其使用新索引。 组织的方式为：pg_index 中有字段 indcheckxmin 。当该字段为 true 时，如果有事务像用该索引，需要确保自己的 TransactionXmin （逻辑）大于 pg_index 中对应 tuple 的 xmin\nTransactionXmin 表示当前事务的所有快照中，最小的的 xmin。（快照中， xmin 前的事务都结束了） pg_index 中对应 tuple 的 xmin 表示 该索引创建的 xid 3-2 对 HOT 链上的元组构建索引 由于创建新索引会导致已有的 HOT 链无效，这里还需讨论如何将已有 HOT 链中元组如何构建到索引中。考虑如下情形，现在需要对 y 这一列创建索引，只需要将 tuple_3 加入到索引中(y=2)即可。由于一个 line pointer 只能在一个 HOT 链中，所以此时索引应该指向 lp_1（注意 tuple_1 有 y=1)。\n如果想去“优化“ 新HOT链的长度，让索引指向 lp_2 或者 lp_3，会产生很多问题，例如指向 lp_2，那么此时 tuple_2 还是 heap only tuple 么？","hot-基础#HOT 基础":"简单而言, HOT(Heap Only Tuple) 指没有索引指向的元组，用于消除元组更新引起的索引膨胀，原理如下图：\n索引指向 line_ptr_1 ，line_ptr_1 指向 tuple_1 ，tuple_1 被更新后成为 tuple_2，此时 tuple_1 指向 tuple_2 索引指向 line_ptr_3 , line_ptr_3 指向 line_ptr_4 ，line_ptr_4 指向 tuple3 显然，HOT 技术具有如下优点\n对于被更新的元组，无需创建新的索引指针指向新元组 旧元组可以被“普通操作”删除掉，并不一定需要 vacuum HOT 链的构建 （一）：表 tbl(x int, y int) 在 x 上有索引，先插入一行 tuple_1=(x=1, y=1) ，结果如下\n（二）：当更新 tuple_1 为 (x=1,y=2) 时， 新增 lp_2, 和 tuple_2 ，但是不会新增索引指针，而是由 tuple_1 的 header 会记录 tuple_2 的位置。\n从可见性的角度思考，对于一个快照而言，一个 HOT 链上最多只有一个 tuple 可见。\n所以使用索引扫描时，会先找到 tuple_1 判断 tuple_ 1 是否符合可见性：\n如果 tuple_1 可见，那么立即返回，不在向下搜索。 如果 tuple_1 不可见，再继续向下搜素。 （三）：再更新 tuple_1 为 tuple3=(x=1, y=3)，结果如下\n清理 显然如果一个tuple一直被更新，那么这个链会很长，影响索引搜索的性能，所以需要去清理 HOT 链，清理分为两步，一个是 pruning （修剪），另一个是 defragmentation （碎片整理）\n（四）：pruning （修剪）：等 tuple_1 和 tuple_2 多所有事务都不可见时，则通过修改 line pointers，减少 hot 链的长度。 line pointer 2 可以被其他操作复用，但是 tuple_1 和 tuple_2 占用的空间仍没有被清理。如图：\n（五）：defragmentation （碎片整理）：将对应的 tuple 彻底删除，如图","概述#概述":"本文介绍 PostgreSQL 中 Heap Only Tuple(HOT) 技术以及创建索引相关的知识，主要包含以下内容：\nHOT 的基本原理 普通的创建索引 (Create Index) 流程 同时创建索引 (Create Index Concurrently CIC) 的原理 本文不包括：\nbtree 等索引的具体实现方式 PostgreSQL 对索引访问方式 (Access Method) 的抽象 "},"title":"Hot and Index"},"/postgresql/pg_repack/":{"data":{"":"","details#details":"Although the idea is so simple, there are many problems to challenge. Such as how to ensure there are no duplicated or lost data in both existent part and incremental part. So code-level details are shown below:\nAll the 7 step are manipulated through 2 connections: See function repack_one_table for detail:\ncreate a log table to record changes made to the original table\nadd a trigger onto the original table, logging INSERTs, UPDATEs and DELETEs into our log table\nconn1 starts a transaction and acquire an advisory lock to prevent potential conflict with other repack process get the AccessiveExclusive lock to the original table, tbl for example create the trigger on tbl and the corresponding log-table where the incremental changes will be stored. (Just comments: If we release the exclusive lock here, we may not able to acquire a shared lock later if another process has gotten a exclusive lock in the interval, which can cause that we have no way to continue or revert what we have done. So we must acquire a lock during the whole process. 👌) conn2 tries to acquire the AccessiveShared lock on tbl. Since the conn1 ’s transaction hasn’t finished, this lock acquisition will be blocked. conn1 kill all connections that tries to perform a DDL operation, whose character is waiting for AccessiveLock . Then, conn1 commits. Now conn2 get the AccessiveShared lock on tbl , which can ensure that no other dll operation on tbl ✌️ create a new table containing all the rows in the old table\nconn1 begins a serializable transaction( repeatable read, at least)\nconn1 get the vxids of current active transactions\nconn1 delete all data in tbl with the current snapshot (This means we don’t perform a “truncate” operation ). This is a very skillful technique:\nThe table shows the secret:\ntbl log table visible existent data empty invisible incremental data incremental data All existent data is visible in tbl through the current snapshot\nAll incremental data is invisible in log table and tbl (The latter one isn’t important\nSo there is no lost or duplicated data\nconn1 copies all data in tbl to a temp table tbl-tmp for example\nconn1 commits\nbuild indexes on this new table. (I don’t care this.)\napply all changes which have accrued in the log table to the new table\nconn1 apply at most 1000 records in log-table , until the remaining records are few. AND All transactions in vxids finish. This operation is to keep the ISOLATION, but it still has some accidence. #TODO (Just comments: Now we believe that there is few records in log-table .) conn2 acquire the AccessiveExclusive lock. Note that no other process can do that conn2 apply all data in log-table swap the tables, including indexes and toast tables, using the system catalogs\nconn2 swaps relfilenode between tbl-tmp and tbl conn2 commits drop the original table\nconn1 drop the current tbl-tmp conn1 analyze the current tbl conn1 release the advisory lock ","principle#principle":"pg_repack 1.5.0 – Reorganize tables in PostgreSQL databases with minimal locks\nhttps://github.com/reorg/pg_repack\ncreate a log table to record changes made to the original table add a trigger onto the original table, logging INSERTs, UPDATEs and DELETEs into our log table create a new table containing all the rows in the old table build indexes on this new table apply all changes which have accrued in the log table to the new table swap the tables, including indexes and toast tables, using the system catalogs drop the original table The basic idea is\ntransport the existent data with a old snapshot record the incremental data into a table and replay the record And this idea is so general that almost all online-ddl ability in PG(supported in extensions) takes the way."},"title":"pg_repack"},"/postgresql/pgvector/":{"data":{"":"","hnsw#HNSW":"概览 HNSW 算法主要包括以下几个步骤\n索引构建 构建层级邻近图 每一层都是邻近图 —— 每个点都记录它最近的几个点 高一层的图是低一层图的缩略图 —— 只有低一层图的部分点 ——，最低一层的图有全部点的信息。 查询阶段，对于目标点$p$ 对于每一层图： 维护一个图中距点$p$最近的点集合$S$，依次从候选点集合$C$中选取一个元素$c$：如果$c$的邻居$neighbor(c)$比$S$中距$p$最远的点$s$距$p$更近，即$d(neighbor(c), p) \u003c d(s,c)$ ，则用$neighbor(c)$替换集合$S$中的点$s$，并将$s$加入到候选集合$C$中。重复以上步骤直到$|c| = 0$ 从高层图向底层图搜索，使用高层图的结果$S$作为低层图$S$和$C$的初始值。 算法介绍 一下顺序只是为了便于理解，不代表论文发布顺序。更多细节可参考论文。\nNSW —— HNSW的起源? NSW可以视为邻近图，每个点维护至多$K$个距离其最近的点，此时HNSW退化为只有一层的特殊情况。\nNSW的构建 构建NSW的算法如下（此处忽略边角情况以方便理解\nINPUT: a set of points S OUTPUT: graph G BUILD_LAYER(S) G = [] # Insert each point into the graph FOREACH point IN S: ---------- INSERT_POINT(graph, point) neighbors[] = select_one_random(G) candidate[] = neighbors[] visited_points[] = neighbors[] # Code in this WHILE loop is to find the neighbors of the point # in current graph WHILE (!candidate.empty()) nearest_candidate = candidate.pop_nearest(point) furthest_neighbor = neighbors.get_furthest(point) # no candidate can b closer IF (distant(nearest_candidate, point) \u003e distant(furthest_neighbor, point)) break; # This candidate is great, but what about its neighbors? FOREACH candidate_neighbor in nearest_candidate.neighbors() IF (visited_points.has(candidate_neighbor)) continue visited_points.append(candidate_neighbor) # the furthest one can be changed furthest_neighbor = neighbors.get_furthest(point) # The neighbor of this candidate is also great, its neighbors # can also be candidates IF (distant(candidate_neighbor, point) \u003c distant(furthest_neighbor, point)) candidate.append(candidate_neighbor) neighbors.append(candidate_neighbor) IF (neighbors.size() \u003e MAX_NEIGHBORS) neighbors.pop_furthest(point) # Now we have found the neighbors, add a bidirection connections # between the each neighbor and the point FOREACH this_neighbor in neighbors add_bidirection_direction(this_neighbor, point) # Since the neighbor has one more connection, we may need # to shrink. This is a point to optimize. Read paper for detail. IF this_neighbor.neighbors().size() \u003e MAX_NEIGHBORS this_neighbor.drop_longest_connection() # All points have been added RETURN G NSW的搜索 OUTPUT: graph G, point P RETURN K nearest neighbors SEARCH_LAYER(G, p, K) candidates = select_one_random(G) visited_points = candidates # LOOP until we have K stable points WHILE TRUE candidates_old = candidates FOREACH candidate in candidates FOREACH neighbor in candidate.neighbors() if (visited_points.has(neighbor)) continue visited_points.add(neighbor) furthest_candidate = candidates.get_furthest(point) IF (distant(neighbor, P) \u003c distant(furthest_candidate, P) || candidates.size() \u003c K) candidates.add(neighbor) IF (candidates.size() \u003e K) candidates.pop_furthest(P) IF candidates_old == candidates BREAK RETURN candidates HNSW —— NSW的进化 显然，上述过程最大的问题之一为：\n对于图的构建：每新加入一个点，都需要从一个随机点开始搜索它的邻居。 对于图的搜索：需要从一个随机点开始搜索。 以上两点导致，NSW算法搜索了很多无用的点。 H(hierarchy)NSW 为解决这个问题，从NSW图（layer=0）中选出部分点，再构建一个缩略的NSW图（layer=1）。在搜索的时候，只需要从layer=1的图中搜索出一个粗略结果，将该结果用于layer=0搜索过程中的初始化，即可大量减少无用的搜索。同理，层数也不一定只有2层，可以有更多。 （这个思想在科研中似乎经常使用:先得出一个粗略的结果，再进一步精细化） 为了构建一个这样的图，我们在插入一个点时。\nINPUT: point P, a series of NSW graph G[] cur_layer = -ln(unif(0, 1)) * MAX_LAYER # for layer upper than current layer, just get a candidate FOR l from MAX_LAYER to cur_layer + 1 closest_points = SEARCH_LAYER(G[l], P, 1, candidates = closest_point) # insert into each layer from top to bottom of the below layers FOR l from cur_layer to 0 closest_points = SEARCH_LAYER(G[l], P, 1, candidates = closest_points) INSERT_POINT(graph, P, neighbors = closest_points) 同理在搜索时\nINPUT: point P, a series of NSW graph G[] cur_layer = P.layer # for layer upper than current layer, just get a candidate FOR l from MAX_LAYER to cur_layer + 1 closest_points = SEARCH_LAYER(G[l], P, 1, candidates = closest_point) # for layer leq than current layer, just get a candidate FOR l from cur_layer to 0 closest_points = SEARCH_LAYER(G[l], P, 1, candidates = closest_point) return closest_points PGVECTOR中的算法实现 INSERT /* * Algorithm 1 from paper: update graph by inserting an element * Parms: * @element: element to insert * @entryPoint: the initial entry point * @index? * @procinfo * @collation * @m: same as \"M\" in algo(number of established connections) */ HnswInsertElement(HnswElement element, HnswElement entryPoint, Relation index, FmgrInfo *procinfo, Oid collation, int m, int efConstruction, bool existing) level = element-\u003elevel; q = PointerGetDatum(element-\u003evec) # fill entry point list with the initial one ep = list_make1(HnswEntryCandidate(entryPoint,)) # for layers upper than the element's level for (int lc = entryLevel; lc \u003e= level + 1; lc--) # only get the nearest element now w = HnswSearchLayer() ep = w; # for the below layers for (int lc = level; lc \u003e= 0; lc) # search for top efConstruction nearest ones w = HnswSearchLayer(efConstruction) lw = w # get neighbors neighbors = SelectNeighbors(lw, lm, lc, procinfo, collation, NULL); # add connection # Is this different from paper? # bidirectional vs single directional # shrink directions or not shrink AddConnections() foreach(lc2, neighbors) a-\u003eitems[a-\u003elength++] = *((HnswCandidate *) lfirst(lc2)); search layer /* * Algorithm 2 from paper: search this layer with specifiyed enter points to * return \"ef\" closest neighbors * Parms: * @q: same as algo * @ep: enter points * @ef: count of closest neighbors * @lc: layer number * @index: * @procinfo: * @collation: * @inserting: * @skipElement: */ List * HnswSearchLayer(Datum q, List *ep, int ef, int lc, Relation index, FmgrInfo *procinfo, Oid collation, int m, bool inserting, HnswElement skipElement) v = NULL. # visited points C = NULL # set of candidates, nearer first W = NULL # dynamic found nearest neighbors # for each candidate in enter points foreach(lc2, ep) hc = (HnswCandidate *) lfirst(lc2); # HNSW candidates v.add(hc) C.add(hc) W.add(hc) # loop until no more candidates while (!C.empty()) c = C.pop_nearest() # for each neighbor \"e\" in the nearest candicate \"c\" neighborhood = \u0026c-\u003eelement-\u003eneighbors[lc]; for (int i = 0; i \u003c neighborhood-\u003elength; i++) # neighbor e HnswCandidate *e = \u0026neighborhood-\u003eitems[i]; v.add(e) DO # continue if visited # f is the furthest element in dynamic neighbors f = W.furthest() # find a good neighbor who is closer to q than the worst one in W if (DISTANT(e, q) \u003c DISTANT(f, q) || wlen \u003c ef) ec = e # neighbor of ec can also be the candidates C.add(ec) # add ec to W to promote the lower bound W.add(ec) # clean W if it's too large if (skipElement == NULL || list_length(e-\u003eelement-\u003eheaptids) != 0) wlen++; /* No need to decrement wlen */ if (wlen \u003e ef) W.pop_furthest return W pairing heap 配对堆 - OI Wiki (oi-wiki.org)\ninsert($\\mathrm{log}n$) random_select($\\mathrm{log} n$) select_min($\\mathrm{log} n$) delete_min($\\mathrm{log} n$) select neighbors /* * Algorithm 4: select neighbors starting with specified candidates * PARAMS: * @c : candidates * @m : number of neighbors to return * @lc: layer number * @ * * NOTES: * extendCandidates = false * keepPrunedConnections = true * pruned */ static List * SelectNeighbors(List *c, int m, int lc, FmgrInfo *procinfo, Oid collation, HnswCandidate * *pruned) r = NULL # results---returning neighbors w = c # working candidates wd = NULL; # discarded candidates; # Since we don't extend candidates, if the starting candidates isn't enought # just return. if (list_length(w) \u003c= m) return w # loop untils no more working candidate or enought neighbors while (length(w) \u003e 0 \u0026\u0026 length(r) \u003c m) *e = llast(w); # get the nearest candidates closer = CheckElementCloser(e, r, lc, procinfo, collation); if(closer) r.append(e) else wd.append(e) # loop until discarded candidates are empty or enough neighbors while (!wd.empty() \u0026\u0026 length(r) \u003c m) r.append(wd.pop_nearest()) prune = wd.nearest() return r data structure typedef struct HnswElementData { List\t*heaptids; uint8\tlevel; uint8\tdeleted; HnswNeighborArray *neighbors; BlockNumber blkno; OffsetNumber offno; OffsetNumber neighborOffno; BlockNumber neighborPage; Vector\t*vec; }\tHnswElementData; typedef struct HnswCandidate { HnswElement element; float\tdistance; }\tHnswCandidate; typedef struct HnswNeighborArray { int\tlength; HnswCandidate *items; }\tHnswNeighborArray; 底层实现中的问题 论文中的图是双向连接，而pgvector实现的是单向连接 pgvector中插入新向量时，没有更新其邻居的连接。（这么低级的问题有待验证） page representation ","ivfflat#IVFFlat":"概览 IVFFlat 算法主要包括以下几个步骤\n索引构建阶段 使用 KMeans 将数据集划分成多个簇(cluster) 查询阶段 通过每个簇的中心点（向量是高维的点）获取N个最近的簇 遍历这N个簇的所有点，从中找到最近的K个点 算法介绍 基础算法kmeans reference k-means clustering - Wikipedia 算法目标：选取K个中心点，使得数据集中的所有点到其最近的中心点“距离”之和最近，以平方和距离为例：\nGiven a set of observations $(x_1, x_2, \\dots, x_n)$, where each observation is a $d$-dimensional real vector, k-means clustering aims to partition the $n$ observations into $k$ ($\\leq n$) sets $S = {S_1, S_2, \\dot, S_k}$ so as to minimize the within-cluster sum of squares (WCSS). Formally, the objective is to find: 算法过程： 我们可以很容易的证明目标函数是关于$S$的凸函数 Given an initial set of $k$ means $m_1^{1}, \\dots , m_k^{(1)}$ (see below), the algorithm proceeds by alternating between two steps:\nAssignment step: Assign each observation to the cluster with the nearest mean: where each $x_p$is assigned to exactly one $S^{t}$, even if it could be assigned to two or more of them.\nUpdate step: Recalculate means (centroids) for observations assigned to each cluster.\nkmeans 优化篇 上述算法虽然简洁，但计算上复杂度高。在pgvector的IVFFlat实现中，使用了一些优化算法，主要是如下两篇论文：\nUsing Triangle Inequality: 使用三角不等式减少两点间距离的计算次数 KMeans++ :使用随机点的选取技巧来提高收敛速度和准确率 Using the Triangle Inequality to Accelerate k-Means (aaai.org) kMeansPP-soda.pdf (stanford.edu) Using Triangle Inequality 思路：\n在高维向量中，计算一次两点之间的距离的代价较高。 根据一些朴素的思想，假如使用的距离函数满足三角不等式$d(a,b) \\leq d(a,c) + d(b,c)$，那么在一次kmeams迭代中，如果点 x 距其中心点 c(x) 的距离很近，而 c(x) 距另一个中心点 c(y) 的距离很远，那么c(y)必然不是x 的中心点，这样就可以避免一次计算。 根据三角不等式可以推出\nLet x be a point and let b and c be centers. If $d(b, c) \u003e 2d(x,b)$, then $d(x,c) \\geq d(x,b)$ Let x be a point and let b and c be centers, then $d(x,c) \\geq \\mathrm{max} {0,d(x,b)-d(b,c)}$ 根据上述定理，在Kmeans迭代期间，维护一些状态，即可减少计算量 过程如\n使用三角不等式优化Kmeans\nKMeans++ 论文中的数学分析很多，其主要目的为：通过在初始化的时候选取恰当的中心点，减少迭代次数。方法为： 假设向量的全集为$X={x_1,x_2,\\dots,x_n}\\subset \\mathbb{R}^d$ ,$D(x)$ 表示点 $x$ 到其当前中心点的距离\n从$X$ 中随机选择一个点$c_1$ 以$\\frac{D(x’)}{\\sum_{x\\in X}D(x)}$ 的概率选择$x’$为$c_i$ 重复上一步直到我们选择了 $k$ 个中心点， 使用标准的k-means算法进行后续处理 实现介绍 page representation Key functions index build 索引构建分为以下几个步骤\n计算中心点 构建元信息页（‘meta page’） 构建中心点页（‘centerid pages’） 构建数据页（‘data pages’） ivfflatbuild BuildIndex InitBuildState ComputeCenters CreateMetaPage CreateListPages CreateEntryPages FreeBuildState 计算中心点 实现上，没有扫描所有的行以计算中心点，而是“采样”一些block。 会选择$ncenter \\times 50$ 作为采样block的数量 ComputeCenters SampleRows /* The number of target samples is the number of centers times 50 */ numSamples = buildstate-\u003elists * 50; buildstate-\u003esamples = VectorArrayInit(numSamples, buildstate-\u003edimensions); BlockSampler_Init \u003e provides algorithm for block level sampling of a relation as discussed on pgsql-hackers 2004-04-02 (subject \"Large DB\") Since we know the total number of blocks in advance, we can use the straightforward Algorithm S from Knuth 3.4.2, rather than Vitter's algorithm. reservoir_init_selection_state while (BlockSampler_HasMore(\u0026buildstate-\u003ebs)) table_index_build_range_scan: callback=SampleCallback IvfflatKmeans # Do as kmeans algrithm if (samples-\u003elength \u003c= centers-\u003emaxlen) QuickCenters(index, samples, centers); else ElkanKmeans(index, samples, centers); SampleCallback AddSample if (samples-\u003elength \u003c targsamples) VectorArraySet else if (buildstate-\u003erowstoskip \u003c 0) rowstoskip = reservoir_get_next_S #skip some future samples else k = sampler_random_fract VectorArraySet\t# replace a old with this one randomly 构建元信息页 CreateMetaPage # info about meta information IvfflatNewBuffer IvfflatInitRegisterPage IvfflatCommitBuffer 构建中心点页 当一个页的剩余空间不够时，使用字段nextblkno指向下一个页\ntypedef struct IvfflatPageOpaqueData { BlockNumber nextblkno; uint16\tunused; uint16\tpage_id;\t/* for identification of IVFFlat indexes */ }\tIvfflatPageOpaqueData; CreateListPages # info about center infomation foreach sampled vector if (PageGetFreeSpace \u003c listSize) # we need more free space to store the vector IvfflatAppendPage newbuf = IvfflatNewBuffer newpage = GenericXLogRegisterBuffer IvfflatPageGetOpaque old_page-\u003enext = this_page IvfflatInitPage PageAddItem # copy this point to the page 构建数据页 CreateEntryPages # omit parallel optimization here AssignTuples # Scan table for tuples to index tuplesort_performsort InsertTuples for (int i = 0; i \u003c buildstate-\u003ecenters-\u003elength; i++) buf = IvfflatNewBuffer(index, forkNum); # add new page for each data page list startPage = BufferGetBlockNumber(buf); # the first page number foreach tuple in this list: if (PageGetFreeSpace(page) \u003c itemsz) # append page IvfflatAppendPage(index, \u0026buf, \u0026page, \u0026state, forkNum); PageAddItem() IvfflatUpdateList(); # update the first page record of the center page index scan begin scan ivfflatbeginscan IvfflatGetMetaPageInfo(index, \u0026lists, \u0026dimensions); # Get lists and dimensions from metapage get tupele ivfflatgettuple if (first) # try to get the first tuple GetScanLists # find 'probe' centers that are closest while (BlockNumberIsValid(nextblkno)) # search all list pages if (distance \u003c maxDistance) # omit probe here for easier understanding scanlist = (IvfflatScanList *) pairingheap_remove_first(so-\u003elistQueue); pairingheap_add(so-\u003elistQueue, \u0026scanlist-\u003eph_node); maxDistance = ((IvfflatScanList *) pairingheap_first(so-\u003elistQueue))-\u003edistance; GetScanItems # find closest items in the above centers while (!pairingheap_is_empty(so-\u003elistQueue)) # for each center while (BlockNumberIsValid(searchPage)) # for each block in the data list foreach (tuple) tuplesort_puttupleslot ","vector-database-调研#vector database 调研":"qdrant Vector databases are optimized for storing and querying these high-dimensional vectors efficiently, and they often using specialized data structures and indexing techniques such as Hierarchical Navigable Small World (HNSW) – which is used to implement Approximate Nearest Neighbors – and Product Quantization, among others.\n算法与存储 qdrant使用 hnsw 算法\nA key feature of Qdrant is the effective combination of vector and traditional indexes. It is essential to have this because for vector search to work effectively with filters, having vector index only is not enough. In simpler terms, a vector index speeds up vector search, and payload indexes speed up filtering.\npayload 索引仅用于过滤，我们关注向量索引部分\nQdrant currently only uses HNSW as a vector index.\nAll data within one collection is divided into segments. Each segment has its independent vector and payload storage as well as indexes.","后记#后记":" pg官方的新闻：PostgreSQL: pgvector 0.5.0 Released! 。pgvector在社区的热度不小 ","序言#序言":"pgvector是一个向量搜索（根据近似度）的插件，用来加速AKNN（approximate nearest neighbor）。 PASE中提到，向量ANN算法包括4类\ntree-based algorithms KD-Tree RTree quantization-based algorithms IVFFlat IVFADC IMI graph based algorithms HNSW NSG SSG hash-base algorithms LSH pgvector 包括两个算法，IVFFlat 和 HNSW，后续内容将以这两个算法的内容及其实现展开。 ","附录#附录":"trianlge-inequality-Kmeans 维护的状态： lower bound $l(x,c)$ of $d(x,c)$ for each point $x$ and center $c$ each time $d(x,c)$ is computed, set $l(x,c)=d(x,c)$ $c(x)= \\mathrm{argmin}_cd(x,c)$ get its center for each point $x$ upper bound $u(x)$ of $d(x,c)$ for each point $x$, indicating the upper bound of $x$ to its center $r(x)$ is a boolean value indicate whether $u(x, c)$ is out of date 过程： initialization compute $d(x,c)$ for each point $x$ and each center $c$, which means $l(x,c)$ is computed too $u(x)=\\mathrm{min}_c(d,c)$ for each point $x$ repeate until convergence: For each pair of centers $c$ and $c’$ , compute $d(c,c’)$, this is to compute $s(c)=1/2\\min_{c’\\neq c}d(c,c’)$ . So we get the distance to the nearest center of each center identify all point $x$ such that $u(x) \\le s(c(x))$ .If the point is so near to its center, its center can’t be changed in this iteration. See lemma 1 For each remaining point $x$ and centers $c$ such that $c\\neq c(x)$ (not the current center) and $u(x)\u003el(x,c)$ (upper bound to current center greater than lower bound of this center) and $u(x)\u003e\\frac{1}{2}d(c(x),c)$(upper bound to current center greater than half of the two centers distant, See lemma 1) iterm 2 and 3 means $u(x)$ may be too big DO: If $r(x)$ , compute$d(x, c(x))$ and set $r(x)=false$, else $d(x,c(x))=u(x)$ if $u(x)\u003el(x,c)$ and $u(x)\u003e\\frac{1}{2}d(c(x),c)$ then (same as the above) compute $d(x,c)$, if $d(x,c) \u003c d(x,c(x))$ then assign $c(x)=c$ (update center) For each center $c$ , let $m(c)$ be the new mean point For each point $x$ and center $c$, assign $l(x,c)=\\max{l(x,c)-d(c,m(c))}$ (update lower bound by lemma 2) For each point x, assign $u(x)=u(x) + d(m(c(x)),c(x))$ (update lower bound by lemma 2 ) and $r(x)=true$ Replace each center $c$ by $m(c)$ 采样算法 Knuth’s algorithm S 算法描述： Select $n$ items from a set of $M$ iems with equal probility for $M \\geq n$ 实现 samples = set[0:n-1] for i in (n, M) with prob = n/i: samples[random()%n] = set[i] 参考文档 Knuth’s algorithm S - Rosetta Code 。\n社区讨论 [PostgreSQL: Re: GENERAL] Large DB"},"title":"PGVECTOR AND VECTOR DATABASE"},"/postgresql/sequence_type/":{"data":{"background#background":"From official documents:\n9.17. Sequence Manipulation Functions\nCREATE SEQUENCE\nSequence objects are special single-row tables created with CREATE SEQUENCE. Sequence objects are commonly used to generate unique identifiers for rows of a table. The sequence functions, provide simple, multiuser-safe methods for obtaining successive sequence values from sequence objects. ","main-function#Main function":"There is no much concerns about these functions\nnextval\nAdvances the sequence object to its next value and returns that value setval\nSome examples SELECT setval(‘myseq’, 42); Next nextval will return 43 SELECT setval(‘myseq’, 42, true); Same as above SELECT setval(‘myseq’, 42, false); Next nextval will return 42 currval\nReturns the value most recently obtained by nextval for this sequence in the current session lastval\nReturns the value most recently returned by nextval in the current session. This function is identical to currval, except that instead of taking the sequence name as an argument it refers to whichever sequence nextval was most recently applied to in the current session. ** There is a caution: **\nThere is no rollback of the sequence type. Official document is post below:\nTo avoid blocking concurrent transactions that obtain numbers from the same sequence, the value obtained by nextval is not reclaimed for re-use if the calling transaction later aborts. This means that transaction aborts or database crashes can result in gaps in the sequence of assigned values. That can happen without a transaction abort, too. For example an INSERT with an ON CONFLICT clause will compute the to-be-inserted tuple, including doing any required nextval calls, before detecting any conflict that would cause it to follow the ON CONFLICT rule instead. Thus, PostgreSQL sequence objects cannot be used to obtain “gapless”（无缝的） sequences.","most-important#Most important":"All things above doesn’t worth a post, but the replication hack of this type does. Considering a master-standby example, the currval in standby is always bigger than the master’s. And once the value in master advances and the new value doesn’t precede the standby’s one, the currval in standby would’t advanced immediately. This is a greate skill to reduce the wal records.","sequence-type#sequence type":"sequence type"},"title":"pg_squeence_type"},"/postgresql/slru/clog/":{"data":{"":"","extend-and-truncate#Extend And Truncate":"During the process of generating a new xid, we make sure that the slru page exists.\nIf it’s the first xid of the page, we allocate a new page in clog buffer. Also generate a WAL to record the birth of the page. If not, the page must exist in memory or flushed into disk. So it’s for slru layer to manage such situation. Keep in mind that the general self-increment xid does’t begin at zero:\n#define FirstNormalTransactionId\t((TransactionId) 3) so:\nDuring bootstrap, initialize the first clog page During extend new pages, be careful about the FirstNormalTransactionId, since it is not the first xid in page representation but the first general one. The above behaviors indicate that although a clog segment at most occupies 256K space, it doesn’t have such size just after initialization. We extend 8K pages one by one during the xid increment.\nSince at most half of uint32 xids can be in use, it’s natural to clean up out of date clog files. Different from extending a page, we always delete a whole page. So once we promote the frozenxid, we try to find some clog files to delete:\nThe judgement whether there is a file can be deleted is completed in slru layer(a loop to scan the directory), but clog layer supports a hook to judge one file. Advance the oldest clog xid in shared memory Generate a clog truncate WAL record Real truncate. Complemented in slru layer. Details of the two kind WAL record will be shown later.","in-disk-representation#In-Disk Representation":"Thinking that the commit status of each transaction composites an array clog[] and clog[xid] records the status, we can easily store the array to disk by the slru.\nThe status of one transaction needs two bits to represent:\n#define CLOG_BITS_PER_XACT\t2 #define CLOG_XACTS_PER_BYTE 4 #define CLOG_XACTS_PER_PAGE (BLCKSZ * CLOG_XACTS_PER_BYTE) #define CLOG_XACT_BITMASK\t((1 \u003c\u003c CLOG_BITS_PER_XACT) - 1) So we can get the xid’s index and offset in page and byte.\n#define TransactionIdToPage(xid)\t((xid) / (TransactionId) CLOG_XACTS_PER_PAGE) #define TransactionIdToPgIndex(xid) ((xid) % (TransactionId) CLOG_XACTS_PER_PAGE) #define TransactionIdToByte(xid)\t(TransactionIdToPgIndex(xid) / CLOG_XACTS_PER_BYTE) #define TransactionIdToBIndex(xid)\t((xid) % (TransactionId) CLOG_XACTS_PER_BYTE) Thinking of that one slru segment contains 32 pages, so we name the clog file as 0000(contains xid in [0, 32 * CLOG_XACTS_PER_PAGE - 1]), 0001(contains xid in [32 * CLOG_XACTS_PER_PAGE, 32 * CLOG_XACTS_PER_PAGE * 2 - 1]) and so on. Because four hex numbers can represent $16^4=2^{12}$ files with $2^{12} \\times 32 \\times 8192 \\times 4 = 2^{32}$ transactions’ status(a int32 size)\nAttension, such simple mapping means that the pages in clog file don’t have page headers. So we can’t record LSN, checksum in each page. The lack of LSN means the changes of clog page wouldn’t be recorded in WAL but clog doesn’t need it indeed.","overview#Overview":"This chapter explains the content of clog\nclog(commit log), records the commit status of each transaction. The log exists both in memory mannaged by slru buffer and disk for durability. The commit status can be the four kinds below:\n#define TRANSACTION_STATUS_IN_PROGRESS\t0x00 #define TRANSACTION_STATUS_COMMITTED\t0x01 #define TRANSACTION_STATUS_ABORTED\t0x02 #define TRANSACTION_STATUS_SUB_COMMITTED\t0x03 ","record-changes-in-wal#Record changes in WAL":"Recall what mentioned above:\nExtending a new page and delete a segment will generata a WAL record. Setting commit status wouldn’t For the latter one, it’s unbelievable but tricky. Since only the transactions that changes the content data(some hint flags are exception, such as tuple infomask) will have a xid(and then record on clog segment). During the replay of such transactions’ commit(or abort) WAL record, we can redo the clog by the way.\nFor the former one, it’s a matter of course, since we must guarantee the clog to be recovery-safe. But some details deserve a glance;\nFor extending a new page, it makes no difference that we flush the WAL record now or later. Since once we want to set status in a non-existent page during recovery, we can padding a new empty page. This trick doesn’t affect the page usage. For deleting a clog segment, we have no chance to remedy the lost of clogs, and the disaster means a lot of tuple can be accessed at all. So regardless of the synchronous commit level, we must ensure the WAL record has flushed into disk before really delete the segments. ","set-and-get#Set And Get":"Concerned with subtransactions …\nI can’t totally figure out the commit tree without knowing the mechanism of subtransaction. Just assuming subxids as a set of xids related to the main xid seems not convictive enough for me. So I remain it here now and will finish it after reading subtransactions)\nFor now, it’s enough to knowing that\nThe pair of operations wouldn’t generate any WAL record They are done during the commit or abort procedure. "},"title":"CLOG"},"/postgresql/slru/slru/":{"data":{"":"","#":"本文主要为SLRU本身的结构解读。\n简述 slru用来干什么？ slru是一个简单的buffer管理模块，simple slru 有了buffer pool manager，为什么还要slru？ bpm管理通用的page，比如heap，vm等 slru最大的特点就是lru，非常适合处理xid这样，递增的信息。 下面的代码分析基于pg15 存储结构 与bpm不同，通过slru管理的page，其文件大小固定，一个文件有32个page，一个page有8KB，故一个文件最大为256K。\n与WAL不同，WAL文件的大小在创建时就已经确定为16M，与WAL文件重用保持一致，而slru的文件，先在内存中产生相应的page，再会去落盘。\n#define SLRU_PAGES_PER_SEGMENT\t32 内存slru 全局 buffer 数组 typedef struct SlruSharedData { LWLock\t*ControlLock; /* Number of buffers managed by this SLRU structure */ int\tnum_slots; /* * Arrays holding info for each buffer slot. Page number is undefined * when status is EMPTY, as is page_lru_count. */ char\t**page_buffer; SlruPageStatus *page_status; bool\t*page_dirty; int\t*page_number; int\t*page_lru_count; LWLockPadded *buffer_locks; XLogRecPtr *group_lsn; int\tlsn_groups_per_page; /*---------- * We mark a page \"most recently used\" by setting *\tpage_lru_count[slotno] = ++cur_lru_count; * The oldest page is therefore the one with the highest value of *\tcur_lru_count - page_lru_count[slotno] * The counts will eventually wrap around, but this calculation still * works as long as no page's age exceeds INT_MAX counts. *---------- */ int\tcur_lru_count; } SlruSharedData; 从内存结构上看，是一个数组，每个元素代表一个page。同时，记录这些page的使用次数。\npage_lru_count[slotno] = ++cur_lru_count; 同时每个page，都有状态标识，以在刷脏时，确定脏页。实际上这里没有脏页这个选项，因为只有 valid 状态的页才有可能是脏页，有包含关系。故在SlruSharedData 中使用 page_dirty 进行单独标识。\ntypedef enum { SLRU_PAGE_EMPTY,\t/* buffer is not in use */ SLRU_PAGE_READ_IN_PROGRESS, /* page is being read in */ SLRU_PAGE_VALID,\t/* page is valid and not being written */ SLRU_PAGE_WRITE_IN_PROGRESS /* page is being written out */ } SlruPageStatus; 关于为什么需要记录LSN信息 group_lsn：这与 WAL 设计有关。对于 WAL 而言，无论是同步提交或是异步提交，都需要在对应的 buffer page 落盘前落盘,所以 slru 也需要满足这样的规则。同时，可能是为了节约内存（节约的内存实在有限），或是减少WAL flush的调用次数以增加 IO 效率，slru的实现中并不记录每个buffer page的 LSN，而是记录一组 page 的 LSN，在刷下一个 page 前，需要把一组 page 中最大的 LSN 前的 WAL 落盘。而这样的“一组”的长度，就为lsn_groups_per_page\n各个进程私有的pointer /* * SlruCtlData is an unshared structure that points to the active information * in shared memory. */ typedef struct SlruCtlData { SlruShared\tshared; /* * Decide whether a page is \"older\" for truncation and as a hint for * evicting pages in LRU order. */ bool\t(*PagePrecedes) (int, int); /* * Dir is set during SimpleLruInit and does not change thereafter. Since * it's always the same, it doesn't need to be in shared memory. */ char\tDir[64]; } SlruCtlData; 初始化时，即返回一个SlruCtlData。Dir 是初始化时的标记，不同模块会填充对应的名称。\n核心功能 SimpleLruZeroPage：新增一个page SimpleLruReadPage ：读一个page SimpleLruWritePage ：写一个page 基础函数 选择一个空slot /* Select the slot to re-use when we need a free slot. */ /* Control lock must be held at entry, and will be held at exit. */ static int SlruSelectLRUPage(SlruCtl ctl, int pageno) { for (;;) # return if we have such a slot # return if we have an empty slot \"SLRU_PAGE_EMPTY\" # select a lru slot # return it if it's clean. Or # victim it if dirty # loop end -- It's a very clever design to dealing with corner cases # such as the victim page being re-dirtied while we wrote it. } 记录一个\"most recently used\"的page，cur_lru_count++ 并用其赋值 #define SlruRecentlyUsed(shared, slotno)\t\\ do { \\ int\tnew_lru_count = (shared)-\u003ecur_lru_count; \\ if (new_lru_count != (shared)-\u003epage_lru_count[slotno]) { \\ (shared)-\u003ecur_lru_count = ++new_lru_count; \\ (shared)-\u003epage_lru_count[slotno] = new_lru_count; \\ } \\ } while (0) 从磁盘中读取一个 page SlruPhysicalReadPage { int\tsegno = pageno / SLRU_PAGES_PER_SEGMENT; SlruFileName(ctl, path, segno); /* * In a crash-and-restart situation, it's possible for us to receive * commands to set the commit status of transactions whose bits are in * already-truncated segments of the commit log */ fd = OpenTransientFile(path, O_RDONLY | PG_BINARY); if (fd \u003c 0 \u0026\u0026 !InRecovery) ereport() pg_pread(fd, shared-\u003epage_buffer[slotno], BLCKSZ, offset) } 向磁盘中写入一个 page SlruPhysicalWritePage { /* We must flush WAL before flush slru pages */ if (shared-\u003egroup_lsn != NULL) { max_lsn = shared-\u003egroup_lsn[lsnindex++]; XLogFlush(max_lsn); } SlruFileName(ctl, path, segno); fd = OpenTransientFile(path, O_RDWR | O_CREAT | PG_BINARY); pg_pwrite(fd, shared-\u003epage_buffer[slotno], BLCKSZ, offset) /* Queue up a sync request for the checkpointer. */ ... } interface 新增一个 page 到buffer。 /* Initialize (or reinitialize) a page to zeroes. */ int SimpleLruZeroPage(SlruCtl ctl, int pageno) { slotno = SlruSelectLRUPage(ctl, pageno); SlruRecentlyUsed(shared, slotno); # SlruSelectLRUPage may return a in-use page, we must clear it MemSet(shared-\u003epage_buffer[slotno], 0, BLCKSZ); SimpleLruZeroLSNs(ctl, slotno); } 从 disk 中读取一个 page /* Control lock must be held at entry, and will be held at exit. */ SimpleLruReadPage { #infinite loop slotno = SlruSelectLRUPage(ctl, pageno); # for in IO slots, just wait /* update in-memory status */ shared-\u003epage_number[slotno] = pageno; shared-\u003epage_status[slotno] = SLRU_PAGE_READ_IN_PROGRESS; shared-\u003epage_dirty[slotno] = false; /* Acquire per-buffer lock and release control lock */ LWLockAcquire(\u0026shared-\u003ebuffer_locks[slotno].lock, LW_EXCLUSIVE); LWLockRelease(shared-\u003eControlLock); ok = SlruPhysicalReadPage(ctl, pageno, slotno); /* re-acquire control lock */ LWLockAcquire(shared-\u003eControlLock, LW_EXCLUSIVE); # others } 这里的锁设计很特别：\n在 SlruSelectLRUPage 需要获取全局锁 在 SimpleLruReadPage 中，先初始化内存，再获取 per-buffer 锁，同时释放 ControlLock 在看函数 SimpleLruZeroPage\n/* Control lock must be held at entry, and will be held at exit. */ SimpleLruZeroPage { slotno = SlruSelectLRUPage(ctl, pageno); shared-\u003epage_number[slotno] = pageno; shared-\u003epage_status[slotno] = SLRU_PAGE_VALID; shared-\u003epage_dirty[slotno] = true; } 难道，一旦获取 ControlLock，即可对任意 slot 进行修改？\n实际上，SimpleLruReadPage 读取的 page，必须已存在于磁盘（或者经由 WAL 来保证）。 而 SimpleLruZeroPage 所初始化的 page 必须不存在。从使用逻辑上保证二者不产生冲突。\nSimpleLruWritePage(SlruInternalWritePage) /* Control lock must be held at entry, and will be held at exit. */ SlruInternalWritePage { /* If a write is in progress, wait for it to finish */ /* Do nothing if page is not dirty */ /* update in-memory status */ shared-\u003epage_status[slotno] = SLRU_PAGE_WRITE_IN_PROGRESS; shared-\u003epage_dirty[slotno] = false; /* Acquire per-buffer lock and release control lock */ LWLockAcquire(\u0026shared-\u003ebuffer_locks[slotno].lock, LW_EXCLUSIVE); LWLockRelease(shared-\u003eControlLock); SlruPhysicalWritePage(ctl, pageno, slotno, fdata); /* re-acquire control lock */ LWLockAcquire(shared-\u003eControlLock, LW_EXCLUSIVE); shared-\u003epage_status[slotno] = SLRU_PAGE_VALID; } "},"title":"SLRU"},"/postgresql/ssl-in-pg/":{"data":{"":"","client-sides-authorization#Client sides Authorization":"Generate certification similarly\nopenssl req -new -x509 -days 3650 -nodes \\ -out ca-client.crt -keyout ca-client.key -subj \"/CN=root-client-ca\" openssl req -new -nodes -text -out client.csr \\ -keyout client.key -subj \"/CN=postgres\" openssl x509 -req -in client.csr -text -days 365 \\ -CA ca-client.crt -CAkey ca-client.key -CAcreateserial -out client.crt prepare in $PGDATA\ncp ca-client.crt $PGDATA/. echo -e \"\\nssl_ca_file = 'ca-client.crt'\" \u003e\u003e $PGDATA/postgresql.conf and restart\ntest connection Before connection, remember to set pg_hba.conf to only authorized with cetification.\nhostssl all all 127.0.0.1/32 cert psql \"sslrootcert=ca.crt sslcert=client.crt sslkey=client.key \\ host=127.0.0.1 dbname=postgres user=postgres sslmode=verify-full\" ","just-encrypt-internet-transmission#Just encrypt internet transmission":"build binary from source just configure with -with-openssl option. You may need to install ssl-dev tools first\nsudo apt-get install libssl-dev Below is a building example:\nexport build_dir=/home/dev/build export data_dir=/home/dev/data export superuser=postgres export defaultdb=test ${build_dir}/bin/pg_ctl -D ${data_dir} stop rm -rf build rm -rf data cd postgresql git clean -xdf ./configure \\ --prefix=${build_dir} \\ --enable-debug \\ --enable-cassert \\ --with-tcl \\ --with-perl \\ --with-python \\ --enable-debug \\ --without-icu \\ --with-openssl \\ CC=/usr/bin/gcc \\ CFLAGS='-O0 -pipe -Wall -g3' # export CLFAGS=\"-O0 -Wall -g3\" # export CPPLFAGS=\"-O0 -Wall -g3\" make -j8 \u0026\u0026 make install make -C contrib install ${build_dir}/bin/initdb --username=${superuser} --pgdata=${data_dir} ${build_dir}/bin/pg_ctl -D ${data_dir} -l ${data_dir}/logfile start ${build_dir}/bin/psql -U${superuser} postgres -c \"create database ${defaultdb};\" echo \"----------------- all finished -----------------------\" echo \"use ************** \" echo \"[ ${build_dir}/bin/psql -U${superuser} ${defaultdb} ] \" echo \"to connect postgresql\" cd .. Configure ssl on server prepare a certification use openssl command to generate one. The 127.0.0.1 means that the certification only protects localhost connections\n# generate root certification openssl req -new -x509 -days 3650 -nodes \\ -out ca.crt -keyout ca.key -subj \"/CN=root-server-ca\" # generate csr and key openssl req -new -nodes -text -out server.csr \\ -keyout server.key -subj \"/CN=127.0.0.1\" # generate certification openssl x509 -req -in server.csr -text -days 365 \\ -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt configure in $PGDATA copy the key and crt to $PGDATA\nexport $PGDATA=/home/dev/data cp server.key $PGDATA/. cp server.crt $PGDATA/. configure in postgresql.conf\nssl = on ssl_cert_file = 'server.crt' ssl_key_file = 'server.key' And (re)start the server\nconnect and test psql \"host=127.0.0.1 port=5432 dbname=postgres user=postgres sslmode=require\" ","overview#Overview":"In application level, ”PostgreSQL“ has native supports for using SSL connections. This requires that OpenSSL is installed on both client and server systems and that support in PostgreSQL is enabled at build time.\nWith SSL, we can:\nEncrypted data on Internet transmission Allow client to authorize the server(PostgreSQL), which can protect the client from connecting to the attacker’s server Allow server to authorize the client, which can stop the attacker from connecting to the database even if password leak. ","server-sides-authorization#Server sides Authorization":"Note that the client hasn’t check the certification of the server now. Check in this way:\nPGSSLROOTCERT=ca.crt \\ psql \"host=127.0.0.1 port=5432 dbname=postgres user=postgres sslmode=require\" "},"title":"SSL in PG"},"/postgresql/wal/":{"data":{"":"wal"},"title":"Wal"},"/postgresql/wal/wal-basic/":{"data":{"":" From access/transam/README","write-ahead-log-coding#Write-Ahead Log Coding":"基本思想，日志在数据页前落盘\nLSN：刷脏前检查LSN对应的日志已经落盘 优势：仅在必要的时候等待XLOG的IO。（异步IO） LSN的检查模块只用在 buffer manager 中实现 在WAL回放时，避免相同的日志被重复回放（可重入）。（TODO：full page write是否在另一个层面上保证了可重入） WAL 包含一个（或一小组）页的增量更新的重做信息。 依赖文件系统和硬件的原子写，不可靠！ checkpoint，checkpointer后的第一次写全页。通过 checkpoint 留下的 LSN 来判断是否为第一次写 写下WAL日志的逻辑为 pin and exclusive-lock the shared buffer START_CRIT_SECTION，发生错误时确保整个数据库能立即重启 在shared buffer上，进行对应的修改 标记为脏页， 必须在WAL日志写入前完成（TODO，为什么？SyncOneBuffer） 只有在要写WAL时，才能标记脏页（TODO，为什么？） 使用XLogBeginInsert 和 XLogRegister* 函数构建WAL，使用返回的LSN来更新page END_CRIT_SECTION，退出 解锁和unpin （注意顺序） 一些复杂的操作，需要原子地写下一串WAL记录，但中间状态必须自洽(self-consistent)。这样在回放wal日志时，如果中断，系统还能够正常运行。注意：此时相当于事务回滚，但是其部分更改已经落盘。举例：\n在btree索引中，页的分裂分为两步（1）分配一个新页（2）在上一层的页(parent page)中新插入一条数据。 但是因为锁，这会形成两个独立的WAL日志。在回放WAL日志时 回放第（1）个日志： 分配一个新页，将元组移动进去 设置标记位，表示上一层的页没有更新 回放第（2）个日志： 在上一层的页中新插入一条数据 清除第（1）个日志中的标记位 标志位通常情况下不可见，因为对 child page 的修改时持有的锁，在两个操作完成后才会释放。 仅在写下第（2）个日志前，数据库恰好崩溃，标志位才会被感知。（该标志位应该没有MVCC，否则会在事务层屏蔽） 搜索时，不管这个中间状态 插入时，如果发现这个中间状态，先在上一层的页插入对应key，以修复这个“崩溃”状态，再继续插入 "},"title":"WAL基础"},"/postgresql/wal/wal-insert/":{"data":{"":"","具体的插入方式#具体的插入方式":"上述代码中的XLogRecordAssemble和XLogInsertRecord已经概括了具体的插入步骤\nXLogRecordAssemble Assemble a WAL record from the registered data and buffers into an XLogRecData chain\nstatic XLogRecData * XLogRecordAssemble(RmgrId rmid, uint8 info, XLogRecPtr RedoRecPtr, bool doPageWrites, XLogRecPtr *fpw_lsn, int *num_fpi) { for (block_id = 0; block_id \u003c max_registered_block_id; block_id++) { if (needs_data) { rdt_datas_last-\u003enext = regbuf-\u003erdata_head; } } } ","接口函数#接口函数":"一个WAL记录包含\nWAL记录类型。（TODO不同的修改有不同的记录方式？） 这个页的修改方式 被修改的页的信息。被修改的页通过一个唯一ID标识，也可以有更多的关联数据（“record-specific data associated with the block”）。如果要写full page，就没有关联数据 构建一个WAL记录包含5个核心函数 void XLogBeginInsert(void) 初始化相关状态 如果当前无法构建WAL日志（例如在recovery模式），则报错 void XLogRegisterBuffer(uint8 block_id, Buffer buf, uint8 flags); 增加了数据块的信息；注册一个buffer的引用，相当于上述WAL日志的第三部分 block_id is an arbitrary number used to identify this page reference in the redo routine\n在redo阶段，可以根据这些信息找到需要redo的page regbuf = \u0026registered_buffers[block_id]; /* * Returns the relfilenode, fork number and block number associated with * a buffer */ BufferGetTag(buffer, \u0026regbuf-\u003ernode, \u0026regbuf-\u003eforkno, \u0026regbuf-\u003eblock); regbuf-\u003epage = BufferGetPage(buffer); regbuf-\u003eflags = flags; regbuf-\u003erdata_tail = (XLogRecData *) \u0026regbuf-\u003erdata_head; regbuf-\u003erdata_len = 0; registered_buffer的结构\ntypedef struct { /* xxx */ /* info to re-find the page */ ForkNumber\tforkno; BlockNumber block; Page\tpage; /* a loop-linked structure to store the data change of each buffer */ uint32 rdata_len; /* total length of data in rdata chain */ XLogRecData *rdata_head; /* head of the chain of data registered with * this block */ XLogRecData *rdata_tail;\t/* last entry in the chain, or \u0026rdata_head if * empty */ /* xxx */ } registered_buffer; typedef struct XLogRecData { struct XLogRecData *next; /* next struct in chain, or NULL */ char *data; /* start of rmgr data to include */ uint32 len; /* length of rmgr data to include */ } XLogRecData; void XLogRegisterData(char *data, int len); 向WAL日志中写入任意数据 可多次调用，保证连续。这样在rodo时，就可以得到连续的数据 rdata = \u0026rdatas[num_rdatas++]; rdata-\u003edata = data; rdata-\u003elen = len; void XLogRegisterBufData(uint8 block_id, char *data, int len); rdata = \u0026rdatas[num_rdatas++]; rdata-\u003edata = data; rdata-\u003elen = len; regbuf = \u0026registered_buffers[block_id]; regbuf-\u003erdata_tail-\u003enext = rdata; regbuf-\u003erdata_tail = rdata; regbuf-\u003erdata_len += len; 可见，XLogRegisterBufData 和 XLogRegisterData 的核心区别在，前者写入的数据会关联到具体的buffer，而后者没有\nXLogInsert Insert the record. do { GetFullPageWriteInfo(\u0026RedoRecPtr, \u0026doPageWrites); rdt = XLogRecordAssemble(rmid, info, RedoRecPtr, doPageWrites, \u0026fpw_lsn, \u0026num_fpi); EndPos = XLogInsertRecord(rdt, fpw_lsn, curinsert_flags, num_fpi); } while (EndPos == InvalidXLogRecPtr); ","数据结构汇总#数据结构汇总":"registered_buffers 每一个buffer对应registered_buffers中的一个元素（一个registered buffer）\nvoid XLogEnsureRecordSpace(int max_block_id, int ndatas) { if (nbuffers \u003e max_registered_buffers) { registered_buffers = (registered_buffer *) repalloc(registered_buffers, sizeof(registered_buffer) * nbuffers); max_registered_buffers = nbuffers; } } "},"title":"WAL日志的插入"}}