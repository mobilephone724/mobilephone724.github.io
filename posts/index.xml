<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 29 Aug 2025 21:05:24 +0800</lastBuildDate>
    <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>volatile in sigsetjmp and siglongjmp</title>
      <link>/posts/20250829-1-volatile/</link>
      <pubDate>Fri, 29 Aug 2025 21:05:24 +0800</pubDate>
      <guid>/posts/20250829-1-volatile/</guid>
      <description>&lt;h2 id=&#34;conclusion&#34;&gt;conclusion&lt;/h2&gt;&#xA;&lt;p&gt;In postgresql, the error handling methods &lt;code&gt;pg_try() + elog() + pg_catch()&lt;/code&gt; is implemented through &lt;code&gt;sigsetjmp&lt;/code&gt; and &lt;code&gt;siglongjmp&lt;/code&gt;. But the variables changed in &lt;code&gt;pg_try()&lt;/code&gt; and used in &lt;code&gt;pg_catch()&lt;/code&gt; must be declared as &lt;code&gt;volatile&lt;/code&gt;. The reasons are below:&lt;/p&gt;&#xA;&lt;h2 id=&#34;reason&#34;&gt;reason&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The sigsetjmp call must store all the register value and the siglongjmp restore the registers from it. It&amp;rsquo;s very reasonable in the view of asm code.&lt;/li&gt;&#xA;&lt;li&gt;If a variable is not declared as volatile, the assignment operation of it in &lt;code&gt;pg_try()&lt;/code&gt; may only changes the variable in the register. And after jumping by the &lt;code&gt;siglongjmp&lt;/code&gt; call, the value of variable is changed back to the point of &lt;code&gt;sigsetjmp&lt;/code&gt; , which means the changes in &lt;code&gt;pg_try()&lt;/code&gt; lost&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;example&#34;&gt;example&lt;/h2&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s consider an example:&lt;/p&gt;</description>
    </item>
    <item>
      <title>mesi-summary</title>
      <link>/post/me-z1ogd4d.html</link>
      <pubDate>Sat, 29 Mar 2025 08:56:22 +0800</pubDate>
      <guid>/post/me-z1ogd4d.html</guid>
      <description>&lt;h2 id=&#34;store-buffer&#34;&gt;store buffer&lt;/h2&gt;&#xA;&lt;h3 id=&#34;why&#34;&gt;why?&lt;/h3&gt;&#xA;&lt;p&gt;When a CPU wants to modify data (not in the &amp;ldquo;Modified&amp;rdquo; or &amp;ldquo;Exclusive&amp;rdquo; state), it will always update the data regardless of the responses from other CPUs.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Thus, the data is immediately updated in the store buffer.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;complexity-it-introduces&#34;&gt;complexity it introduces&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Multilayer caches (reason for write memory barrier):&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Example: Consider a CPU storing two values (A and B) sequentially, where A is in the store buffer and B is in the cache. It is uncertain whether another CPU will observe the updated A before observing B, as it depends on whether the invalidate message for A is received before the request for B.&lt;/li&gt;&#xA;&lt;li&gt;Reason: Broadcasting later changes (in the cache) before earlier changes (in the store buffer) are visible to others.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Write memory barrier&lt;/strong&gt;: CPUs must wait until the store buffer is cleared before applying subsequent changes. Alternatively, later changes can remain in the store buffer until all prior entries in the store buffer have been processed.&lt;/p&gt;</description>
    </item>
    <item>
      <title>【日拱一卒】2025-03-02</title>
      <link>/post/20250302-8ctcr.html</link>
      <pubDate>Sun, 02 Mar 2025 20:00:48 +0800</pubDate>
      <guid>/post/20250302-8ctcr.html</guid>
      <description>&lt;h1 id=&#34;2025-03-02&#34;&gt;2025-03-02&lt;/h1&gt;&#xA;&lt;h2 id=&#34;符文般的js&#34;&gt;符文般的JS&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-source&#34; data-lang=&#34;source&#34;&gt;0 = [+[]]+[]&#xA;1 = [+!+[]]+[]&#xA;10 = [+!+[]]+[+[]]&#xA;100 = [+!+[]]+[+[]]+[+[]]&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;1-0--&#34;&gt;1. &lt;code&gt;0 = [+[]]+[]&lt;/code&gt;​&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;​&lt;code&gt;[]&lt;/code&gt;​ 是一个空数组。&lt;/li&gt;&#xA;&lt;li&gt;​&lt;code&gt;+[]&lt;/code&gt;​ 将空数组转换为数字。空数组转换为数字时是 &lt;code&gt;0&lt;/code&gt;​，所以 &lt;code&gt;+[]&lt;/code&gt;​ 的结果是 &lt;code&gt;0&lt;/code&gt;​。&lt;/li&gt;&#xA;&lt;li&gt;​&lt;code&gt;[+[]]&lt;/code&gt;​ 将 &lt;code&gt;0&lt;/code&gt;​ 放入一个数组中，结果是 &lt;code&gt;[0]&lt;/code&gt;​。&lt;/li&gt;&#xA;&lt;li&gt;​&lt;code&gt;[+[]]+[]&lt;/code&gt;​ 将数组 &lt;code&gt;[0]&lt;/code&gt;​ 转换为字符串，结果是 &lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;​。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;最终结果：&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;​（字符串形式的 &lt;code&gt;0&lt;/code&gt;​）。&lt;/p&gt;</description>
    </item>
    <item>
      <title>【日拱一卒】2025-03-01</title>
      <link>/post/20250301-1r5xzc.html</link>
      <pubDate>Sat, 01 Mar 2025 15:14:45 +0800</pubDate>
      <guid>/post/20250301-1r5xzc.html</guid>
      <description>&lt;h2 id=&#34;column-oriented-storage&#34;&gt;Column-Oriented Storage&lt;/h2&gt;&#xA;&lt;h3 id=&#34;basic-idea&#34;&gt;Basic idea:&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Although fact tables are often over 100 columns wide, &lt;strong&gt;a typical data warehouse query only accesses 4 or 5 of them at one time&lt;/strong&gt; (&lt;code&gt;SELECT *&lt;/code&gt;​ queries are rarely needed for analytics)&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;The idea behind column-oriented storage is simple: &lt;strong&gt;don’t store all the values from one row together, but store all the values from each column together instead&lt;/strong&gt;. If each column is stored in a separate file, a query only needs to read and parse those columns that are used in that query, which can save a lot of work&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
