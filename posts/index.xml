<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>/posts/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 03 Sep 2025 21:01:17 +0800</lastBuildDate>
    <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PG: How to restart bgworker</title>
      <link>/posts/20250903-restart-pg-bgworker/</link>
      <pubDate>Wed, 03 Sep 2025 21:01:17 +0800</pubDate>
      <guid>/posts/20250903-restart-pg-bgworker/</guid>
      <description>&lt;h2 id=&#34;postmaster-的代码路径&#34;&gt;postmaster 的代码路径&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-txt&#34; data-lang=&#34;txt&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;-&amp;gt;ServerLoop&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt;WaitEventSetWait&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -&amp;gt;process_pm_child_exit&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    -&amp;gt;waitpid(-1, )&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    -&amp;gt;CleanupBackgroundWorker()&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;CleanupBackgroundWorker&lt;/code&gt; 的细节：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果bgworker以 0 退出，则正常退出，不参与重启逻辑。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果以 1 退出，进入后续的正常重启逻辑&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;否则，视为系统级 crash， 重启整个实例。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;关键变量：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;RegisteredBgWorker.rw_crashed_at&lt;/code&gt; 非 0 视为崩溃&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;HaveCrashedWorker&lt;/code&gt;  postmaster 在本轮循环是是否检测到了 bgworker 崩溃&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;StartWorkerNeeded&lt;/code&gt; 此刻是否需要重启 bgworker 。bgworker 支持设置重启间隔，所以 postmaster 在每次循环中，不总会重启所有崩溃的的 bgworker&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;appendix&#34;&gt;appendix&lt;/h2&gt;&#xA;&lt;h3 id=&#34;waitpid&#34;&gt;waitpid&lt;/h3&gt;&#xA;&lt;p&gt;(Generated from AI, haven&amp;rsquo;t been confirmed by myself)&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;while&lt;/span&gt; ((pid = &lt;span style=&#34;color:#ff0&#34;&gt;waitpid&lt;/span&gt;(-&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;, &amp;amp;exitstatus, WNOHANG)) &amp;gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If multiple child processes have already terminated before this loop runs:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;The loop will collect them one by one, in the order determined by the operating system&amp;rsquo;s process table&lt;/li&gt;&#xA;&lt;li&gt;Each iteration of the loop will retrieve one zombie process&lt;/li&gt;&#xA;&lt;li&gt;The loop will continue until all terminated child processes have been collected&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;When a child process terminates in a Unix/Linux system, it doesn&amp;rsquo;t immediately disappear from the system. Instead, it enters a &amp;ldquo;zombie&amp;rdquo; state (sometimes called a &amp;ldquo;defunct&amp;rdquo; state). In this state:&lt;/p&gt;</description>
    </item>
    <item>
      <title>volatile in sigsetjmp and siglongjmp</title>
      <link>/posts/20250829-volatile-in-sigsetjmp/</link>
      <pubDate>Fri, 29 Aug 2025 21:05:24 +0800</pubDate>
      <guid>/posts/20250829-volatile-in-sigsetjmp/</guid>
      <description>&lt;h2 id=&#34;conclusion&#34;&gt;conclusion&lt;/h2&gt;&#xA;&lt;p&gt;In postgresql, the error handling methods &lt;code&gt;pg_try() + elog() + pg_catch()&lt;/code&gt; is implemented through &lt;code&gt;sigsetjmp&lt;/code&gt; and &lt;code&gt;siglongjmp&lt;/code&gt;. But the variables changed in &lt;code&gt;pg_try()&lt;/code&gt; and used in &lt;code&gt;pg_catch()&lt;/code&gt; must be declared as &lt;code&gt;volatile&lt;/code&gt;. The reasons are below:&lt;/p&gt;&#xA;&lt;h2 id=&#34;reason&#34;&gt;reason&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The sigsetjmp call must store all the register value and the siglongjmp restore the registers from it. It&amp;rsquo;s very reasonable in the view of asm code.&lt;/li&gt;&#xA;&lt;li&gt;If a variable is not declared as volatile, the assignment operation of it in &lt;code&gt;pg_try()&lt;/code&gt; may only changes the variable in the register. And after jumping by the &lt;code&gt;siglongjmp&lt;/code&gt; call, the value of variable is changed back to the point of &lt;code&gt;sigsetjmp&lt;/code&gt; , which means the changes in &lt;code&gt;pg_try()&lt;/code&gt; lost&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;example&#34;&gt;example&lt;/h2&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s consider an example:&lt;/p&gt;</description>
    </item>
    <item>
      <title>mesi-summary</title>
      <link>/posts/20250329-mesi-summary/</link>
      <pubDate>Sat, 29 Mar 2025 21:05:24 +0800</pubDate>
      <guid>/posts/20250329-mesi-summary/</guid>
      <description>&lt;h2 id=&#34;store-buffer&#34;&gt;store buffer&lt;/h2&gt;&#xA;&lt;h3 id=&#34;why&#34;&gt;why?&lt;/h3&gt;&#xA;&lt;p&gt;When a CPU wants to modify data (not in the &amp;ldquo;Modified&amp;rdquo; or &amp;ldquo;Exclusive&amp;rdquo; state), it will always update the data regardless of the responses from other CPUs.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Thus, the data is immediately updated in the store buffer.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;complexity-it-introduces&#34;&gt;complexity it introduces&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Multilayer caches (reason for write memory barrier):&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Example: Consider a CPU storing two values (A and B) sequentially, where A is in the store buffer and B is in the cache. It is uncertain whether another CPU will observe the updated A before observing B, as it depends on whether the invalidate message for A is received before the request for B.&lt;/li&gt;&#xA;&lt;li&gt;Reason: Broadcasting later changes (in the cache) before earlier changes (in the store buffer) are visible to others.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;Write memory barrier&lt;/strong&gt;: CPUs must wait until the store buffer is cleared before applying subsequent changes. Alternatively, later changes can remain in the store buffer until all prior entries in the store buffer have been processed.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
