<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>较长的专题文章 on </title>
    <link>//localhost:1313/posts/archives/article/</link>
    <description>Recent content in 较长的专题文章 on </description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sun, 07 Jul 2024 15:53:54 +0800</lastBuildDate>
    <atom:link href="//localhost:1313/posts/archives/article/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>constant recovery with undo</title>
      <link>//localhost:1313/posts/archives/article/constant_recovery/</link>
      <pubDate>Sun, 07 Jul 2024 15:53:54 +0800</pubDate>
      <guid>//localhost:1313/posts/archives/article/constant_recovery/</guid>
      <description>&lt;h2 id=&#34;0x0-backgroud&#34;&gt;0x0 backgroud&lt;/h2&gt;&#xA;&lt;p&gt;Even though ARIES simplifies the recovery process and allows it to be generic for all transactional operations, &lt;strong&gt;recovering the database to a consistent state requires undoing all operations performed by uncommitted transactions&lt;/strong&gt; which makes the cost of recovery proportional to the work performed by these transactions. This significantly impacts database availability since &lt;strong&gt;recovering a long running transaction can take several hours&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;p&gt;This paper describes the overall design of “&lt;strong&gt;Constant Time Recovery&lt;/strong&gt;” (CTR)&lt;/p&gt;</description>
    </item>
    <item>
      <title>MESI AND MEMORY_BARRIER: paper reading</title>
      <link>//localhost:1313/posts/archives/article/mesi/</link>
      <pubDate>Sun, 16 Jun 2024 01:12:36 +0800</pubDate>
      <guid>//localhost:1313/posts/archives/article/mesi/</guid>
      <description>&lt;ul&gt;&#xA;&lt;li&gt;paper&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Introduction: &lt;a href=&#34;https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/memory_barrier_withMarginNotes.2024_06_16_1718472482.pdf&#34;&gt;Memory Barriers: a Hardware View for Software Hackers&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;0x0-why-we-need-memory-barrier&#34;&gt;0x0 why we need memory barrier&lt;/h2&gt;&#xA;&lt;p&gt;In short, because &lt;strong&gt;reordering memory references allows much better performance&lt;/strong&gt;, and so memory barriers are needed to force ordering in things like synchronization primitives whose &lt;strong&gt;correct operation depends on ordered memory references&lt;/strong&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;0x1-cache-structure&#34;&gt;0x1 &lt;strong&gt;Cache Structure&lt;/strong&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/Untitled.2024_06_17_1718631318.png&#34; alt=&#34;Untitled&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;0x11-some-cases-of-cache-missnot-important&#34;&gt;0x11 some cases of cache miss(not important)&lt;/h3&gt;&#xA;&lt;p&gt;The cache miss means that the CPU will have to wait (or be “stalled”) for hundreds of cycles while the item is fetched from memory.&lt;/p&gt;</description>
    </item>
    <item>
      <title>roaring bitmap</title>
      <link>//localhost:1313/posts/archives/article/roaring_bitmap/</link>
      <pubDate>Tue, 07 May 2024 21:04:38 +0800</pubDate>
      <guid>//localhost:1313/posts/archives/article/roaring_bitmap/</guid>
      <description>&lt;h2 id=&#34;0x0-introduction&#34;&gt;0x0 Introduction&lt;/h2&gt;&#xA;&lt;p&gt;A bitmap, also known as a bit array or bitset, is a data structure that represents a fixed-size sequence of bits.  That is the value of the &lt;em&gt;ith&lt;/em&gt; bit representing the existence of the the &lt;em&gt;ith object.&lt;/em&gt;&#xA;Bare bitmap can cost much memory according to the total substantial data size, even if we have stored little infomation. Roaring bitmap provide a new method to compress the bitmap structure.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CLOG</title>
      <link>//localhost:1313/posts/archives/article/clog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/archives/article/clog/</guid>
      <description>&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;&#xA;&lt;p&gt;This chapter explains the content of &lt;code&gt;clog&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;clog&lt;/code&gt;(commit log), records the commit status of each transaction. The log&#xA;exists both in memory mannaged by &lt;code&gt;slru&lt;/code&gt; buffer and disk for durability. The&#xA;commit status can be the four kinds below:&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;#define TRANSACTION_STATUS_IN_PROGRESS&#x9;&#x9;0x00&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;#define TRANSACTION_STATUS_COMMITTED&#x9;&#x9;0x01&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;#define TRANSACTION_STATUS_ABORTED&#x9;&#x9;&#x9;0x02&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;#define TRANSACTION_STATUS_SUB_COMMITTED&#x9;0x03&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;in-disk-representation&#34;&gt;In-Disk Representation&lt;/h2&gt;&#xA;&lt;p&gt;Thinking that the commit status of each transaction composites an array &lt;code&gt;clog[]&lt;/code&gt;&#xA;and &lt;code&gt;clog[xid]&lt;/code&gt; records the status, we can easily store the array to disk by the&#xA;&lt;code&gt;slru&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>hash join</title>
      <link>//localhost:1313/posts/archives/article/hashjoin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/archives/article/hashjoin/</guid>
      <description>&lt;h2 id=&#34;high-level-view&#34;&gt;high level view&lt;/h2&gt;&#xA;&lt;p&gt;See &lt;a href=&#34;https://postgrespro.com/blog/pgsql/5969673&#34;&gt;Queries in PostgreSQL: 6. Hashing&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;one-pass-hash-join&#34;&gt;One-pass hash join&lt;/h3&gt;&#xA;&lt;p&gt;Note that join in PostgreSql, we scan the right relation first, which means that&#xA;the right relation is the &amp;ldquo;inner relation&amp;rdquo; and the left relation is the outer&#xA;one.&#xA;&lt;img src=&#34;https://mobilephone724.oss-cn-beijing.aliyuncs.com/blog/database/hashjoin/One-pass_hash_join.svg&#34; alt=&#34;Alt text&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;two-pass-hash-join&#34;&gt;Two-pass hash join&lt;/h3&gt;&#xA;&lt;p&gt;Since we can&amp;rsquo;t allocate as much memory as we want, instead of building a hash&#xA;table of the entire table, PG split the tables to several &lt;code&gt;batches&lt;/code&gt; where all&#xA;tuples have the same hash value flag.&lt;/p&gt;</description>
    </item>
    <item>
      <title>pg_repack</title>
      <link>//localhost:1313/posts/archives/article/pg_repack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/archives/article/pg_repack/</guid>
      <description>&lt;h2 id=&#34;principle&#34;&gt;principle&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://reorg.github.io/pg_repack/&#34;&gt;pg_repack 1.5.0 &amp;ndash; Reorganize tables in PostgreSQL databases with minimal locks&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/reorg/pg_repack&#34;&gt;https://github.com/reorg/pg_repack&lt;/a&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;create a log table to record changes made to the original table&lt;/li&gt;&#xA;&lt;li&gt;add a trigger onto the original table, logging INSERTs, UPDATEs and DELETEs into our log table&lt;/li&gt;&#xA;&lt;li&gt;create a new table containing all the rows in the old table&lt;/li&gt;&#xA;&lt;li&gt;build indexes on this new table&lt;/li&gt;&#xA;&lt;li&gt;apply all changes which have accrued in the log table to the new table&lt;/li&gt;&#xA;&lt;li&gt;swap the tables, including indexes and toast tables, using the system catalogs&lt;/li&gt;&#xA;&lt;li&gt;drop the original table&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;The basic idea is&lt;/p&gt;</description>
    </item>
    <item>
      <title>PGVECTOR AND VECTOR DATABASE</title>
      <link>//localhost:1313/posts/archives/article/pgvector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/archives/article/pgvector/</guid>
      <description>&lt;h2 id=&#34;序言&#34;&gt;序言&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;pgvector&lt;/code&gt;是一个向量搜索（根据近似度）的插件，用来加速AKNN（approximate nearest neighbor）。&#xA;&lt;code&gt;PASE&lt;/code&gt;中提到，向量ANN算法包括4类&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;tree-based algorithms&#xA;&lt;ol&gt;&#xA;&lt;li&gt;KD-Tree&lt;/li&gt;&#xA;&lt;li&gt;RTree&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;quantization-based algorithms&#xA;&lt;ol&gt;&#xA;&lt;li&gt;IVFFlat&lt;/li&gt;&#xA;&lt;li&gt;IVFADC&lt;/li&gt;&#xA;&lt;li&gt;IMI&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;graph based algorithms&#xA;&lt;ol&gt;&#xA;&lt;li&gt;HNSW&lt;/li&gt;&#xA;&lt;li&gt;NSG&lt;/li&gt;&#xA;&lt;li&gt;SSG&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;hash-base algorithms&#xA;&lt;ol&gt;&#xA;&lt;li&gt;LSH&#xA;&lt;code&gt;pgvector&lt;/code&gt; 包括两个算法，&lt;code&gt;IVFFlat&lt;/code&gt; 和 &lt;code&gt;HNSW&lt;/code&gt;，后续内容将以这两个算法的内容及其实现展开。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;ivfflat&#34;&gt;IVFFlat&lt;/h2&gt;&#xA;&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;&#xA;&lt;p&gt;IVFFlat 算法主要包括以下几个步骤&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;索引构建阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;KMeans&lt;/code&gt; 将数据集划分成多个簇(cluster)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;查询阶段&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过每个簇的中心点（向量是高维的点）获取N个最近的簇&lt;/li&gt;&#xA;&lt;li&gt;遍历这N个簇的所有点，从中找到最近的K个点&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;算法介绍&#34;&gt;算法介绍&lt;/h3&gt;&#xA;&lt;h4 id=&#34;基础算法kmeans&#34;&gt;基础算法kmeans&lt;/h4&gt;&#xA;&lt;p&gt;reference &lt;a href=&#34;https://en.wikipedia.org/wiki/K-means_clustering&#34;&gt;k-means clustering - Wikipedia&lt;/a&gt;&#xA;算法目标：选取K个中心点，使得数据集中的所有点到其最近的中心点“距离”之和最近，以平方和距离为例：&lt;/p&gt;&#xA;&lt;p&gt;Given a set of observations $(x_1, x_2, \dots, x_n)$, where each observation is a $d$-dimensional real vector, k-means clustering aims to partition the $n$ observations into $k$ ($\leq n$) sets $S = {S_1, S_2, \dot, S_k}$ so as to minimize the within-cluster sum of squares (WCSS). Formally, the objective is to find:&#xA;&lt;img src=&#34;https://raw.githubusercontent.com/mobilephone724/blog_pictures/master/kmeans_target.2024_02_12_1707672348.png&#34; alt=&#34;&#34;&gt;&#xA;算法过程：&#xA;&lt;strong&gt;我们可以很容易的证明目标函数是关于$S$的凸函数&lt;/strong&gt;&#xA;Given an initial set of $k$ means $m_1^{1}, \dots , m_k^{(1)}$ (see below), the algorithm proceeds by alternating between two steps:&lt;/p&gt;</description>
    </item>
    <item>
      <title>SLRU</title>
      <link>//localhost:1313/posts/archives/article/slru/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/archives/article/slru/</guid>
      <description>&lt;p&gt;本文主要为&lt;code&gt;SLRU&lt;/code&gt;本身的结构解读。&lt;/p&gt;&#xA;&lt;h3 id=&#34;简述&#34;&gt;简述&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;slru用来干什么？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;slru是一个简单的buffer管理模块，simple slru&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;有了buffer pool manager，为什么还要slru？&#xA;&lt;ul&gt;&#xA;&lt;li&gt;bpm管理通用的page，比如heap，vm等&lt;/li&gt;&#xA;&lt;li&gt;slru最大的特点就是lru，非常适合处理xid这样，递增的信息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;下面的代码分析基于pg15&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;存储结构&#34;&gt;存储结构&lt;/h3&gt;&#xA;&lt;p&gt;与bpm不同，通过slru管理的page，其文件大小固定，一个文件有32个page，一个page有8KB，故一个文件最大为256K。&lt;/p&gt;&#xA;&lt;p&gt;与WAL不同，WAL文件的大小在创建时就已经确定为16M，与WAL文件重用保持一致，而slru的文件，先在内存中产生相应的page，再会去落盘。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e5e5e5&#34;&gt;#define SLRU_PAGES_PER_SEGMENT&#x9;32&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;内存slru&#34;&gt;内存slru&lt;/h4&gt;&#xA;&lt;h5 id=&#34;全局-buffer-数组&#34;&gt;全局 buffer 数组&lt;/h5&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f00&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#f00&#34;&gt;struct&lt;/span&gt; SlruSharedData&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;LWLock&#x9;   *ControlLock;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#0f0&#34;&gt;/* Number of buffers managed by this SLRU structure */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;&#x9;&#x9;&#x9;num_slots;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#0f0&#34;&gt;/*&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; * Arrays holding info for each buffer slot.  Page number is undefined&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; * when status is EMPTY, as is page_lru_count.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ee82ee&#34;&gt;char&lt;/span&gt;&#x9;  **page_buffer;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;SlruPageStatus *page_status;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ee82ee&#34;&gt;bool&lt;/span&gt;&#x9;   *page_dirty;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;&#x9;&#x9;   *page_number;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;&#x9;&#x9;   *page_lru_count;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;LWLockPadded *buffer_locks;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    XLogRecPtr *group_lsn;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;&#x9;&#x9;&#x9;lsn_groups_per_page;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#0f0&#34;&gt;/*----------&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; * We mark a page &amp;#34;most recently used&amp;#34; by setting&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; *&#x9;&#x9;page_lru_count[slotno] = ++cur_lru_count;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; * The oldest page is therefore the one with the highest value of&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; *&#x9;&#x9;cur_lru_count - page_lru_count[slotno]&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; * The counts will eventually wrap around, but this calculation still&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; * works as long as no page&amp;#39;s age exceeds INT_MAX counts.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; *----------&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0f0&#34;&gt;&#x9; */&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;&lt;span style=&#34;color:#ee82ee&#34;&gt;int&lt;/span&gt;&#x9;&#x9;&#x9;cur_lru_count;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} SlruSharedData;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;从内存结构上看，是一个数组，每个元素代表一个page。同时，记录这些page的使用次数。&lt;/p&gt;</description>
    </item>
    <item>
      <title>WAL基础</title>
      <link>//localhost:1313/posts/archives/article/wal-basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/archives/article/wal-basic/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;From &lt;code&gt;access/transam/README&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;write-ahead-log-coding&#34;&gt;Write-Ahead Log Coding&lt;/h2&gt;&#xA;&lt;p&gt;基本思想，日志在数据页前落盘&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;LSN&lt;/code&gt;：刷脏前检查&lt;code&gt;LSN&lt;/code&gt;对应的日志已经落盘&#xA;&lt;ol&gt;&#xA;&lt;li&gt;优势：仅在必要的时候等待&lt;code&gt;XLOG&lt;/code&gt;的&lt;code&gt;IO&lt;/code&gt;。（异步&lt;code&gt;IO&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;LSN&lt;/code&gt;的检查模块只用在 buffer manager 中实现&lt;/li&gt;&#xA;&lt;li&gt;在WAL回放时，避免相同的日志被重复回放（可重入）。（TODO：full page write是否在另一个层面上保证了可重入）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;WAL 包含一个（或一小组）页的&lt;strong&gt;增量更新&lt;/strong&gt;的重做信息。&#xA;&lt;ol&gt;&#xA;&lt;li&gt;依赖文件系统和硬件的原子写，不可靠！&lt;/li&gt;&#xA;&lt;li&gt;checkpoint，checkpointer后的第一次写全页。通过 checkpoint 留下的 &lt;code&gt;LSN &lt;/code&gt; 来判断是否为第一次写&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;写下WAL日志的逻辑为&#xA;&lt;ol&gt;&#xA;&lt;li&gt;pin and exclusive-lock the shared buffer&lt;/li&gt;&#xA;&lt;li&gt;START_CRIT_SECTION，发生错误时确保整个数据库能立即重启&lt;/li&gt;&#xA;&lt;li&gt;在shared buffer上，进行对应的修改&lt;/li&gt;&#xA;&lt;li&gt;标记为脏页，&#xA;&lt;ol&gt;&#xA;&lt;li&gt;必须在WAL日志写入前完成（TODO，为什么？&lt;code&gt;SyncOneBuffer&lt;/code&gt;）&lt;/li&gt;&#xA;&lt;li&gt;只有在要写WAL时，才能标记脏页（TODO，为什么？）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;使用&lt;code&gt;XLogBeginInsert&lt;/code&gt; 和 &lt;code&gt;XLogRegister*&lt;/code&gt; 函数构建WAL，使用返回的&lt;code&gt;LSN&lt;/code&gt;来更新&lt;code&gt;page&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;END_CRIT_SECTION，退出&lt;/li&gt;&#xA;&lt;li&gt;解锁和unpin （注意顺序）&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;一些复杂的操作，需要原子地写下一串WAL记录，但中间状态必须自洽(self-consistent)。这样在回放wal日志时，如果中断，系统还能够正常运行。注意：此时相当于事务回滚，但是其部分更改已经落盘。举例：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在btree索引中，页的分裂分为两步（1）分配一个新页（2）在上一层的页(parent page)中新插入一条数据。&lt;/li&gt;&#xA;&lt;li&gt;但是因为锁，这会形成两个独立的WAL日志。在回放WAL日志时&#xA;&lt;ul&gt;&#xA;&lt;li&gt;回放第（1）个日志：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;分配一个新页，将元组移动进去&lt;/li&gt;&#xA;&lt;li&gt;设置标记位，表示上一层的页没有更新&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;回放第（2）个日志：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;在上一层的页中新插入一条数据&lt;/li&gt;&#xA;&lt;li&gt;清除第（1）个日志中的标记位&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;标志位通常情况下不可见，因为对 child page 的修改时持有的锁，在两个操作完成后才会释放。&lt;/li&gt;&#xA;&lt;li&gt;仅在写下第（2）个日志前，数据库恰好崩溃，标志位才会被感知。（该标志位应该没有MVCC，否则会在事务层屏蔽）&#xA;&lt;ul&gt;&#xA;&lt;li&gt;搜索时，不管这个中间状态&lt;/li&gt;&#xA;&lt;li&gt;插入时，如果发现这个中间状态，先在上一层的页插入对应key，以修复这个“崩溃”状态，再继续插入&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>WAL日志的插入</title>
      <link>//localhost:1313/posts/archives/article/wal-insert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/archives/article/wal-insert/</guid>
      <description>&lt;h2 id=&#34;接口函数&#34;&gt;接口函数&lt;/h2&gt;&#xA;&lt;p&gt;一个WAL记录包含&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;WAL记录类型。（TODO不同的修改有不同的记录方式？）&lt;/li&gt;&#xA;&lt;li&gt;这个页的修改方式&lt;/li&gt;&#xA;&lt;li&gt;被修改的页的信息。被修改的页通过一个唯一ID标识，也可以有更多的关联数据（&amp;ldquo;record-specific data associated with the block&amp;rdquo;）。如果要写full page，就没有关联数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;构建一个wal记录包含5个核心函数&#34;&gt;构建一个WAL记录包含5个核心函数&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;void XLogBeginInsert(void)&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化相关状态&lt;/li&gt;&#xA;&lt;li&gt;如果当前无法构建WAL日志（例如在recovery模式），则报错&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;void XLogRegisterBuffer(uint8 block_id, Buffer buf, uint8 flags);&lt;/code&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;增加了数据块的信息；注册一个buffer的引用，相当于上述WAL日志的第三部分&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;block_id is an arbitrary number used to identify this page reference in the redo routine&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;在redo阶段，可以根据这些信息找到需要redo的page&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;    regbuf = &amp;amp;registered_buffers[block_id];&#xA;    /*&#xA;     * Returns the relfilenode, fork number and block number associated with&#xA;     * a buffer&#xA;     */&#xA;    BufferGetTag(buffer, &amp;amp;regbuf-&amp;gt;rnode, &amp;amp;regbuf-&amp;gt;forkno, &amp;amp;regbuf-&amp;gt;block);&#xA;    regbuf-&amp;gt;page = BufferGetPage(buffer);&#xA;    regbuf-&amp;gt;flags = flags;&#xA;    regbuf-&amp;gt;rdata_tail = (XLogRecData *) &amp;amp;regbuf-&amp;gt;rdata_head;&#xA;    regbuf-&amp;gt;rdata_len = 0;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;registered_buffer的结构&lt;/p&gt;</description>
    </item>
    <item>
      <title>ZERO TO RSA</title>
      <link>//localhost:1313/posts/archives/article/zero2rsa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/posts/archives/article/zero2rsa/</guid>
      <description>&lt;h2 id=&#34;从0证明rsa&#34;&gt;从0证明RSA&lt;/h2&gt;&#xA;&lt;p&gt;RSA 算法（即一个非对称加密算法）除了应用非常广泛外，其特性也非常吸引人（起码非常吸引我）。我在网上找了很多关于RSA的证明，要么不够详细（例如缺失对前置定理的证明），要么需要引出较多复杂的数论概念。作者本身水平不高，试图绕过这些复杂的概念，从初等数学的开始，完备地证明RSA。&lt;/p&gt;&#xA;&lt;p&gt;关于RSA的背景知识可能很多，可以慢慢阅读，我在此尝试从初等数学开始证明。这些背景知识的证明有一定的顺序，如果读者发现某个证明看不懂，可以向前翻阅。&lt;/p&gt;&#xA;&lt;p&gt;参考的文章如下：（因为参考的文章太多，大概率不全）&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86&#34;&gt;费马小定理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86&#34;&gt;中国剩余定理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&#34;&gt;阮一峰的博客——RSA算法原理（一）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&#34;&gt;阮一峰的博客——RSA算法原理（二）&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/35060143&#34;&gt;初等数论笔记Part 1： 欧拉定理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/100587745&#34;&gt;算法学习笔记(9)：逆元&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;费马小定理&#34;&gt;费马小定理&lt;/h2&gt;&#xA;&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;&#xA;&lt;p&gt;如果 $p$ 是质数且 $\mathrm{gcd}(a,p)=1$ , 那么 $a^{p-1}\equiv 1\ (\mathrm{mod}\ p)$&lt;/p&gt;&#xA;&lt;p&gt;在证明该定理前，先证明一个简单的引理&lt;/p&gt;&#xA;&lt;h3 id=&#34;引理1&#34;&gt;引理1&lt;/h3&gt;&#xA;&lt;p&gt;如果 $p$ 是质数，且 $\mathrm{gcd}(a,p)=1$ , 那么&lt;/p&gt;&#xA;&lt;p&gt;$$&#xA;\lbrace ka \ \mathrm{mod}\ p | k = \lbrace 1,2,&amp;hellip;,p -1 \rbrace \rbrace= \lbrace 1,2,3,&amp;hellip;,p-1 \rbrace&#xA;$$&lt;/p&gt;&#xA;&lt;p&gt;即二者存在一对一的关系。由于这两个集合的元素个数相同，所以只要证明左侧集合没有重复元素即可&lt;/p&gt;&#xA;&lt;p&gt;证明：假设存在 $k_1$ 和 $k_2$ 满足 $1 \leq k_1 &amp;lt; k_2 \leq p-1$ ，且 $k_1a\ \mathrm{mod}\ p = k_2a\ \mathrm{mod}\ p$ . 那么可知&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
