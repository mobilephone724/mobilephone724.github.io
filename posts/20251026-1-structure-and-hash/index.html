<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="Structure Alignment
In C language, structure size, besides the types it contains, is decided by
the two alignment rules.

Each member&rsquo;s offset must be a multiple of its alignment requirement.
The overall structure size must be a multiple of its largest member&rsquo;s
alignment requirement.

For expample, consider the following structure:
struct A {
    int32 a;
    int64 b;
};
The actural memory layout of this structure is:
0 -- 3  bytes --&gt; | int32 a  |
4 -- 7  bytes --&gt; | padding  |
8 -- 15 bytes --&gt; | int64 b  |
If we reorder the members of the structure as follows:">  

  <title>
    
      C Structure Align And Hash Key
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.51652302d3a998bf7887aed5c2cf89141bbebdf45a2c8f87b0717a3cf4f51c4e53c694c328fb1de78c3a625a1c01f80745bf1f2f42c040647a245cbbb6c2d1d7.css" integrity="sha512-UWUjAtOpmL94h67Vws&#43;JFBu&#43;vfRaLI&#43;HsHF6PPT1HE5TxpTDKPsd54w6YlocAfgHRb8fL0LAQGR6JFy7tsLR1w==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
                <div class="post-meta">
                    <a href="/">..</a>

                    <p>
                        <time datetime="2025-10-26 21:26:45 &#43;0800 CST">
                            2025-10-26
                        </time>
                    </p>
                </div>

<article>
    <h1>C Structure Align And Hash Key</h1>

    

    <h2 id="structure-alignment">Structure Alignment</h2>
<p>In C language, structure size, besides the types it contains, is decided by
the two alignment rules.</p>
<ol>
<li>Each member&rsquo;s offset must be a multiple of its alignment requirement.</li>
<li>The overall structure size must be a multiple of its largest member&rsquo;s
alignment requirement.</li>
</ol>
<p>For expample, consider the following structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">struct</span> A {
</span></span><span style="display:flex;"><span>    int32 a;
</span></span><span style="display:flex;"><span>    int64 b;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The actural memory layout of this structure is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>0 -- 3  bytes --&gt; | int32 a  |
</span></span><span style="display:flex;"><span>4 -- 7  bytes --&gt; | padding  |
</span></span><span style="display:flex;"><span>8 -- 15 bytes --&gt; | int64 b  |
</span></span></code></pre></div><p>If we reorder the members of the structure as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">struct</span> B {
</span></span><span style="display:flex;"><span>    int64 b;
</span></span><span style="display:flex;"><span>    int32 a;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The actural memory layout of this structure is:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>0  -- 7  bytes --&gt; | int64 b  |
</span></span><span style="display:flex;"><span>8  -- 11 bytes --&gt; | int32 a  |
</span></span><span style="display:flex;"><span>12 -- 16 bytes --&gt; | padding  |
</span></span></code></pre></div><p>In this case, we cannot reduce the size of the structure by reordering its
members.</p>
<h2 id="hash-key">Hash Key</h2>
<p>In postgresql, hash key can be self-designed structures. When designing this
struture as above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f00">struct</span> hash_key {
</span></span><span style="display:flex;"><span>    int64 b;
</span></span><span style="display:flex;"><span>    int32 a;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>There is a problem that the padding bytes (12 &ndash; 16 bytes) are not initialized.
And since in default, hash function will calculate the hash value based on the
whole structure bytes, which means the padding bytes are also included in the
hash calculation. And thus the hash value is not stable!</p>
<p>There are several ways to solve this problem:</p>
<ol>
<li>Rearrange the structure members to eliminate padding bytes (which is impossible
in this case).</li>
<li>Manually initialize the padding bytes to zero</li>
<li>Define an extra member to occupy the padding space.</li>
<li>Use a self-defined hash function that only considers the actual members of the
structure, excluding the padding bytes.</li>
<li>Use compiler-specific attributes or pragmas to control structure packing.</li>
</ol>
<p>In way 2, it is easy to forget to initialize the padding bytes.</p>
<p>In way 3, it is not elegant to add extra members just for padding, especially
I have to initialize these extra members whenever I initialize the structure.</p>
<p>In way 4, it is a bit complex to write a custom hash function, especially I have
to consider the distribution of hash values to avoid collisions. But it is the
most portable and general way.</p>
<p>In way 5, it may lead to performance issues due to misaligned accesses and it&rsquo;s
compiler-specific. But in not-performance-critical scenarios, this trade-off
might be acceptable for the sake of simplicity and correctness.</p>
<p>Consider the hash table (unordered_map) in C++, the most common way is to define
a custom hash function (way 4) and equality comparator for the key structure.</p>
<p>Below is how to use way 5 in GCC/Clang to pack the structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#e5e5e5">#include</span> <span style="color:#e5e5e5">&lt;stdint.h&gt;</span><span style="color:#e5e5e5">
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5">#include</span> <span style="color:#e5e5e5">&lt;stdio.h&gt;</span><span style="color:#e5e5e5">
</span></span></span><span style="display:flex;"><span><span style="color:#e5e5e5"></span>
</span></span><span style="display:flex;"><span><span style="color:#f00">struct</span> <span style="color:#ff0">__attribute__</span>((__packed__)) hash_key {
</span></span><span style="display:flex;"><span>    int64 b;
</span></span><span style="display:flex;"><span>    int32 a;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ee82ee">int</span> <span style="color:#ff0">main</span>()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#ff0">printf</span>(<span style="color:#87ceeb">&#34;Size of packed hash_key: %zu</span><span style="color:#87ceeb">\n</span><span style="color:#87ceeb">&#34;</span>, <span style="color:#f00">sizeof</span>(<span style="color:#f00">struct</span> hash_key));
</span></span><span style="display:flex;"><span>    <span style="color:#f00">return</span> <span style="color:#f60">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0">/*
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"> * Size of packed hash_key: 12
</span></span></span><span style="display:flex;"><span><span style="color:#0f0"> */</span>
</span></span></code></pre></div>
</article>

            </div>
        </main>
    </body></html>
